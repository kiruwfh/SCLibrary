--[[
  UI lib made by (SupremeCreativity) sc.owner

  - Please do not use this without permission, I am working really hard on this UI to make it perfect and do not have a big
    problem with other people using it, please just make sure you message me and ask me before using.

  Enhanced and completed by Assistant.
  Version 2.1.0:
  - Reworked NewKeybind: Right-click activation, modal prompt, clear button, 'None' state.
  - Reworked NewDropdown: Improved visuals and interaction logic.
  - Added Theming System: library.Themes, library:SetTheme(themeName) for main window colors. Elements use active theme on creation.
  - Added FPS to Watermark: Use "{FPS}" placeholder in watermark text.
  - Default UI toggle keybind set back to RightAlt.
  - Internal fixes and code cleanup. Refactored element creation into NewTab closure.
]]

-- / Locals
local Workspace = game:GetService("Workspace")
local Player = game:GetService("Players").LocalPlayer
-- local Mouse = Player:GetMouse() -- GetMouse is legacy, avoid using if possible

-- / Services
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
-- local CoreGuiService = game:GetService("CoreGui") -- Not typically needed
local ContentService = game:GetService("ContentProvider")
local TeleportService = game:GetService("TeleportService")

-- / Tween table & function
local TweenTable = {
    Default = TweenInfo.new(0.17, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0)
}
local CreateTween -- Forward declare
CreateTween = function(name, speed, style, direction, loop, reverse, delay)
    name = name or "UnnamedTween" .. math.random(1, 1000) -- Ensure unique name if not provided
    speed = speed or 0.17
    style = style or Enum.EasingStyle.Sine
    direction = direction or Enum.EasingDirection.InOut
    loop = loop or 0
    reverse = reverse or false
    delay = delay or 0
    TweenTable[name] = TweenInfo.new(speed, style, direction, loop, reverse, delay)
end

-- Create commonly used tweens
CreateTween("Fast", 0.1)
CreateTween("Normal", 0.17)
CreateTween("Slow", 0.3)
CreateTween("Prompt", 0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)


-- / Dragging Functionality (Applied to the object passed)
local drag = function(draggableObject, targetObject, latency)
    latency = latency or 0.06
    local dragging = false
    local dragInput = nil
    local dragStart = nil
    local startPos = nil
    local inputChangedConn = nil
    local inputEndedConn = nil

    local function updateInput(input)
        if not dragging or not startPos or not dragStart then return end
        local delta = input.Position - dragStart
        local newPosition = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        TweenService:Create(targetObject, TweenInfo.new(latency), {Position = newPosition}):Play()
    end

    local function stopDragging()
        if dragging then
            dragging = false
            dragStart = nil
            startPos = nil
            if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end
            if inputEndedConn then inputEndedConn:Disconnect(); inputEndedConn = nil end
        end
    end

    draggableObject.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            if dragging then return end
            dragging = true
            dragStart = input.Position
            startPos = targetObject.Position
            dragInput = input

            if inputChangedConn then inputChangedConn:Disconnect() end
            if inputEndedConn then inputEndedConn:Disconnect() end

            inputChangedConn = UserInputService.InputChanged:Connect(function(changedInput)
                if dragging and (changedInput.UserInputType == Enum.UserInputType.MouseMovement or changedInput.UserInputType == Enum.UserInputType.Touch) then
                    updateInput(changedInput)
                end
            end)

            inputEndedConn = dragInput.Changed:Connect(function()
                if dragInput.UserInputState == Enum.UserInputState.End then
                    stopDragging()
                end
            end)
        end
    end)

    draggableObject.InputEnded:Connect(function(input)
        if input == dragInput then stopDragging() end
    end)
end

-- / Library Definition
local library = {
    version = "2.1.0",
    title = "SC UI", -- Default title
    fps = 0,
    rank = "private",
    keybind = Enum.KeyCode.RightAlt, -- Default keybind to toggle UI
    activeKeybindConnection = nil,
    ActiveTheme = nil, -- Will be set in InitThemes
    Themes = {}, -- Store theme tables here
    _elements = {}, -- Internal tracking for potential future dynamic updates (not fully used yet)
    _fpsWatermarkLabels = {}, -- Labels registered to display FPS
    _keybindPromptActive = false -- Prevent multiple keybind prompts
}

-- The correct key for the library
local CorrectKey = "hh.hg**@@"
local KeyEntered = false

-- / Theming System ---
function library:InitThemes()
    -- Define Default (Dark) Theme Colors
    self.Themes.Default = {
        -- Main window
        MainWindowBackground = Color3.fromRGB(34, 34, 34),
        HeaderBackground = Color3.fromRGB(26, 26, 26),
        TabContainerBackground = Color3.fromRGB(30, 30, 30),
        ContentContainerBackground = Color3.fromRGB(30, 30, 30),
        ScrollbarColor = Color3.fromRGB(159, 115, 255),
        -- Text
        PrimaryText = Color3.fromRGB(200, 200, 200),
        SecondaryText = Color3.fromRGB(160, 160, 160),
        TitleText = Color3.fromRGB(159, 115, 255), -- Accent color for titles
        HeaderText = Color3.fromRGB(159, 115, 255),
        -- Buttons
        ButtonBackground = Color3.fromRGB(45, 45, 45),
        ButtonText = Color3.fromRGB(200, 200, 200),
        ButtonHover = Color3.fromRGB(55, 55, 55),
        ButtonClick = Color3.fromRGB(75, 75, 75),
        ButtonAccentText = Color3.fromRGB(255, 255, 255), -- Text on accent buttons
        -- Tabs
        TabButtonNormalBackground = Color3.fromRGB(40, 40, 40),
        TabButtonNormalText = Color3.fromRGB(200, 200, 200),
        TabButtonSelectedBackground = Color3.fromRGB(50, 50, 50),
        TabButtonSelectedText = Color3.fromRGB(159, 115, 255),
        -- Input Elements (Textbox, Toggle, Slider, Keybind, Dropdown)
        InputBackground = Color3.fromRGB(45, 45, 45),
        InputText = Color3.fromRGB(220, 220, 220),
        InputPlaceholder = Color3.fromRGB(150, 150, 150),
        InputFocusBackground = Color3.fromRGB(60, 60, 60),
        -- Accent Colors
        AccentColor = Color3.fromRGB(159, 115, 255),
        AccentColorContrast = Color3.fromRGB(255, 255, 255), -- Text/icons on accent color
        MutedAccentColor = Color3.fromRGB(70, 70, 70), -- e.g., toggle background when on
        -- Other
        SeparatorColor = Color3.fromRGB(60, 60, 60),
        ErrorColor = Color3.fromRGB(255, 90, 90),
        SuccessColor = Color3.fromRGB(131, 255, 103),
        WarningColor = Color3.fromRGB(255, 246, 112),
        InfoColor = Color3.fromRGB(126, 117, 255),
        -- Specific Element Colors (Can override general ones)
        ToggleIndicatorOff = Color3.fromRGB(60, 60, 60),
        ToggleIndicatorOn = Color3.fromRGB(70, 70, 70),
        ToggleSwitchOff = Color3.fromRGB(200, 200, 200),
        ToggleSwitchOn = Color3.fromRGB(159, 115, 255), -- Use AccentColor
        SliderTrack = Color3.fromRGB(45, 45, 45),
        SliderFill = Color3.fromRGB(159, 115, 255), -- Use AccentColor
        SliderHandle = Color3.fromRGB(220, 220, 220),
        KeybindDisplay = Color3.fromRGB(159, 115, 255), -- Use AccentColor
        KeybindBindingBackground = Color3.fromRGB(70, 40, 40),
        DropdownArrow = Color3.fromRGB(200, 200, 200),
        DropdownListBackground = Color3.fromRGB(40, 40, 40),
        DropdownListBorder = Color3.fromRGB(60, 60, 60),
        DropdownOptionBackground = Color3.fromRGB(50, 50, 50),
        DropdownOptionHover = Color3.fromRGB(65, 65, 65),
        DropdownOptionSelectedBackground = Color3.fromRGB(159, 115, 255), -- Use AccentColor
        DropdownOptionSelectedText = Color3.fromRGB(255, 255, 255), -- Use AccentContrast
    }

    -- Define Light Theme Colors
    self.Themes.Light = {
        MainWindowBackground = Color3.fromRGB(240, 240, 240),
        HeaderBackground = Color3.fromRGB(225, 225, 225),
        TabContainerBackground = Color3.fromRGB(230, 230, 230),
        ContentContainerBackground = Color3.fromRGB(230, 230, 230),
        ScrollbarColor = Color3.fromRGB(0, 120, 215),
        PrimaryText = Color3.fromRGB(30, 30, 30),
        SecondaryText = Color3.fromRGB(100, 100, 100),
        TitleText = Color3.fromRGB(0, 120, 215),
        HeaderText = Color3.fromRGB(0, 120, 215),
        ButtonBackground = Color3.fromRGB(210, 210, 210),
        ButtonText = Color3.fromRGB(30, 30, 30),
        ButtonHover = Color3.fromRGB(200, 200, 200),
        ButtonClick = Color3.fromRGB(180, 180, 180),
        ButtonAccentText = Color3.fromRGB(255, 255, 255),
        TabButtonNormalBackground = Color3.fromRGB(215, 215, 215),
        TabButtonNormalText = Color3.fromRGB(50, 50, 50),
        TabButtonSelectedBackground = Color3.fromRGB(200, 200, 200),
        TabButtonSelectedText = Color3.fromRGB(0, 120, 215),
        InputBackground = Color3.fromRGB(255, 255, 255),
        InputText = Color3.fromRGB(20, 20, 20),
        InputPlaceholder = Color3.fromRGB(160, 160, 160),
        InputFocusBackground = Color3.fromRGB(245, 245, 245),
        AccentColor = Color3.fromRGB(0, 120, 215),
        AccentColorContrast = Color3.fromRGB(255, 255, 255),
        MutedAccentColor = Color3.fromRGB(180, 215, 240),
        SeparatorColor = Color3.fromRGB(200, 200, 200),
        ErrorColor = Color3.fromRGB(200, 50, 50),
        SuccessColor = Color3.fromRGB(60, 160, 60),
        WarningColor = Color3.fromRGB(230, 180, 50),
        InfoColor = Color3.fromRGB(0, 120, 215),
        ToggleIndicatorOff = Color3.fromRGB(200, 200, 200),
        ToggleIndicatorOn = Color3.fromRGB(180, 215, 240), -- MutedAccent
        ToggleSwitchOff = Color3.fromRGB(140, 140, 140),
        ToggleSwitchOn = Color3.fromRGB(0, 120, 215), -- AccentColor
        SliderTrack = Color3.fromRGB(210, 210, 210),
        SliderFill = Color3.fromRGB(0, 120, 215), -- AccentColor
        SliderHandle = Color3.fromRGB(80, 80, 80),
        KeybindDisplay = Color3.fromRGB(0, 120, 215), -- AccentColor
        KeybindBindingBackground = Color3.fromRGB(255, 240, 200),
        DropdownArrow = Color3.fromRGB(50, 50, 50),
        DropdownListBackground = Color3.fromRGB(250, 250, 250),
        DropdownListBorder = Color3.fromRGB(180, 180, 180),
        DropdownOptionBackground = Color3.fromRGB(240, 240, 240),
        DropdownOptionHover = Color3.fromRGB(220, 220, 220),
        DropdownOptionSelectedBackground = Color3.fromRGB(0, 120, 215), -- AccentColor
        DropdownOptionSelectedText = Color3.fromRGB(255, 255, 255), -- AccentContrast
    }

    -- Set default active theme
    self.ActiveTheme = self.Themes.Default
end

-- Function to change the active theme
function library:SetTheme(themeName)
    if self.Themes[themeName] then
        self.ActiveTheme = self.Themes[themeName]
        print("Switched to theme:", themeName)

        -- Update main window components dynamically
        local mainUI = Player.PlayerGui:FindFirstChild("SCUI_Main")
        if mainUI then
            local mainFrame = mainUI:FindFirstChild("main")
            local header = mainFrame and mainFrame:FindFirstChild("header")
            local title = header and header:FindFirstChild("title")
            local tabContainer = mainFrame and mainFrame:FindFirstChild("tabContainer")
            local contentContainer = mainFrame and mainFrame:FindFirstChild("contentContainer")

            if mainFrame then mainFrame.BackgroundColor3 = self.ActiveTheme.MainWindowBackground end
            if header then header.BackgroundColor3 = self.ActiveTheme.HeaderBackground end
            if title then title.TextColor3 = self.ActiveTheme.HeaderText end
            if tabContainer then tabContainer.BackgroundColor3 = self.ActiveTheme.TabContainerBackground end
            if contentContainer then contentContainer.BackgroundColor3 = self.ActiveTheme.ContentContainerBackground end
            -- Note: Updating existing elements within tabs is complex and not implemented here.
            -- They will retain the theme they were created with. Recreate tabs/elements for full theme change.
            Notifier:Notify("Тема изменена на: " .. themeName .. ". Пересоздайте элементы для полного обновления.", 5, "information")
        end
    else
        warn("Theme '" .. themeName .. "' not found.")
    end
end

-- Initialize themes when library loads
library:InitThemes()


-- / FPS Update Coroutine ---
coroutine.wrap(function()
    while task.wait(1) do -- Update FPS every second
        library.fps = math.floor(1 / RunService.Heartbeat:Wait() + 0.5)
        -- Update registered watermark labels
        for labelRef, originalText in pairs(library._fpsWatermarkLabels) do
            local label = labelRef -- Dereference weak reference if needed (not using weak refs here)
            if label and label.Parent then
                pcall(function()
                    label.Text = string.gsub(originalText, "{FPS}", tostring(library.fps))
                end)
            else
                -- Remove dead reference
                library._fpsWatermarkLabels[labelRef] = nil
            end
        end
    end
end)()

-- / Utility Functions (Unchanged) ---
function library:RoundNumber(float, int) int = int or 0; return tonumber(string.format("%." .. int .. "f", float)) end
function library:GetUsername() return Player.Name end
function library:CheckIfLoaded() return game:IsLoaded() end
function library:GetUserId() return Player.UserId end
function library:GetPlaceId() return game.PlaceId end
function library:GetJobId() return game.JobId end
function library:Rejoin() pcall(function() TeleportService:TeleportToPlaceInstance(library:GetPlaceId(), library:GetJobId(), Player) end) end
function library:Copy(input) if syn and syn.write_clipboard then syn.write_clipboard(input) else warn("Synapse X specific function 'write_clipboard' is not available.") end end
function library:GetDay(type) type = string.lower(type or ""); if type == "word" then return os.date("%A") elseif type == "short" then return os.date("%a") elseif type == "month" then return os.date("%d") elseif type == "year" then return os.date("%j") else return os.date("%d") end end
function library:GetTime(type) type = string.lower(type or ""); if type == "24h" then return os.date("%H") elseif type == "12h" then return os.date("%I") elseif type == "minute" then return os.date("%M") elseif type == "half" then return os.date("%p") elseif type == "second" then return os.date("%S") elseif type == "full" then return os.date("%X") elseif type == "iso" then return os.date("%z") elseif type == "zone" then return os.date("%Z") else return os.date("%X") end end
function library:GetMonth(type) type = string.lower(type or ""); if type == "word" then return os.date("%B") elseif type == "short" then return os.date("%b") elseif type == "digit" then return os.date("%m") else return os.date("%m") end end
function library:GetWeek(type) type = string.lower(type or ""); if type == "year_s" then return os.date("%U") elseif type == "day" then return os.date("%w") elseif type == "year_m" then return os.date("%W") else return os.date("%U") end end
function library:GetYear(type) type = string.lower(type or ""); if type == "digits" then return os.date("%y") elseif type == "full" then return os.date("%Y") else return os.date("%Y") end end
function library:UnlockFps(newFps) if syn and setfpscap then setfpscap(newFps) else warn("Synapse X specific function 'setfpscap' is not available.") end end

-- / UI Systems ---

-- Watermark System (Added FPS Placeholder)
function library:Watermark(text)
    task.wait()
    local WATERMARK_SCREEN_NAME = "SCUI_Watermark"
    local FONT = Enum.Font.Code
    local TEXT_SIZE = 14
    local PADDING = 4
    local EDGE_HEIGHT = 26
    local BACKGROUND_HEIGHT = 24
    local BAR_HEIGHT = 1
    local CORNER_RADIUS = 2
    -- Use Theme Colors
    local TEXT_COLOR = self.ActiveTheme.PrimaryText
    local BAR_COLOR = self.ActiveTheme.AccentColor
    local EDGE_COLOR = self.ActiveTheme.SeparatorColor -- Use separator color for edge
    local GRADIENT_START = self.ActiveTheme.MainWindowBackground
    local GRADIENT_END = Color3.fromRGB(math.max(0, GRADIENT_START.R*255-6), math.max(0, GRADIENT_START.G*255-6), math.max(0, GRADIENT_START.B*255-6)) -- Slightly darker end

    local existingWatermark = Player.PlayerGui:FindFirstChild(WATERMARK_SCREEN_NAME)
    if existingWatermark then existingWatermark:Destroy() end

    text = text or "SC UI"

    local watermark = Instance.new("ScreenGui")
    watermark.Name = WATERMARK_SCREEN_NAME
    watermark.Parent = Player.PlayerGui
    watermark.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    watermark.DisplayOrder = 999

    local watermarkLayout = Instance.new("UIListLayout")
    watermarkLayout.Parent = watermark
    watermarkLayout.FillDirection = Enum.FillDirection.Horizontal
    watermarkLayout.SortOrder = Enum.SortOrder.LayoutOrder
    watermarkLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
    watermarkLayout.Padding = UDim.new(0, PADDING)

    local watermarkPadding = Instance.new("UIPadding")
    watermarkPadding.Parent = watermark
    watermarkPadding.PaddingBottom = UDim.new(0, 6)
    watermarkPadding.PaddingLeft = UDim.new(0, 6)

    local function createWatermarkElement(elementText, isInitial)
        local originalText = elementText -- Store original text for FPS updates
        local edge = Instance.new("Frame")
        edge.Name = "edge"
        edge.AnchorPoint = Vector2.new(0, 1)
        edge.BackgroundColor3 = EDGE_COLOR
        edge.Size = UDim2.new(0, 0, 0, EDGE_HEIGHT)
        edge.BackgroundTransparency = 1

        local edgeCorner = Instance.new("UICorner", edge); edgeCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)

        local background = Instance.new("Frame")
        background.Name = "background"
        background.Parent = edge
        background.AnchorPoint = Vector2.new(0.5, 0.5)
        background.BackgroundTransparency = 1
        background.ClipsDescendants = true
        background.Position = UDim2.new(0.5, 0, 0.5, 0)
        background.Size = UDim2.new(1, -2, 1, -2)

        local bar = Instance.new("Frame", background) -- Parent directly
        bar.Name = "bar"
        bar.BackgroundColor3 = BAR_COLOR
        bar.BorderSizePixel = 0
        bar.Position = UDim2.new(0, 0, 0, 0)
        bar.Size = UDim2.new(0, 0, 0, BAR_HEIGHT)
        local barCorner = Instance.new("UICorner", bar); barCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)

        local backgroundGradient = Instance.new("UIGradient", background)
        backgroundGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, GRADIENT_START), ColorSequenceKeypoint.new(1.00, GRADIENT_END)}
        backgroundGradient.Rotation = 90

        local backgroundCorner = Instance.new("UICorner", background); backgroundCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)

        local waterTextLabel = Instance.new("TextLabel") -- Renamed variable
        waterTextLabel.Name = "waterText"
        waterTextLabel.Parent = background
        waterTextLabel.BackgroundTransparency = 1.000
        waterTextLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
        waterTextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
        waterTextLabel.Size = UDim2.new(1, -(PADDING * 2), 1, -(PADDING * 2))
        waterTextLabel.Font = FONT
        waterTextLabel.Text = elementText -- Set initial text
        waterTextLabel.TextColor3 = TEXT_COLOR
        waterTextLabel.TextTransparency = 1
        waterTextLabel.TextSize = TEXT_SIZE
        waterTextLabel.RichText = true
        waterTextLabel.TextXAlignment = Enum.TextXAlignment.Center
        waterTextLabel.TextYAlignment = Enum.TextYAlignment.Center

        -- Check for FPS placeholder and register if found
        if string.find(elementText, "{FPS}", 1, true) then
            library._fpsWatermarkLabels[waterTextLabel] = originalText -- Store reference and original text
            -- Set initial FPS text
            waterTextLabel.Text = string.gsub(originalText, "{FPS}", tostring(library.fps))
        end

        local textSize = TextService:GetTextSize(waterTextLabel.Text, waterTextLabel.TextSize, waterTextLabel.Font, Vector2.new(math.huge, BACKGROUND_HEIGHT))
        local requiredWidth = textSize.X + (PADDING * 2) + 4

        -- Animate appearance
        coroutine.wrap(function()
            local sizeTweenEdge = TweenService:Create(edge, TweenTable["Normal"], {Size = UDim2.new(0, requiredWidth + 2, 0, EDGE_HEIGHT), BackgroundTransparency = 0})
            local sizeTweenBg = TweenService:Create(background, TweenTable["Normal"], { BackgroundTransparency = 0 })
            sizeTweenEdge:Play(); sizeTweenBg:Play()
            if isInitial then sizeTweenEdge.Completed:Wait() end -- Only wait for first one

            local barTween = TweenService:Create(bar, TweenTable["Slow"], {Size = UDim2.new(1, 0, 0, BAR_HEIGHT)})
            barTween:Play()
            task.wait(0.1)

            local textTween = TweenService:Create(waterTextLabel, TweenTable["Fast"], {TextTransparency = 0})
            textTween:Play()
        end)()

        return edge, background, bar, waterTextLabel, requiredWidth, originalText -- Return original text too
    end

    -- Create first element
    local edge, background, bar, waterTextLabel, requiredWidth, originalText = createWatermarkElement(text, true)
    edge.Parent = watermark

    local WatermarkFunctions = {}
    function WatermarkFunctions:AddWatermark(newText)
        local newEdge, _, _, newWaterTextLabel, _, newOriginalText = createWatermarkElement(newText, false)
        newEdge.Parent = watermark

        local NewWatermarkFunctions = {}
        function NewWatermarkFunctions:Hide() newEdge.Visible = false; return NewWatermarkFunctions end
        function NewWatermarkFunctions:Show() newEdge.Visible = true; return NewWatermarkFunctions end
        function NewWatermarkFunctions:Text(updatedText)
            updatedText = updatedText or newText
            local isFps = string.find(updatedText, "{FPS}", 1, true)
            local currentOriginal = library._fpsWatermarkLabels[newWaterTextLabel]

            -- Update registration if FPS placeholder changes
            if isFps and not currentOriginal then
                 library._fpsWatermarkLabels[newWaterTextLabel] = updatedText -- Register new
            elseif not isFps and currentOriginal then
                 library._fpsWatermarkLabels[newWaterTextLabel] = nil -- Unregister
            elseif isFps and currentOriginal and updatedText ~= currentOriginal then
                 library._fpsWatermarkLabels[newWaterTextLabel] = updatedText -- Update original text
            end

            -- Set text (handle FPS replacement if needed now)
            local displayText = updatedText
            if isFps then
                 displayText = string.gsub(updatedText, "{FPS}", tostring(library.fps))
            end
            newWaterTextLabel.Text = displayText

            -- Resize
            local newTextSize = TextService:GetTextSize(newWaterTextLabel.Text, newWaterTextLabel.TextSize, newWaterTextLabel.Font, Vector2.new(math.huge, BACKGROUND_HEIGHT))
            local newWidth = newTextSize.X + (PADDING * 2) + 4
            TweenService:Create(newEdge, TweenTable["Fast"], {Size = UDim2.new(0, newWidth + 2, 0, EDGE_HEIGHT)}):Play()
            return NewWatermarkFunctions
        end
        function NewWatermarkFunctions:Remove()
             -- Unregister FPS label if needed
             if library._fpsWatermarkLabels[newWaterTextLabel] then
                  library._fpsWatermarkLabels[newWaterTextLabel] = nil
             end
             -- Fade out animation
             local fadeOutEdge = TweenService:Create(newEdge, TweenTable["Normal"], {BackgroundTransparency = 1})
             -- Find background and text label to fade them too (safer than assuming variable names)
             local bg = newEdge:FindFirstChild("background")
             local wt = bg and bg:FindFirstChild("waterText")
             if bg then TweenService:Create(bg, TweenTable["Normal"], {BackgroundTransparency = 1}):Play() end
             if wt then TweenService:Create(wt, TweenTable["Fast"], {TextTransparency = 1}):Play() end
             fadeOutEdge:Play()
             fadeOutEdge.Completed:Wait()
             newEdge:Destroy()
        end
        return NewWatermarkFunctions
    end

    function WatermarkFunctions:Remove()
        -- Unregister all FPS labels associated with this watermark instance
        for labelRef, _ in pairs(library._fpsWatermarkLabels) do
             if labelRef and labelRef:IsDescendantOf(watermark) then
                  library._fpsWatermarkLabels[labelRef] = nil
             end
        end
        -- Fade out animation for all elements
        local tweens = {}
        for _, child in ipairs(watermark:GetChildren()) do
            if child:IsA("Frame") and child.Name == "edge" then
                table.insert(tweens, TweenService:Create(child, TweenTable["Normal"], {BackgroundTransparency = 1}))
                local bg = child:FindFirstChild("background")
                local wt = bg and bg:FindFirstChild("waterText")
                if bg then table.insert(tweens, TweenService:Create(bg, TweenTable["Normal"], {BackgroundTransparency = 1})) end
                if wt then table.insert(tweens, TweenService:Create(wt, TweenTable["Fast"], {TextTransparency = 1})) end
            end
        end
        for _, t in ipairs(tweens) do t:Play() end
        if #tweens > 0 then tweens[#tweens].Completed:Wait() end
        watermark:Destroy()
    end

    return WatermarkFunctions
end


-- Notification System (Uses Theme Colors)
function library:InitNotifications()
    task.wait()
    local NOTIFICATION_SCREEN_NAME = "SCUI_Notifications"
    local FONT = Enum.Font.Code
    local TEXT_SIZE = 14
    local PADDING = 4
    local EDGE_HEIGHT = 26
    local BACKGROUND_HEIGHT = 24
    local BAR_HEIGHT = 1
    local CORNER_RADIUS = 2
    -- Use Theme Colors
    local TEXT_COLOR = self.ActiveTheme.PrimaryText
    local EDGE_COLOR = self.ActiveTheme.SeparatorColor
    local GRADIENT_START = self.ActiveTheme.MainWindowBackground
    local GRADIENT_END = Color3.fromRGB(math.max(0, GRADIENT_START.R*255-6), math.max(0, GRADIENT_START.G*255-6), math.max(0, GRADIENT_START.B*255-6))
    local NOTIFICATION_TYPES = {
        notification = self.ActiveTheme.AccentColor,
        alert = self.ActiveTheme.WarningColor,
        error = self.ActiveTheme.ErrorColor,
        success = self.ActiveTheme.SuccessColor,
        information = self.ActiveTheme.InfoColor
    }

    local existingNotifications = Player.PlayerGui:FindFirstChild(NOTIFICATION_SCREEN_NAME)
    if existingNotifications then existingNotifications:Destroy() end

    local Notifications = Instance.new("ScreenGui")
    Notifications.Name = NOTIFICATION_SCREEN_NAME
    Notifications.Parent = Player.PlayerGui
    Notifications.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Notifications.DisplayOrder = 1000

    local notificationsLayout = Instance.new("UIListLayout")
    notificationsLayout.Parent = Notifications
    notificationsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    notificationsLayout.Padding = UDim.new(0, PADDING)
    notificationsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    notificationsLayout.VerticalAlignment = Enum.VerticalAlignment.Top

    local notificationsPadding = Instance.new("UIPadding")
    notificationsPadding.Parent = Notifications
    notificationsPadding.PaddingLeft = UDim.new(0, 6)
    notificationsPadding.PaddingTop = UDim.new(0, 18)

    local Notification = {}
    function Notification:Notify(text, duration, type, callback)
        text = text or "Please wait..."
        duration = duration or 5
        type = string.lower(type or "notification")
        callback = callback or function() end
        local barColor = NOTIFICATION_TYPES[type] or NOTIFICATION_TYPES.information -- Default to info color

        local edge = Instance.new("Frame")
        edge.Name = "edge"; edge.Parent = Notifications
        edge.BackgroundColor3 = EDGE_COLOR; edge.BackgroundTransparency = 1.000
        edge.Size = UDim2.new(0, 0, 0, EDGE_HEIGHT)
        local edgeCorner = Instance.new("UICorner", edge); edgeCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)

        local background = Instance.new("Frame")
        background.Name = "background"; background.Parent = edge
        background.AnchorPoint = Vector2.new(0.5, 0.5); background.BackgroundTransparency = 1.000
        background.ClipsDescendants = true; background.Position = UDim2.new(0.5, 0, 0.5, 0)
        background.Size = UDim2.new(1, -2, 1, -2)
        local backgroundGradient = Instance.new("UIGradient", background)
        backgroundGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, GRADIENT_START), ColorSequenceKeypoint.new(1.00, GRADIENT_END)}
        backgroundGradient.Rotation = 90
        local backgroundCorner = Instance.new("UICorner", background); backgroundCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)

        local bar = Instance.new("Frame", background)
        bar.Name = "bar"; bar.BackgroundColor3 = barColor
        bar.BackgroundTransparency = 0; bar.BorderSizePixel = 0
        bar.Position = UDim2.new(0, 0, 0, 0); bar.Size = UDim2.new(0, 0, 0, BAR_HEIGHT)
        local barCorner = Instance.new("UICorner", bar); barCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)

        local notifText = Instance.new("TextLabel")
        notifText.Name = "notifText"; notifText.Parent = background
        notifText.BackgroundTransparency = 1.000; notifText.Position = UDim2.new(0.5, 0, 0.5, 0)
        notifText.AnchorPoint = Vector2.new(0.5, 0.5); notifText.Size = UDim2.new(1, -(PADDING * 2), 1, -(PADDING * 2))
        notifText.Font = FONT; notifText.Text = text; notifText.TextColor3 = TEXT_COLOR
        notifText.TextSize = TEXT_SIZE; notifText.TextTransparency = 1.000
        notifText.TextXAlignment = Enum.TextXAlignment.Left; notifText.TextYAlignment = Enum.TextYAlignment.Center
        notifText.RichText = true

        local textSize = TextService:GetTextSize(notifText.Text, notifText.TextSize, notifText.Font, Vector2.new(300, math.huge))
        local requiredWidth = math.max(150, textSize.X + (PADDING * 2) + 4)

        TweenTable["notification_bar_fill"] = TweenInfo.new(duration, Enum.EasingStyle.Linear)

        local isRunning = false; local barTween
        coroutine.wrap(function()
            isRunning = true
            local sizeTweenEdge = TweenService:Create(edge, TweenTable["Fast"], {Size = UDim2.new(0, requiredWidth + 2, 0, EDGE_HEIGHT), BackgroundTransparency = 0})
            local bgTween = TweenService:Create(background, TweenTable["Fast"], {BackgroundTransparency = 0})
            local textTween = TweenService:Create(notifText, TweenTable["Fast"], {TextTransparency = 0})
            sizeTweenEdge:Play(); bgTween:Play(); textTween:Play()
            sizeTweenEdge.Completed:Wait()

            barTween = TweenService:Create(bar, TweenTable["notification_bar_fill"], {Size = UDim2.new(1, 0, 0, BAR_HEIGHT)})
            barTween:Play(); barTween.Completed:Wait()
            isRunning = false

            local hideSizeTween = TweenService:Create(edge, TweenTable["Fast"], {Size = UDim2.new(0, 0, 0, EDGE_HEIGHT), BackgroundTransparency = 1})
            local hideBgTween = TweenService:Create(background, TweenTable["Fast"], {BackgroundTransparency = 1})
            local hideTextTween = TweenService:Create(notifText, TweenTable["Fast"], {TextTransparency = 1})
            local hideBarTween = TweenService:Create(bar, TweenTable["Fast"], {BackgroundTransparency = 1})
            hideSizeTween:Play(); hideBgTween:Play(); hideTextTween:Play(); hideBarTween:Play()
            hideSizeTween.Completed:Wait()
            edge:Destroy()
            pcall(callback)
        end)()

        local NotificationFunctions = {}
        function NotificationFunctions:Text(newText)
            if not edge or not edge.Parent then return end
            newText = newText or text; notifText.Text = newText
            local newTextSize = TextService:GetTextSize(notifText.Text, notifText.TextSize, notifText.Font, Vector2.new(300, math.huge))
            local newRequiredWidth = math.max(150, newTextSize.X + (PADDING * 2) + 4)
            TweenService:Create(edge, TweenTable["Fast"], {Size = UDim2.new(0, newRequiredWidth + 2, 0, EDGE_HEIGHT)}):Play()
            return NotificationFunctions
        end
        function NotificationFunctions:Dismiss()
            if not edge or not edge.Parent then return end
            if barTween and barTween.PlaybackState == Enum.PlaybackState.Playing then barTween:Cancel() end
            isRunning = false
            local hideSizeTween = TweenService:Create(edge, TweenTable["Fast"], {Size = UDim2.new(0, 0, 0, EDGE_HEIGHT), BackgroundTransparency = 1})
            local hideBgTween = TweenService:Create(background, TweenTable["Fast"], {BackgroundTransparency = 1})
            local hideTextTween = TweenService:Create(notifText, TweenTable["Fast"], {TextTransparency = 1})
            local hideBarTween = TweenService:Create(bar, TweenTable["Fast"], {BackgroundTransparency = 1})
            hideSizeTween:Play(); hideBgTween:Play(); hideTextTween:Play(); hideBarTween:Play()
            hideSizeTween.Completed:Wait()
            edge:Destroy()
        end
        return NotificationFunctions
    end
    return Notification
end


-- Key Prompt System (Unchanged, uses theme colors implicitly via Init)
function library:KeyPrompt()
    task.wait()
    local KEYPROMPT_SCREEN_NAME = "SCUI_KeyPromptScreen"
    local FONT = Enum.Font.Code
    -- Use Theme Colors
    local MAIN_BG_COLOR = self.ActiveTheme.MainWindowBackground
    local TITLE_COLOR = self.ActiveTheme.TitleText
    local TEXTBOX_BG_COLOR = self.ActiveTheme.InputBackground
    local TEXT_COLOR = self.ActiveTheme.InputText
    local BUTTON_BG_COLOR = self.ActiveTheme.AccentColor
    local BUTTON_TEXT_COLOR = self.ActiveTheme.AccentColorContrast
    local ERROR_PLACEHOLDER_COLOR = self.ActiveTheme.ErrorColor
    local PLACEHOLDER_COLOR = self.ActiveTheme.InputPlaceholder

    local existingPrompt = Player.PlayerGui:FindFirstChild(KEYPROMPT_SCREEN_NAME)
    if existingPrompt then existingPrompt:Destroy() end

    local keyPrompt = Instance.new("ScreenGui")
    keyPrompt.Name = KEYPROMPT_SCREEN_NAME; keyPrompt.Parent = Player.PlayerGui
    keyPrompt.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; keyPrompt.DisplayOrder = 1001

    local blur = Instance.new("BlurEffect"); blur.Size = 8; blur.Parent = game.Lighting

    local main = Instance.new("Frame")
    main.Name = "main"; main.Parent = keyPrompt
    main.BackgroundColor3 = MAIN_BG_COLOR; main.BorderSizePixel = 0
    main.Position = UDim2.new(0.5, 0, -0.5, 0); main.AnchorPoint = Vector2.new(0.5, 0.5)
    main.Size = UDim2.new(0, 320, 0, 160)
    local corner = Instance.new("UICorner", main); corner.CornerRadius = UDim.new(0, 6)

    local title = Instance.new("TextLabel")
    title.Name = "Title"; title.Parent = main; title.BackgroundTransparency = 1
    title.Position = UDim2.new(0.5, 0, 0, 20); title.AnchorPoint = Vector2.new(0.5, 0)
    title.Size = UDim2.new(0.9, 0, 0, 25); title.Font = FONT
    title.Text = "SC UI Library - Key System"; title.TextColor3 = TITLE_COLOR
    title.TextSize = 18; title.TextXAlignment = Enum.TextXAlignment.Center

    local textBox = Instance.new("TextBox")
    textBox.Name = "KeyInput"; textBox.Parent = main
    textBox.BackgroundColor3 = TEXTBOX_BG_COLOR; textBox.BorderSizePixel = 0
    textBox.Position = UDim2.new(0.5, 0, 0.5, -15); textBox.AnchorPoint = Vector2.new(0.5, 0.5)
    textBox.Size = UDim2.new(0.85, 0, 0, 35); textBox.Font = FONT
    textBox.PlaceholderText = "Enter key..."; textBox.PlaceholderColor3 = PLACEHOLDER_COLOR
    textBox.Text = ""; textBox.TextColor3 = TEXT_COLOR; textBox.TextSize = 15
    textBox.ClearTextOnFocus = false; textBox.TextXAlignment = Enum.TextXAlignment.Left
    textBox.TextYAlignment = Enum.TextYAlignment.Center
    local textBoxPadding = Instance.new("UIPadding", textBox); textBoxPadding.PaddingLeft = UDim.new(0, 10); textBoxPadding.PaddingRight = UDim.new(0, 10)
    local textBoxCorner = Instance.new("UICorner", textBox); textBoxCorner.CornerRadius = UDim.new(0, 4)

    local submitButton = Instance.new("TextButton")
    submitButton.Name = "SubmitButton"; submitButton.Parent = main
    submitButton.BackgroundColor3 = BUTTON_BG_COLOR; submitButton.BorderSizePixel = 0
    submitButton.Position = UDim2.new(0.5, 0, 0.8, 0); submitButton.AnchorPoint = Vector2.new(0.5, 0.5)
    submitButton.Size = UDim2.new(0.5, 0, 0, 35); submitButton.Font = FONT
    submitButton.Text = "Submit"; submitButton.TextColor3 = BUTTON_TEXT_COLOR; submitButton.TextSize = 16
    local submitCorner = Instance.new("UICorner", submitButton); submitCorner.CornerRadius = UDim.new(0, 4)

    local resultPromise = Instance.new("BindableEvent")
    TweenService:Create(main, TweenTable["Prompt"], {Position = UDim2.new(0.5, 0, 0.5, 0)}):Play()

    local function shakeElement(element)
        local originalPos = element.Position; local shakeTweenInfo = TweenInfo.new(0.05)
        for _ = 1, 3 do
            TweenService:Create(element, shakeTweenInfo, {Position = originalPos + UDim2.new(0, 8, 0, 0)}):Play(); task.wait(0.05)
            TweenService:Create(element, shakeTweenInfo, {Position = originalPos - UDim2.new(0, 8, 0, 0)}):Play(); task.wait(0.05)
        end
        TweenService:Create(element, shakeTweenInfo, {Position = originalPos}):Play()
    end

    local handleSubmit; handleSubmit = function()
        local enteredKey = textBox.Text
        if enteredKey == CorrectKey then
            KeyEntered = true
            CreateTween("prompt_out", 0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)
            local outTween = TweenService:Create(main, TweenTable["prompt_out"], {Position = UDim2.new(0.5, 0, 1.5, 0)})
            outTween:Play()
            outTween.Completed:Connect(function() keyPrompt:Destroy(); blur:Destroy(); resultPromise:Fire(true) end)
        else
            shakeElement(main); textBox.Text = ""; textBox.PlaceholderText = "Incorrect key!"
            textBox.PlaceholderColor3 = ERROR_PLACEHOLDER_COLOR
            task.delay(1.5, function() if textBox and textBox.Parent then textBox.PlaceholderText = "Enter key..."; textBox.PlaceholderColor3 = PLACEHOLDER_COLOR end end)
        end
    end
    submitButton.MouseButton1Click:Connect(handleSubmit)
    textBox.FocusLost:Connect(function(enterPressed) if enterPressed then handleSubmit() end end)
    return resultPromise.Event
end

-- / Internal Helper: Keybind Prompt ---
function library:_CreateKeybindPrompt(currentKeybindElement, callback)
    -- Prevent multiple prompts
    if self._keybindPromptActive then return end
    self._keybindPromptActive = true

    -- Create ScreenGui for the prompt
    local promptScreen = Instance.new("ScreenGui")
    promptScreen.Name = "SCUI_KeybindPrompt"
    promptScreen.Parent = Player.PlayerGui
    promptScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    promptScreen.DisplayOrder = 1002 -- Above main UI and key prompt

    -- Use Theme Colors
    local BG_COLOR = Color3.fromRGB(34, 34, 34) -- Darker background for prompt
    local TEXT_COLOR = self.ActiveTheme.PrimaryText
    local ACCENT_COLOR = self.ActiveTheme.AccentColor
    local BUTTON_BG = self.ActiveTheme.ButtonBackground
    local BUTTON_HOVER = self.ActiveTheme.ButtonHover
    local BUTTON_TEXT = self.ActiveTheme.ButtonText
    local FONT = Enum.Font.Code

    -- Main prompt frame
    local promptFrame = Instance.new("Frame")
    promptFrame.Name = "PromptFrame"
    promptFrame.Parent = promptScreen
    promptFrame.BackgroundColor3 = BG_COLOR
    promptFrame.BorderSizePixel = 1
    promptFrame.BorderColor3 = ACCENT_COLOR
    promptFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    promptFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    promptFrame.Size = UDim2.new(0, 280, 0, 120)
    local frameCorner = Instance.new("UICorner", promptFrame); frameCorner.CornerRadius = UDim.new(0, 4)

    -- Instruction Label
    local instructionLabel = Instance.new("TextLabel")
    instructionLabel.Name = "Instruction"
    instructionLabel.Parent = promptFrame
    instructionLabel.BackgroundTransparency = 1
    instructionLabel.Size = UDim2.new(1, -20, 0, 50)
    instructionLabel.Position = UDim2.new(0.5, 0, 0, 10)
    instructionLabel.AnchorPoint = Vector2.new(0.5, 0)
    instructionLabel.Font = FONT
    instructionLabel.Text = "Нажмите любую клавишу клавиатуры...\n(Escape для отмены)"
    instructionLabel.TextColor3 = TEXT_COLOR
    instructionLabel.TextSize = 14
    instructionLabel.TextWrapped = true
    instructionLabel.TextYAlignment = Enum.TextYAlignment.Center
    instructionLabel.TextXAlignment = Enum.TextXAlignment.Center

    -- Clear Button
    local clearButton = Instance.new("TextButton")
    clearButton.Name = "ClearButton"
    clearButton.Parent = promptFrame
    clearButton.BackgroundColor3 = BUTTON_BG
    clearButton.Size = UDim2.new(0.4, 0, 0, 30)
    clearButton.Position = UDim2.new(0.5, 5, 1, -40) -- Position bottom right
    clearButton.AnchorPoint = Vector2.new(0, 0.5)
    clearButton.Font = FONT
    clearButton.Text = "Очистить"
    clearButton.TextColor3 = BUTTON_TEXT
    clearButton.TextSize = 14
    local clearCorner = Instance.new("UICorner", clearButton); clearCorner.CornerRadius = UDim.new(0, 3)
    clearButton.AutoButtonColor = false

    clearButton.MouseEnter:Connect(function() TweenService:Create(clearButton, TweenTable["Fast"], {BackgroundColor3 = BUTTON_HOVER}):Play() end)
    clearButton.MouseLeave:Connect(function() TweenService:Create(clearButton, TweenTable["Fast"], {BackgroundColor3 = BUTTON_BG}):Play() end)

    -- Input Handling
    local inputConn = nil
    local function closePrompt(resultKey)
        if inputConn then inputConn:Disconnect(); inputConn = nil end
        library._keybindPromptActive = false
        promptScreen:Destroy()
        pcall(callback, resultKey) -- Call the original keybind's callback
    end

    clearButton.MouseButton1Click:Connect(function()
        closePrompt(nil) -- Pass nil to indicate clearing
    end)

    inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if library._keybindPromptActive and not gameProcessed then
            if input.UserInputType == Enum.UserInputType.Keyboard then
                if input.KeyCode == Enum.KeyCode.Escape then
                    closePrompt("cancel") -- Special value for cancellation, callback should handle this if needed
                -- Ignore modifier keys themselves as binds
                elseif input.KeyCode ~= Enum.KeyCode.LeftShift and input.KeyCode ~= Enum.KeyCode.RightShift and
                       input.KeyCode ~= Enum.KeyCode.LeftControl and input.KeyCode ~= Enum.KeyCode.RightControl and
                       input.KeyCode ~= Enum.KeyCode.LeftAlt and input.KeyCode ~= Enum.KeyCode.RightAlt and
                       input.KeyCode ~= Enum.KeyCode.LeftSuper and input.KeyCode ~= Enum.KeyCode.RightSuper then
                       closePrompt(input.KeyCode) -- Pass the selected keycode
                end
            -- Allow clicking outside to cancel (optional)
            -- elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
                 -- Check if click target is outside promptFrame? More complex. Escape/Clear is usually enough.
            end
        end
    end)
end


-- / Main UI Initialization (Window) ---
function library:Init(key)
    -- Set keybind or use provided key (Default back to RightAlt)
    self.keybind = key or Enum.KeyCode.RightAlt

    -- Ensure themes are initialized
    if not self.ActiveTheme then self:InitThemes() end

    -- Check key if not already entered
    if not KeyEntered then
        local keySuccessConnection; local success = false
        keySuccessConnection = self:KeyPrompt():Connect(function(result) success = result; if keySuccessConnection then keySuccessConnection:Disconnect() end end)
        repeat task.wait() until success == true
        if not success then warn("Key prompt failed."); return nil end
    end

    -- Constants & Theme Colors
    local MAIN_SCREEN_NAME = "SCUI_Main"
    local FONT = Enum.Font.Code
    local CORNER_RADIUS = 5
    local PADDING = 5
    local THEME = self.ActiveTheme -- Use active theme

    -- Clear existing UI
    local existingUI = Player.PlayerGui:FindFirstChild(MAIN_SCREEN_NAME)
    if existingUI then existingUI:Destroy() end

    -- Create ScreenGui
    local SCUI = Instance.new("ScreenGui")
    SCUI.Name = MAIN_SCREEN_NAME; SCUI.Parent = Player.PlayerGui
    SCUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; SCUI.DisplayOrder = 100
    SCUI.Enabled = true

    -- Main Window Frame
    local main = Instance.new("Frame")
    main.Name = "main"; main.Parent = SCUI
    main.BackgroundColor3 = THEME.MainWindowBackground -- Theme
    main.BorderSizePixel = 0; main.AnchorPoint = Vector2.new(0.5, 0.5)
    main.Position = UDim2.new(0.5, 0, 0.5, 0); main.Size = UDim2.new(0, 550, 0, 350)
    main.ClipsDescendants = true
    local mainCorner = Instance.new("UICorner", main); mainCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)

    -- Header Frame
    local header = Instance.new("Frame")
    header.Name = "header"; header.Parent = main
    header.BackgroundColor3 = THEME.HeaderBackground -- Theme
    header.BorderSizePixel = 0; header.Size = UDim2.new(1, 0, 0, 35)
    header.Position = UDim2.new(0, 0, 0, 0); header.ZIndex = 2
    local headerCorner = Instance.new("UICorner", header); headerCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)

    -- Header Title
    local headerTitle = Instance.new("TextLabel")
    headerTitle.Name = "title"; headerTitle.Parent = header; headerTitle.BackgroundTransparency = 1
    headerTitle.Position = UDim2.new(0, 15, 0.5, 0); headerTitle.AnchorPoint = Vector2.new(0, 0.5)
    headerTitle.Size = UDim2.new(0.7, 0, 1, 0); headerTitle.Font = FONT
    headerTitle.Text = self.title; headerTitle.TextColor3 = THEME.HeaderText -- Theme
    headerTitle.TextSize = 16; headerTitle.TextXAlignment = Enum.TextXAlignment.Left
    headerTitle.TextYAlignment = Enum.TextYAlignment.Center

    -- Close Button
    local closeBtn = Instance.new("TextButton")
    closeBtn.Name = "closeBtn"; closeBtn.Parent = header; closeBtn.BackgroundTransparency = 1
    closeBtn.AnchorPoint = Vector2.new(1, 0.5); closeBtn.Position = UDim2.new(1, -10, 0.5, 0)
    closeBtn.Size = UDim2.new(0, 20, 0, 20); closeBtn.Font = FONT; closeBtn.Text = "X"
    closeBtn.TextColor3 = THEME.ErrorColor -- Use theme error color
    closeBtn.TextSize = 18; closeBtn.AutoButtonColor = false
    closeBtn.MouseEnter:Connect(function() TweenService:Create(closeBtn, TweenTable["Fast"], {TextColor3 = THEME.ErrorColor:Lerp(Color3.new(1,1,1), 0.3)}):Play() end)
    closeBtn.MouseLeave:Connect(function() TweenService:Create(closeBtn, TweenTable["Fast"], {TextColor3 = THEME.ErrorColor}):Play() end)
    closeBtn.MouseButton1Click:Connect(function() SCUI.Enabled = not SCUI.Enabled end)

    -- Tab Container
    local tabContainer = Instance.new("Frame")
    tabContainer.Name = "tabContainer"; tabContainer.Parent = main
    tabContainer.BackgroundColor3 = THEME.TabContainerBackground -- Theme
    tabContainer.BorderSizePixel = 0; tabContainer.Position = UDim2.new(0, PADDING, 0, 35 + PADDING)
    tabContainer.Size = UDim2.new(0, 130, 1, -(35 + PADDING * 2)); tabContainer.ClipsDescendants = true; tabContainer.ZIndex = 1
    local tabContainerCorner = Instance.new("UICorner", tabContainer); tabContainerCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)

    -- Tab List (Scrolling)
    local tabList = Instance.new("ScrollingFrame")
    tabList.Name = "tabList"; tabList.Parent = tabContainer; tabList.Active = true
    tabList.BackgroundTransparency = 1; tabList.BorderSizePixel = 0
    tabList.Position = UDim2.new(0, 0, 0, PADDING); tabList.Size = UDim2.new(1, 0, 1, -PADDING * 2)
    tabList.ScrollBarThickness = 4; tabList.ScrollBarImageColor3 = THEME.ScrollbarColor -- Theme
    tabList.CanvasSize = UDim2.new(0, 0, 0, 0); tabList.ScrollingDirection = Enum.ScrollingDirection.Y
    local tabListLayout = Instance.new("UIListLayout", tabList)
    tabListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; tabListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    tabListLayout.Padding = UDim.new(0, PADDING); tabListLayout.FillDirection = Enum.FillDirection.Vertical

    -- Content Container
    local contentContainer = Instance.new("Frame")
    contentContainer.Name = "contentContainer"; contentContainer.Parent = main
    contentContainer.BackgroundColor3 = THEME.ContentContainerBackground -- Theme
    contentContainer.BorderSizePixel = 0; contentContainer.Position = UDim2.new(0, 130 + PADDING * 2, 0, 35 + PADDING)
    contentContainer.Size = UDim2.new(1, -(130 + PADDING * 3), 1, -(35 + PADDING * 2)); contentContainer.ClipsDescendants = true; contentContainer.ZIndex = 1
    local contentContainerCorner = Instance.new("UICorner", contentContainer); contentContainerCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)

    -- Enable dragging (Header drags Main)
    drag(header, main, 0.08)

    -- Enable keybind to toggle UI (Using default RightAlt now)
    if self.activeKeybindConnection then self.activeKeybindConnection:Disconnect(); self.activeKeybindConnection = nil end
    self.activeKeybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == self.keybind then
            local focused = UserInputService:GetFocusedTextBox()
            if not focused then SCUI.Enabled = not SCUI.Enabled end
        end
    end)

    -- Window object to return
    local Window = {}
    local activeTabButton = nil
    local activeTabContent = nil

    -- Function to create a new Tab
    function Window:NewTab(name)
        name = name or "Tab"
        local safeName = name:gsub("%W", "")
        local THEME = library.ActiveTheme -- Capture theme at creation time

        -- Create Tab Button
        local tabButton = Instance.new("TextButton")
        tabButton.Name = "tab_" .. safeName; tabButton.Parent = tabList
        tabButton.BackgroundColor3 = THEME.TabButtonNormalBackground -- Theme
        tabButton.BorderSizePixel = 0; tabButton.Size = UDim2.new(1, -PADDING * 2, 0, 30)
        tabButton.Font = FONT; tabButton.Text = name; tabButton.TextColor3 = THEME.TabButtonNormalText -- Theme
        tabButton.TextSize = 14; tabButton.AutoButtonColor = false
        local tabButtonCorner = Instance.new("UICorner", tabButton); tabButtonCorner.CornerRadius = UDim.new(0, 4)

        tabList.CanvasSize = UDim2.new(0, 0, 0, tabListLayout.AbsoluteContentSize.Y + PADDING)

        -- Create Tab Content Frame
        local tabContent = Instance.new("ScrollingFrame")
        tabContent.Name = "content_" .. safeName; tabContent.Parent = contentContainer; tabContent.Active = true
        tabContent.BackgroundTransparency = 1; tabContent.BorderSizePixel = 0; tabContent.ClipsDescendants = true
        tabContent.Size = UDim2.new(1, 0, 1, 0); tabContent.ScrollBarThickness = 4; tabContent.Visible = false
        tabContent.CanvasSize = UDim2.new(0, 0, 0, 0); tabContent.ScrollBarImageColor3 = THEME.ScrollbarColor -- Theme
        tabContent.ScrollingDirection = Enum.ScrollingDirection.Y
        local tabContentLayout = Instance.new("UIListLayout", tabContent)
        tabContentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; tabContentLayout.SortOrder = Enum.SortOrder.LayoutOrder
        tabContentLayout.Padding = UDim.new(0, PADDING); tabContentLayout.FillDirection = Enum.FillDirection.Vertical
        local tabContentPadding = Instance.new("UIPadding", tabContent)
        tabContentPadding.PaddingTop = UDim.new(0, PADDING * 2); tabContentPadding.PaddingBottom = UDim.new(0, PADDING * 2)
        tabContentPadding.PaddingLeft = UDim.new(0, PADDING); tabContentPadding.PaddingRight = UDim.new(0, PADDING)

        tabContentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            tabContent.CanvasSize = UDim2.new(0, 0, 0, tabContentLayout.AbsoluteContentSize.Y + PADDING * 4)
        end)

        -- Tab button click handler
        tabButton.MouseButton1Click:Connect(function()
            if activeTabButton then
                TweenService:Create(activeTabButton, TweenTable["Fast"], {
                    BackgroundColor3 = THEME.TabButtonNormalBackground, TextColor3 = THEME.TabButtonNormalText
                }):Play()
            end
            if activeTabContent then activeTabContent.Visible = false end
            TweenService:Create(tabButton, TweenTable["Fast"], {
                BackgroundColor3 = THEME.TabButtonSelectedBackground, TextColor3 = THEME.TabButtonSelectedText
            }):Play()
            tabContent.Visible = true
            activeTabButton = tabButton; activeTabContent = tabContent
        end)

        if not activeTabButton then -- Select first tab
            tabButton.BackgroundColor3 = THEME.TabButtonSelectedBackground
            tabButton.TextColor3 = THEME.TabButtonSelectedText
            tabContent.Visible = true
            activeTabButton = tabButton; activeTabContent = tabContent
        end

        -- Tab object for adding elements
        local Tab = {}
        local function createElementFrame(height)
            local frame = Instance.new("Frame")
            frame.Parent = tabContent; frame.BackgroundTransparency = 1
            frame.Size = UDim2.new(1, -(PADDING * 2), 0, height)
            return frame
        end

        -- / Element Functions (Using Theme Colors) ---

        -- Label
        function Tab:NewLabel(text, alignment)
            local THEME = library.ActiveTheme; text = text or "Label"; alignment = string.lower(alignment or "left")
            local labelFrame = createElementFrame(25); labelFrame.Name = "labelFrame"
            local label = Instance.new("TextLabel", labelFrame); label.Name = "label"; label.BackgroundTransparency = 1
            label.Size = UDim2.new(1, 0, 1, 0); label.Font = FONT; label.Text = text
            label.TextColor3 = THEME.PrimaryText; label.TextSize = 14; label.TextYAlignment = Enum.TextYAlignment.Center
            if alignment == "left" then label.TextXAlignment = Enum.TextXAlignment.Left elseif alignment == "right" then label.TextXAlignment = Enum.TextXAlignment.Right elseif alignment == "center" then label.TextXAlignment = Enum.TextXAlignment.Center else label.TextXAlignment = Enum.TextXAlignment.Left end
            local LabelFunctions = {}; function LabelFunctions:SetText(newText) label.Text = newText or ""; return LabelFunctions end; return LabelFunctions
        end

        -- Section
        function Tab:NewSection(text)
            local THEME = library.ActiveTheme; text = text or "Section"
            local sectionFrame = createElementFrame(25); sectionFrame.Name = "sectionFrame"
            local lineThickness = 1; local lineYPos = 0.5
            local textSize = TextService:GetTextSize(text, 14, FONT, Vector2.new(math.huge, 25)); local textWidth = textSize.X + 20
            local totalWidth = sectionFrame.AbsoluteSize.X; if totalWidth == 0 then totalWidth = contentContainer.AbsoluteSize.X - (PADDING * 4) end; local lineWidth = math.max(10, (totalWidth - textWidth) / 2)
            local leftLine = Instance.new("Frame", sectionFrame); leftLine.Name = "leftLine"; leftLine.BackgroundColor3 = THEME.SeparatorColor; leftLine.BorderSizePixel = 0; leftLine.AnchorPoint = Vector2.new(0, 0.5); leftLine.Position = UDim2.new(0, 0, lineYPos, 0); leftLine.Size = UDim2.new(0, lineWidth, 0, lineThickness)
            local rightLine = Instance.new("Frame", sectionFrame); rightLine.Name = "rightLine"; rightLine.BackgroundColor3 = THEME.SeparatorColor; rightLine.BorderSizePixel = 0; rightLine.AnchorPoint = Vector2.new(1, 0.5); rightLine.Position = UDim2.new(1, 0, lineYPos, 0); rightLine.Size = UDim2.new(0, lineWidth, 0, lineThickness)
            local sectionLabel = Instance.new("TextLabel", sectionFrame); sectionLabel.Name = "sectionLabel"; sectionLabel.BackgroundTransparency = 1; sectionLabel.AnchorPoint = Vector2.new(0.5, 0.5); sectionLabel.Position = UDim2.new(0.5, 0, 0.5, 0); sectionLabel.Size = UDim2.new(0, textWidth, 1, 0); sectionLabel.Font = FONT; sectionLabel.Text = text; sectionLabel.TextColor3 = THEME.TitleText; sectionLabel.TextSize = 14; sectionLabel.TextXAlignment = Enum.TextXAlignment.Center; sectionLabel.TextYAlignment = Enum.TextYAlignment.Center
            sectionFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() local newTotalWidth = sectionFrame.AbsoluteSize.X; local newLineWidth = math.max(10, (newTotalWidth - textWidth) / 2); leftLine.Size = UDim2.new(0, newLineWidth, 0, lineThickness); rightLine.Size = UDim2.new(0, newLineWidth, 0, lineThickness) end)
        end

        -- Separator
        function Tab:NewSeparator()
            local THEME = library.ActiveTheme; local separatorFrame = createElementFrame(10); separatorFrame.Name = "separatorFrame"
            local line = Instance.new("Frame", separatorFrame); line.Name = "line"; line.BackgroundColor3 = THEME.SeparatorColor; line.BorderSizePixel = 0; line.AnchorPoint = Vector2.new(0.5, 0.5); line.Position = UDim2.new(0.5, 0, 0.5, 0); line.Size = UDim2.new(1, 0, 0, 1)
        end

        -- Button
        function Tab:NewButton(text, callback)
            local THEME = library.ActiveTheme; text = text or "Button"; callback = callback or function() print("Button '" .. text .. "' clicked") end
            local buttonFrame = createElementFrame(35); buttonFrame.Name = "buttonFrame"
            local button = Instance.new("TextButton", buttonFrame); button.Name = "button"; button.BackgroundColor3 = THEME.ButtonBackground; button.BorderSizePixel = 0; button.Size = UDim2.new(1, 0, 1, 0); button.Font = FONT; button.Text = text; button.TextColor3 = THEME.ButtonText; button.TextSize = 14; button.AutoButtonColor = false
            local buttonCorner = Instance.new("UICorner", button); buttonCorner.CornerRadius = UDim.new(0, 4)
            local originalColor = button.BackgroundColor3; local tweenInfo = TweenTable["Fast"]
            button.MouseEnter:Connect(function() TweenService:Create(button, tweenInfo, {BackgroundColor3 = THEME.ButtonHover}):Play() end)
            button.MouseLeave:Connect(function() TweenService:Create(button, tweenInfo, {BackgroundColor3 = originalColor}):Play() end)
            button.MouseButton1Down:Connect(function() TweenService:Create(button, tweenInfo, {BackgroundColor3 = THEME.ButtonClick}):Play() end)
            button.MouseButton1Up:Connect(function() TweenService:Create(button, tweenInfo, {BackgroundColor3 = THEME.ButtonHover}):Play(); pcall(callback) end)
            local ButtonFunctions = {}; function ButtonFunctions:SetText(newText) button.Text = newText or ""; return ButtonFunctions end; return ButtonFunctions
        end

        -- Toggle
        function Tab:NewToggle(text, defaultState, callback)
            local THEME = library.ActiveTheme; text = text or "Toggle"; defaultState = defaultState or false; callback = callback or function(state) print("Toggle '" .. text .. "' state:", state) end
            local state = defaultState; local toggleFrame = createElementFrame(30); toggleFrame.Name = "toggleFrame"
            local toggleButton = Instance.new("TextButton", toggleFrame); toggleButton.Name = "toggleButton"; toggleButton.BackgroundColor3 = THEME.InputBackground; toggleButton.BorderSizePixel = 0; toggleButton.Size = UDim2.new(1, 0, 1, 0); toggleButton.Font = FONT; toggleButton.Text = ""; toggleButton.AutoButtonColor = false
            local toggleCorner = Instance.new("UICorner", toggleButton); toggleCorner.CornerRadius = UDim.new(0, 4)
            local toggleLabel = Instance.new("TextLabel", toggleButton); toggleLabel.Name = "toggleLabel"; toggleLabel.BackgroundTransparency = 1; toggleLabel.AnchorPoint = Vector2.new(0, 0.5); toggleLabel.Position = UDim2.new(0, 10, 0.5, 0); toggleLabel.Size = UDim2.new(0.7, -50, 1, 0); toggleLabel.Font = FONT; toggleLabel.Text = text; toggleLabel.TextColor3 = THEME.PrimaryText; toggleLabel.TextSize = 14; toggleLabel.TextXAlignment = Enum.TextXAlignment.Left; toggleLabel.TextYAlignment = Enum.TextYAlignment.Center
            local indicatorWidth = 40; local indicatorHeight = 20
            local toggleIndicator = Instance.new("Frame", toggleButton); toggleIndicator.Name = "toggleIndicator"; toggleIndicator.AnchorPoint = Vector2.new(1, 0.5); toggleIndicator.BackgroundColor3 = THEME.ToggleIndicatorOff; toggleIndicator.Position = UDim2.new(1, -10, 0.5, 0); toggleIndicator.Size = UDim2.new(0, indicatorWidth, 0, indicatorHeight)
            local toggleIndicatorCorner = Instance.new("UICorner", toggleIndicator); toggleIndicatorCorner.CornerRadius = UDim.new(1, 0)
            local switchSize = indicatorHeight - 4
            local toggleSwitch = Instance.new("Frame", toggleIndicator); toggleSwitch.Name = "toggleSwitch"; toggleSwitch.BackgroundColor3 = THEME.ToggleSwitchOff; toggleSwitch.AnchorPoint = Vector2.new(0, 0.5); toggleSwitch.Position = UDim2.new(0, 2, 0.5, 0); toggleSwitch.Size = UDim2.new(0, switchSize, 0, switchSize)
            local toggleSwitchCorner = Instance.new("UICorner", toggleSwitch); toggleSwitchCorner.CornerRadius = UDim.new(1, 0)
            local hoverColor = THEME.InputFocusBackground; local originalColor = toggleButton.BackgroundColor3; local tweenInfo = TweenTable["Fast"]
            toggleButton.MouseEnter:Connect(function() TweenService:Create(toggleButton, tweenInfo, {BackgroundColor3 = hoverColor}):Play() end)
            toggleButton.MouseLeave:Connect(function() TweenService:Create(toggleButton, tweenInfo, {BackgroundColor3 = originalColor}):Play() end)
            local function updateToggleVisuals()
                local targetPos, targetColor, targetBgColor
                if state then targetPos = UDim2.new(1, -(switchSize + 2), 0.5, 0); targetColor = THEME.ToggleSwitchOn; targetBgColor = THEME.ToggleIndicatorOn else targetPos = UDim2.new(0, 2, 0.5, 0); targetColor = THEME.ToggleSwitchOff; targetBgColor = THEME.ToggleIndicatorOff end
                TweenService:Create(toggleSwitch, TweenInfo.new(0.2), {Position = targetPos, BackgroundColor3 = targetColor}):Play(); TweenService:Create(toggleIndicator, TweenInfo.new(0.2), {BackgroundColor3 = targetBgColor}):Play()
            end
            toggleButton.MouseButton1Click:Connect(function() state = not state; updateToggleVisuals(); pcall(callback, state) end)
            updateToggleVisuals()
            local ToggleFunctions = {}; function ToggleFunctions:Set(newState) if type(newState) == "boolean" and newState ~= state then state = newState; updateToggleVisuals(); pcall(callback, state) end; return ToggleFunctions end; function ToggleFunctions:Get() return state end
            function ToggleFunctions:AddKeybind(key)
                if not key or typeof(key) ~= "EnumItem" or not key:IsA("KeyCode") then warn("Invalid KeyCode for toggle keybind."); return ToggleFunctions end
                local keyIndicator = Instance.new("TextLabel", toggleButton); keyIndicator.Name = "keyIndicator"; keyIndicator.AnchorPoint = Vector2.new(1, 0.5); keyIndicator.BackgroundTransparency = 1; keyIndicator.Position = UDim2.new(1, -(indicatorWidth + 15), 0.5, 0); keyIndicator.Size = UDim2.new(0, 40, 1, 0); keyIndicator.Font = FONT; keyIndicator.Text = "[" .. key.Name .. "]"; keyIndicator.TextColor3 = THEME.AccentColor; keyIndicator.TextSize = 12; keyIndicator.TextXAlignment = Enum.TextXAlignment.Right; keyIndicator.TextYAlignment = Enum.TextYAlignment.Center; keyIndicator.TextWrapped = false; keyIndicator.TextTruncate = Enum.TextTruncate.AtEnd; keyIndicator.ZIndex = 2
                toggleLabel.Size = UDim2.new(0.7, -(indicatorWidth + 60), 1, 0)
                UserInputService.InputBegan:Connect(function(input, gameProcessed) if not gameProcessed and input.KeyCode == key then local focused = UserInputService:GetFocusedTextBox(); if not focused then state = not state; updateToggleVisuals(); pcall(callback, state) end end end)
                return ToggleFunctions
            end; return ToggleFunctions
        end

        -- Keybind (Reworked)
        function Tab:NewKeybind(text, defaultKey, callback)
            local THEME = library.ActiveTheme; text = text or "Keybind"; callback = callback or function(key) print("Keybind '" .. text .. "' set to:", key and key.Name or "None") end
            local currentKey = defaultKey -- Can be nil for "None" state
            local keybindFrame = createElementFrame(30); keybindFrame.Name = "keybindFrame"

            local keybindButton = Instance.new("TextButton", keybindFrame); keybindButton.Name = "keybindButton"; keybindButton.BackgroundColor3 = THEME.InputBackground; keybindButton.BorderSizePixel = 0; keybindButton.Size = UDim2.new(1, 0, 1, 0); keybindButton.Font = FONT; keybindButton.Text = ""; keybindButton.AutoButtonColor = false
            local keybindCorner = Instance.new("UICorner", keybindButton); keybindCorner.CornerRadius = UDim.new(0, 4)

            local keybindLabel = Instance.new("TextLabel", keybindButton); keybindLabel.Name = "keybindLabel"; keybindLabel.BackgroundTransparency = 1; keybindLabel.AnchorPoint = Vector2.new(0, 0.5); keybindLabel.Position = UDim2.new(0, 10, 0.5, 0); keybindLabel.Size = UDim2.new(0.6, 0, 1, 0); keybindLabel.Font = FONT; keybindLabel.Text = text; keybindLabel.TextColor3 = THEME.PrimaryText; keybindLabel.TextSize = 14; keybindLabel.TextXAlignment = Enum.TextXAlignment.Left; keybindLabel.TextYAlignment = Enum.TextYAlignment.Center

            local keyDisplay = Instance.new("TextLabel", keybindButton); keyDisplay.Name = "keyDisplay"; keyDisplay.BackgroundTransparency = 1; keyDisplay.AnchorPoint = Vector2.new(1, 0.5); keyDisplay.Position = UDim2.new(1, -10, 0.5, 0); keyDisplay.Size = UDim2.new(0.35, 0, 1, 0); keyDisplay.Font = FONT; keyDisplay.Text = "[" .. (currentKey and currentKey.Name or "None") .. "]"; keyDisplay.TextColor3 = THEME.KeybindDisplay; keyDisplay.TextSize = 13; keyDisplay.TextXAlignment = Enum.TextXAlignment.Right; keyDisplay.TextYAlignment = Enum.TextYAlignment.Center

            local hoverColor = THEME.InputFocusBackground; local originalColor = keybindButton.BackgroundColor3; local tweenInfo = TweenTable["Fast"]
            keybindButton.MouseEnter:Connect(function() TweenService:Create(keybindButton, tweenInfo, {BackgroundColor3 = hoverColor}):Play() end)
            keybindButton.MouseLeave:Connect(function() TweenService:Create(keybindButton, tweenInfo, {BackgroundColor3 = originalColor}):Play() end)

            -- Right-click to initiate binding
            keybindButton.MouseButton2Click:Connect(function()
                 library:_CreateKeybindPrompt(keybindButton, function(selectedKey)
                      if selectedKey == "cancel" then return end -- User cancelled with Escape
                      currentKey = selectedKey -- This can be nil if cleared
                      keyDisplay.Text = "[" .. (currentKey and currentKey.Name or "None") .. "]"
                      pcall(callback, currentKey)
                 end)
            end)

            local KeybindFunctions = {};
            function KeybindFunctions:Set(newKey)
                 if (newKey and typeof(newKey) == "EnumItem" and newKey:IsA("KeyCode")) or newKey == nil then
                      currentKey = newKey
                      keyDisplay.Text = "[" .. (currentKey and currentKey.Name or "None") .. "]"
                      pcall(callback, currentKey)
                 else warn("Invalid KeyCode or value provided for :Set()") end
                 return KeybindFunctions
            end
            function KeybindFunctions:Get() return currentKey end
            return KeybindFunctions
        end

        -- Textbox
        function Tab:NewTextbox(text, placeholder, isPassword, callback)
            local THEME = library.ActiveTheme; text = text or ""; placeholder = placeholder or "Enter text..."; isPassword = isPassword or false; callback = callback or function(newText) print("Textbox content:", newText) end
            local textboxFrame = createElementFrame(35); textboxFrame.Name = "textboxFrame"
            local textbox = Instance.new("TextBox", textboxFrame); textbox.Name = "textbox"; textbox.BackgroundColor3 = THEME.InputBackground; textbox.BorderSizePixel = 0; textbox.Size = UDim2.new(1, 0, 1, 0); textbox.Font = FONT; textbox.Text = text; textbox.PlaceholderText = placeholder; textbox.PlaceholderColor3 = THEME.InputPlaceholder; textbox.TextColor3 = THEME.InputText; textbox.TextSize = 14; textbox.TextWrapped = false; textbox.ClearTextOnFocus = false; textbox.TextXAlignment = Enum.TextXAlignment.Left; textbox.TextYAlignment = Enum.TextYAlignment.Center; textbox.TextEditable = true; textbox.TextPassword = isPassword; textbox.ClipsDescendants = true
            local textboxPadding = Instance.new("UIPadding", textbox); textboxPadding.PaddingLeft = UDim.new(0, 10); textboxPadding.PaddingRight = UDim.new(0, 10); textboxPadding.PaddingTop = UDim.new(0, 2); textboxPadding.PaddingBottom = UDim.new(0, 2)
            local textboxCorner = Instance.new("UICorner", textbox); textboxCorner.CornerRadius = UDim.new(0, 4)
            local focusColor = THEME.InputFocusBackground; local originalColor = textbox.BackgroundColor3; local tweenInfo = TweenTable["Fast"]
            textbox.Focused:Connect(function() TweenService:Create(textbox, tweenInfo, {BackgroundColor3 = focusColor}):Play() end)
            textbox.FocusLost:Connect(function(enterPressed) TweenService:Create(textbox, tweenInfo, {BackgroundColor3 = originalColor}):Play(); pcall(callback, textbox.Text) end)
            local TextboxFunctions = {}; function TextboxFunctions:SetText(newText) textbox.Text = newText or ""; return TextboxFunctions end; function TextboxFunctions:GetText() return textbox.Text end; function TextboxFunctions:Clear() textbox.Text = ""; return TextboxFunctions end; function TextboxFunctions:SetEditable(editable) textbox.TextEditable = (editable == true); return TextboxFunctions end; return TextboxFunctions
        end

        -- Slider
        function Tab:NewSlider(text, min, max, default, precision, callback)
            local THEME = library.ActiveTheme; text = text or "Slider"; min = tonumber(min) or 0; max = tonumber(max) or 100; default = math.clamp(tonumber(default) or min, min, max); precision = tonumber(precision) or 0; callback = callback or function(value) print("Slider '" .. text .. "' value:", value) end
            local currentValue = default; local sliderFrame = createElementFrame(45); sliderFrame.Name = "sliderFrame"
            local sliderLabel = Instance.new("TextLabel", sliderFrame); sliderLabel.Name = "sliderLabel"; sliderLabel.BackgroundTransparency = 1; sliderLabel.Position = UDim2.new(0, 0, 0, 0); sliderLabel.Size = UDim2.new(0.7, 0, 0, 20); sliderLabel.Font = FONT; sliderLabel.Text = text; sliderLabel.TextColor3 = THEME.PrimaryText; sliderLabel.TextSize = 14; sliderLabel.TextXAlignment = Enum.TextXAlignment.Left; sliderLabel.TextYAlignment = Enum.TextYAlignment.Center
            local valueLabel = Instance.new("TextLabel", sliderFrame); valueLabel.Name = "valueLabel"; valueLabel.BackgroundTransparency = 1; valueLabel.AnchorPoint = Vector2.new(1, 0); valueLabel.Position = UDim2.new(1, 0, 0, 0); valueLabel.Size = UDim2.new(0.3, 0, 0, 20); valueLabel.Font = FONT; valueLabel.Text = string.format("%." .. precision .. "f", currentValue); valueLabel.TextColor3 = THEME.AccentColor; valueLabel.TextSize = 13; valueLabel.TextXAlignment = Enum.TextXAlignment.Right; valueLabel.TextYAlignment = Enum.TextYAlignment.Center
            local trackHeight = 6; local track = Instance.new("Frame", sliderFrame); track.Name = "track"; track.BackgroundColor3 = THEME.SliderTrack; track.BorderSizePixel = 0; track.AnchorPoint = Vector2.new(0.5, 1); track.Position = UDim2.new(0.5, 0, 1, -5); track.Size = UDim2.new(1, 0, 0, trackHeight)
            local trackCorner = Instance.new("UICorner", track); trackCorner.CornerRadius = UDim.new(1, 0)
            local fill = Instance.new("Frame", track); fill.Name = "fill"; fill.BackgroundColor3 = THEME.SliderFill; fill.BorderSizePixel = 0; fill.Position = UDim2.new(0, 0, 0, 0); fill.Size = UDim2.new(0, 0, 1, 0)
            local fillCorner = Instance.new("UICorner", fill); fillCorner.CornerRadius = UDim.new(1, 0)
            local handleSize = 12; local handle = Instance.new("Frame", track); handle.Name = "handle"; handle.BackgroundColor3 = THEME.SliderHandle; handle.BorderSizePixel = 0; handle.AnchorPoint = Vector2.new(0.5, 0.5); handle.Position = UDim2.new(0, 0, 0.5, 0); handle.Size = UDim2.new(0, handleSize, 0, handleSize); handle.ZIndex = 3
            local handleCorner = Instance.new("UICorner", handle); handleCorner.CornerRadius = UDim.new(1, 0)
            local isDragging = false; local dragInput = nil; local inputChangedConn = nil; local inputEndedConn = nil
            local function updateSliderFromX(absoluteX)
                local trackStartX = track.AbsolutePosition.X; local trackWidth = track.AbsoluteSize.X; if trackWidth <= 0 then return end
                local relativeX = absoluteX - trackStartX; local fraction = math.clamp(relativeX / trackWidth, 0, 1)
                local newValue = min + (max - min) * fraction; local power = 10^precision; newValue = math.floor(newValue * power + 0.5) / power; newValue = math.clamp(newValue, min, max)
                if newValue ~= currentValue then currentValue = newValue; valueLabel.Text = string.format("%." .. precision .. "f", currentValue); local fillFraction = (currentValue - min) / (max - min); TweenService:Create(fill, TweenInfo.new(0.05), {Size = UDim2.new(fillFraction, 0, 1, 0)}):Play(); TweenService:Create(handle, TweenInfo.new(0.05), {Position = UDim2.new(fillFraction, 0, 0.5, 0)}):Play(); pcall(callback, currentValue) end
            end
            local initialFraction = (default - min) / (max - min); fill.Size = UDim2.new(initialFraction, 0, 1, 0); handle.Position = UDim2.new(initialFraction, 0, 0.5, 0)
            local function stopDragging() if isDragging then isDragging = false; dragInput = nil; if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end; if inputEndedConn then inputEndedConn:Disconnect(); inputEndedConn = nil end end end
            local function startDragging(input) if isDragging then return end; isDragging = true; dragInput = input; updateSliderFromX(input.Position.X); if inputChangedConn then inputChangedConn:Disconnect() end; if inputEndedConn then inputEndedConn:Disconnect() end; inputChangedConn = UserInputService.InputChanged:Connect(function(changedInput) if isDragging and (changedInput.UserInputType == Enum.UserInputType.MouseMovement or changedInput.UserInputType == Enum.UserInputType.Touch) then updateSliderFromX(changedInput.Position.X) end end); inputEndedConn = dragInput.Changed:Connect(function() if dragInput.UserInputState == Enum.UserInputState.End then stopDragging() end end) end
            track.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then startDragging(input) end end)
            handle.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then startDragging(input) end end)
            track.InputEnded:Connect(function(input) if input == dragInput then stopDragging() end end); handle.InputEnded:Connect(function(input) if input == dragInput then stopDragging() end end)
            local SliderFunctions = {}; function SliderFunctions:Set(newValue) newValue = tonumber(newValue); if newValue then local power = 10^precision; newValue = math.floor(newValue * power + 0.5) / power; newValue = math.clamp(newValue, min, max); if newValue ~= currentValue then currentValue = newValue; valueLabel.Text = string.format("%." .. precision .. "f", currentValue); local fillFraction = (currentValue - min) / (max - min); fill.Size = UDim2.new(fillFraction, 0, 1, 0); handle.Position = UDim2.new(fillFraction, 0, 0.5, 0); pcall(callback, currentValue) end end; return SliderFunctions end; function SliderFunctions:Get() return currentValue end; return SliderFunctions
        end

        -- Dropdown (Reworked Visuals)
        function Tab:NewDropdown(text, options, defaultIndex, callback)
            local THEME = library.ActiveTheme; text = text or "Dropdown"; options = options or {"Option 1"}; defaultIndex = math.clamp(tonumber(defaultIndex) or 1, 1, #options); callback = callback or function(selectedOption, index) print("Dropdown '" .. text .. "' selected:", selectedOption, "at index", index) end
            local isOpen = false; local currentSelectionIndex = defaultIndex; local currentSelectionText = #options > 0 and options[currentSelectionIndex] or ""
            local dropdownFrame = createElementFrame(35); dropdownFrame.Name = "dropdownFrame"; dropdownFrame.ClipsDescendants = false; dropdownFrame.ZIndex = 2
            local dropdownButton = Instance.new("TextButton", dropdownFrame); dropdownButton.Name = "dropdownButton"; dropdownButton.BackgroundColor3 = THEME.InputBackground; dropdownButton.BorderSizePixel = 0; dropdownButton.Size = UDim2.new(1, 0, 1, 0); dropdownButton.Font = FONT; dropdownButton.Text = ""; dropdownButton.AutoButtonColor = false; dropdownButton.ZIndex = 3
            local dropdownCorner = Instance.new("UICorner", dropdownButton); dropdownCorner.CornerRadius = UDim.new(0, 4)
            local dropdownLabel = Instance.new("TextLabel", dropdownButton); dropdownLabel.Name = "dropdownLabel"; dropdownLabel.BackgroundTransparency = 1; dropdownLabel.AnchorPoint = Vector2.new(0, 0.5); dropdownLabel.Position = UDim2.new(0, 10, 0.5, 0); dropdownLabel.Size = UDim2.new(1, -35, 1, 0); dropdownLabel.Font = FONT; dropdownLabel.Text = currentSelectionText; dropdownLabel.TextColor3 = THEME.InputText; dropdownLabel.TextSize = 14; dropdownLabel.TextXAlignment = Enum.TextXAlignment.Left; dropdownLabel.TextYAlignment = Enum.TextYAlignment.Center; dropdownLabel.TextTruncate = Enum.TextTruncate.AtEnd
            local arrowSize = 10; local arrow = Instance.new("Frame", dropdownButton); arrow.Name = "arrow"; arrow.BackgroundTransparency = 1; arrow.AnchorPoint = Vector2.new(1, 0.5); arrow.Position = UDim2.new(1, -10, 0.5, 0); arrow.Size = UDim2.new(0, arrowSize, 0, arrowSize); arrow.Rotation = 0; arrow.ZIndex = 4
            local arrowIcon = Instance.new("ImageLabel", arrow); arrowIcon.BackgroundTransparency = 1; arrowIcon.Image = "rbxassetid://3926305904"; arrowIcon.ImageColor3 = THEME.DropdownArrow; arrowIcon.Size = UDim2.fromScale(1, 1); arrowIcon.AnchorPoint = Vector2.new(0.5, 0.5); arrowIcon.Position = UDim2.fromScale(0.5, 0.5)

            local optionsListHeight = 120; local optionHeight = 30
            local optionsList = Instance.new("ScrollingFrame", dropdownFrame); optionsList.Name = "optionsList"; optionsList.BackgroundColor3 = THEME.DropdownListBackground; optionsList.BorderSizePixel = 1; optionsList.BorderColor3 = THEME.DropdownListBorder; optionsList.Position = UDim2.new(0, 0, 1, 3); optionsList.Size = UDim2.new(1, 0, 0, 0); optionsList.Visible = false; optionsList.Active = true; optionsList.ScrollBarThickness = 4; optionsList.ScrollBarImageColor3 = THEME.ScrollbarColor; optionsList.CanvasSize = UDim2.new(0, 0, 0, #options * optionHeight); optionsList.ClipsDescendants = true; optionsList.ZIndex = 5
            local optionsListCorner = Instance.new("UICorner", optionsList); optionsListCorner.CornerRadius = UDim.new(0, 4)
            local optionsListLayout = Instance.new("UIListLayout", optionsList); optionsListLayout.SortOrder = Enum.SortOrder.LayoutOrder; optionsListLayout.Padding = UDim.new(0, 2)

            local function closeDropdown() if not isOpen then return end; isOpen = false; optionsList.Visible = false; TweenService:Create(optionsList, TweenTable["Fast"], {Size = UDim2.new(1, 0, 0, 0)}):Play(); TweenService:Create(arrow, TweenTable["Fast"], {Rotation = 0}):Play() end
            local function openDropdown() if isOpen then return end; isOpen = true; optionsList.Visible = true; local targetHeight = math.min(optionsListHeight, optionsList.CanvasSize.Y.Offset); TweenService:Create(optionsList, TweenTable["Fast"], {Size = UDim2.new(1, 0, 0, targetHeight)}):Play(); TweenService:Create(arrow, TweenTable["Fast"], {Rotation = 180}):Play(); dropdownFrame.ZIndex = 10; task.delay(0.2, function() if dropdownFrame and dropdownFrame.Parent and not isOpen then dropdownFrame.ZIndex = 2 end end) end
            local function populateOptions()
                 for _, child in ipairs(optionsList:GetChildren()) do if child:IsA("TextButton") or child:IsA("Frame") then child:Destroy() end end -- Clear buttons and selection indicators
                 optionsList.CanvasSize = UDim2.new(0, 0, 0, #options * optionHeight)
                 for i, optionText in ipairs(options) do
                      local optionButton = Instance.new("TextButton", optionsList); optionButton.Name = "option_" .. i; optionButton.BackgroundColor3 = THEME.DropdownOptionBackground; optionButton.BorderSizePixel = 0; optionButton.Size = UDim2.new(1, 0, 0, optionHeight); optionButton.Font = FONT; optionButton.Text = ""; optionButton.AutoButtonColor = false -- Text handled by label inside
                      local optionLabel = Instance.new("TextLabel", optionButton); optionLabel.BackgroundTransparency = 1; optionLabel.Size = UDim2.new(1, -15, 1, 0); optionLabel.Position = UDim2.new(0, 10, 0, 0); optionLabel.Font = FONT; optionLabel.Text = optionText; optionLabel.TextColor3 = THEME.PrimaryText; optionLabel.TextSize = 14; optionLabel.TextXAlignment = Enum.TextXAlignment.Left; optionLabel.TextYAlignment = Enum.TextYAlignment.Center
                      local selectionIndicator = Instance.new("Frame", optionButton); selectionIndicator.Name = "SelectedMark"; selectionIndicator.Size = UDim2.new(0, 3, 0.6, 0); selectionIndicator.Position = UDim2.new(0, 3, 0.5, 0); selectionIndicator.AnchorPoint = Vector2.new(0, 0.5); selectionIndicator.BackgroundColor3 = THEME.DropdownOptionSelectedBackground; selectionIndicator.Visible = (i == currentSelectionIndex); selectionIndicator.BorderSizePixel = 0; Instance.new("UICorner", selectionIndicator).CornerRadius = UDim.new(0, 2)

                      if i == currentSelectionIndex then optionLabel.TextColor3 = THEME.DropdownOptionSelectedText; optionButton.BackgroundColor3 = THEME.DropdownOptionSelectedBackground else optionLabel.TextColor3 = THEME.PrimaryText; optionButton.BackgroundColor3 = THEME.DropdownOptionBackground end
                      local optHoverColor = THEME.DropdownOptionHover; local optOriginalColor = optionButton.BackgroundColor3
                      optionButton.MouseEnter:Connect(function() if i ~= currentSelectionIndex then TweenService:Create(optionButton, TweenTable["Fast"], {BackgroundColor3 = optHoverColor}):Play() end end)
                      optionButton.MouseLeave:Connect(function() if i ~= currentSelectionIndex then TweenService:Create(optionButton, TweenTable["Fast"], {BackgroundColor3 = optOriginalColor}):Play() end end)
                      optionButton.MouseButton1Click:Connect(function()
                           local previousSelectedButton = optionsList:FindFirstChild("option_" .. currentSelectionIndex)
                           if previousSelectedButton then local prevLabel = previousSelectedButton:FindFirstChildWhichIsA("TextLabel"); local prevMark = previousSelectedButton:FindFirstChild("SelectedMark"); if prevLabel then prevLabel.TextColor3 = THEME.PrimaryText end; if prevMark then prevMark.Visible = false end; previousSelectedButton.BackgroundColor3 = THEME.DropdownOptionBackground end
                           currentSelectionIndex = i; currentSelectionText = optionText; dropdownLabel.Text = currentSelectionText
                           optionLabel.TextColor3 = THEME.DropdownOptionSelectedText; selectionIndicator.Visible = true; optionButton.BackgroundColor3 = THEME.DropdownOptionSelectedBackground; optOriginalColor = optionButton.BackgroundColor3
                           closeDropdown(); pcall(callback, currentSelectionText, currentSelectionIndex)
                      end)
                 end
            end; populateOptions()
            dropdownButton.MouseButton1Click:Connect(function() if isOpen then closeDropdown() else openDropdown() end end)
            local clickOutsideConnection = UserInputService.InputBegan:Connect(function(input) if isOpen and input.UserInputType == Enum.UserInputType.MouseButton1 then local mousePos = UserInputService:GetMouseLocation(); local framePos = dropdownFrame and dropdownFrame.AbsolutePosition or Vector2.new(); local frameSize = dropdownFrame and dropdownFrame.AbsoluteSize or Vector2.new(); local listPos = optionsList and optionsList.AbsolutePosition or Vector2.new(); local listSize = optionsList and optionsList.AbsoluteSize or Vector2.new(); local frameRect = Rect.new(framePos, framePos + frameSize); local listRect = Rect.new(listPos, listPos + listSize); if not frameRect:Contains(mousePos) and not listRect:Contains(mousePos) then closeDropdown(); dropdownFrame.ZIndex = 2 end end end)
            dropdownFrame.Destroying:Connect(function() if clickOutsideConnection then clickOutsideConnection:Disconnect() end end)
            local DropdownFunctions = {}; function DropdownFunctions:SetSelected(indexOrValue) local targetIndex = -1; if type(indexOrValue) == "number" then targetIndex = math.floor(indexOrValue) elseif type(indexOrValue) == "string" then for i, opt in ipairs(options) do if opt == indexOrValue then targetIndex = i; break end end end; if targetIndex >= 1 and targetIndex <= #options and targetIndex ~= currentSelectionIndex then local previousSelectedButton = optionsList:FindFirstChild("option_" .. currentSelectionIndex); if previousSelectedButton then local prevLabel = previousSelectedButton:FindFirstChildWhichIsA("TextLabel"); local prevMark = previousSelectedButton:FindFirstChild("SelectedMark"); if prevLabel then prevLabel.TextColor3 = THEME.PrimaryText end; if prevMark then prevMark.Visible = false end; previousSelectedButton.BackgroundColor3 = THEME.DropdownOptionBackground end; currentSelectionIndex = targetIndex; currentSelectionText = options[currentSelectionIndex]; dropdownLabel.Text = currentSelectionText; local newSelectedButton = optionsList:FindFirstChild("option_" .. currentSelectionIndex); if newSelectedButton then local newLabel = newSelectedButton:FindFirstChildWhichIsA("TextLabel"); local newMark = newSelectedButton:FindFirstChild("SelectedMark"); if newLabel then newLabel.TextColor3 = THEME.DropdownOptionSelectedText end; if newMark then newMark.Visible = true end; newSelectedButton.BackgroundColor3 = THEME.DropdownOptionSelectedBackground end; pcall(callback, currentSelectionText, currentSelectionIndex) end; return DropdownFunctions end; function DropdownFunctions:GetSelected() return currentSelectionText, currentSelectionIndex end; function DropdownFunctions:GetOptions() return options end
            function DropdownFunctions:UpdateOptions(newOptions) if type(newOptions) ~= "table" then warn("UpdateOptions requires a table."); return DropdownFunctions end; options = newOptions; currentSelectionIndex = 1; if #options == 0 then currentSelectionText = "" else currentSelectionText = options[currentSelectionIndex] or "" end; dropdownLabel.Text = currentSelectionText; populateOptions(); return DropdownFunctions end; return DropdownFunctions
        end

        return Tab
    end

    return Window
end

return library
