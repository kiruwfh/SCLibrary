--[[
  UI lib made by (SupremeCreativity) sc.owner

  - Please do not use this without permission, I am working really hard on this UI to make it perfect and do not have a big
    problem with other people using it, please just make sure you message me and ask me before using.

  Enhanced and completed by Assistant.
  Version 2.1.0: Reworked Dropdown, Reworked Keybind input (Right-Click), Added FPS to Watermark, Added Theming System.
]]

-- / Locals
local Workspace = game:GetService("Workspace")
local Player = game:GetService("Players").LocalPlayer
local Mouse -- Defined later if needed, UserInputService is preferred

-- / Services
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CoreGuiService = game:GetService("CoreGui")
local ContentService = game:GetService("ContentProvider")
local TeleportService = game:GetService("TeleportService")
local Lighting = game:GetService("Lighting")

-- / Tween table & function
local TweenTable = {
    Default = TweenInfo.new(0.17, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0)
}

-- Function to create and store TweenInfo objects
local CreateTween = function(name, speed, style, direction, loop, reverse, delay)
    name = name or "UnnamedTween"
    speed = speed or 0.17
    style = style or Enum.EasingStyle.Sine
    direction = direction or Enum.EasingDirection.InOut
    loop = loop or 0
    reverse = reverse or false
    delay = delay or 0

    TweenTable[name] = TweenInfo.new(speed, style, direction, loop, reverse, delay)
end

-- / Dragging Functionality (Applied to the object passed)
-- Makes a GUI object draggable
local drag = function(draggableObject, targetObject, latency)
    latency = latency or 0.06
    local dragging = false
    local dragInput = nil
    local dragStart = nil
    local startPos = nil
    local inputChangedConn = nil
    local inputEndedConn = nil

    local function updateInput(input)
        if not dragging or not startPos or not dragStart then return end
        local delta = input.Position - dragStart
        local newPosition = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        TweenService:Create(targetObject, TweenInfo.new(latency), {Position = newPosition}):Play()
    end

    local function stopDragging()
        if dragging then
            dragging = false
            dragStart = nil
            startPos = nil
            if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end
            if inputEndedConn then inputEndedConn:Disconnect(); inputEndedConn = nil end
        end
    end

    draggableObject.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            if dragging then return end
            dragging = true
            dragStart = input.Position
            startPos = targetObject.Position
            dragInput = input
            if inputChangedConn then inputChangedConn:Disconnect() end
            if inputEndedConn then inputEndedConn:Disconnect() end

            inputChangedConn = UserInputService.InputChanged:Connect(function(changedInput)
                if dragging and (changedInput.UserInputType == Enum.UserInputType.MouseMovement or changedInput.UserInputType == Enum.UserInputType.Touch) then
                    updateInput(changedInput)
                end
            end)

            inputEndedConn = dragInput.Changed:Connect(function()
                if dragInput.UserInputState == Enum.UserInputState.End then
                    stopDragging()
                end
            end)
        end
    end)

    draggableObject.InputEnded:Connect(function(input)
        if input == dragInput then
             stopDragging()
        end
    end)
end

-- / Library Definition
local library = {
    version = "2.1.0", -- Incremented version
    title = "SC " .. tostring(math.random(1, 366)),
    fps = 0,
    rank = "private",
    keybind = Enum.KeyCode.RightAlt, -- Default keybind (Point 3)
    activeKeybindConnection = nil,
    mainGui = nil, -- Store reference to the main ScreenGui
    mainFrame = nil, -- Store reference to the main Frame
    headerFrame = nil, -- Store reference to header
    tabContainerFrame = nil, -- Store reference to tab container
    contentContainerFrame = nil, -- Store reference to content container
    watermarkScreenGui = nil, -- Store reference to watermark GUI
    notificationScreenGui = nil, -- Store reference to notification GUI
    themes = {}, -- Table to hold theme definitions
    activeTheme = nil -- Currently active theme table
}

-- Define Default Themes (Point 5)
library.themes = {
    Default = {
        name = "Default",
        -- Main UI Colors
        mainBg = Color3.fromRGB(34, 34, 34),
        headerBg = Color3.fromRGB(26, 26, 26),
        tabContainerBg = Color3.fromRGB(30, 30, 30),
        contentContainerBg = Color3.fromRGB(30, 30, 30),
        scrollbar = Color3.fromRGB(159, 115, 255),
        closeButton = Color3.fromRGB(255, 95, 95),
        closeButtonHover = Color3.fromRGB(255, 140, 140),
        -- Text Colors
        title = Color3.fromRGB(159, 115, 255), -- Accent color used for titles
        text = Color3.fromRGB(200, 200, 200), -- Standard text
        textLight = Color3.fromRGB(220, 220, 220), -- Brighter text (e.g., keybind value)
        textDark = Color3.fromRGB(150, 150, 150), -- Dimmer text (e.g., placeholders)
        textButton = Color3.fromRGB(255, 255, 255), -- Text on accent buttons
        -- Element Backgrounds
        elementBg = Color3.fromRGB(45, 45, 45), -- General bg for buttons, inputs
        elementBgLight = Color3.fromRGB(50, 50, 50), -- Slightly lighter bg (dropdown options)
        elementHover = Color3.fromRGB(55, 55, 55), -- Hover state for elements
        elementActive = Color3.fromRGB(65, 65, 65), -- Active/click state
        elementOutline = Color3.fromRGB(60, 60, 60), -- Borders, separators
        -- Specific Element Colors
        tabButtonNormalBg = Color3.fromRGB(40, 40, 40),
        tabButtonSelectedBg = Color3.fromRGB(50, 50, 50),
        tabButtonSelectedText = Color3.fromRGB(159, 115, 255), -- Use accent for selected tab text
        toggleIndicatorOff = Color3.fromRGB(60, 60, 60),
        toggleIndicatorOn = Color3.fromRGB(70, 70, 70),
        toggleSwitchOff = Color3.fromRGB(200, 200, 200),
        toggleSwitchOn = Color3.fromRGB(159, 115, 255), -- Use accent for ON switch
        sliderFill = Color3.fromRGB(159, 115, 255), -- Use accent for slider fill
        sliderHandle = Color3.fromRGB(220, 220, 220),
        error = Color3.fromRGB(255, 90, 90),
        warning = Color3.fromRGB(255, 255, 100),
        success = Color3.fromRGB(131, 255, 103),
        -- Notification/Watermark Specific
        wmBar = Color3.fromRGB(159, 115, 255),
        wmEdge = Color3.fromRGB(60, 60, 60),
        wmGradientStart = Color3.fromRGB(34, 34, 34),
        wmGradientEnd = Color3.fromRGB(28, 28, 28),
        notifDefaultBar = Color3.fromRGB(159, 115, 255),
        notifAlertBar = Color3.fromRGB(255, 246, 112),
        notifErrorBar = Color3.fromRGB(255, 74, 77),
        notifSuccessBar = Color3.fromRGB(131, 255, 103),
        notifInfoBar = Color3.fromRGB(126, 117, 255),
        -- Key Prompt Specific
        keyPromptBg = Color3.fromRGB(34, 34, 34),
        keyPromptTextboxBg = Color3.fromRGB(45, 45, 45),
        keyPromptButtonBg = Color3.fromRGB(159, 115, 255),
    },
    LightTheme = {
        name = "Light",
        mainBg = Color3.fromRGB(245, 245, 245),
        headerBg = Color3.fromRGB(255, 255, 255),
        tabContainerBg = Color3.fromRGB(250, 250, 250),
        contentContainerBg = Color3.fromRGB(255, 255, 255),
        scrollbar = Color3.fromRGB(0, 122, 255),
        closeButton = Color3.fromRGB(255, 59, 48),
        closeButtonHover = Color3.fromRGB(230, 50, 40),
        title = Color3.fromRGB(0, 122, 255),
        text = Color3.fromRGB(30, 30, 30),
        textLight = Color3.fromRGB(10, 10, 10),
        textDark = Color3.fromRGB(120, 120, 120),
        textButton = Color3.fromRGB(255, 255, 255),
        elementBg = Color3.fromRGB(235, 235, 240),
        elementBgLight = Color3.fromRGB(240, 240, 245),
        elementHover = Color3.fromRGB(225, 225, 230),
        elementActive = Color3.fromRGB(215, 215, 220),
        elementOutline = Color3.fromRGB(200, 200, 200),
        tabButtonNormalBg = Color3.fromRGB(240, 240, 240),
        tabButtonSelectedBg = Color3.fromRGB(220, 220, 225),
        tabButtonSelectedText = Color3.fromRGB(0, 122, 255),
        toggleIndicatorOff = Color3.fromRGB(210, 210, 210),
        toggleIndicatorOn = Color3.fromRGB(190, 220, 255),
        toggleSwitchOff = Color3.fromRGB(130, 130, 130),
        toggleSwitchOn = Color3.fromRGB(0, 122, 255),
        sliderFill = Color3.fromRGB(0, 122, 255),
        sliderHandle = Color3.fromRGB(80, 80, 80),
        error = Color3.fromRGB(255, 59, 48),
        warning = Color3.fromRGB(255, 149, 0),
        success = Color3.fromRGB(52, 199, 89),
        wmBar = Color3.fromRGB(0, 122, 255),
        wmEdge = Color3.fromRGB(200, 200, 200),
        wmGradientStart = Color3.fromRGB(255, 255, 255),
        wmGradientEnd = Color3.fromRGB(245, 245, 245),
        notifDefaultBar = Color3.fromRGB(0, 122, 255),
        notifAlertBar = Color3.fromRGB(255, 204, 0),
        notifErrorBar = Color3.fromRGB(255, 59, 48),
        notifSuccessBar = Color3.fromRGB(52, 199, 89),
        notifInfoBar = Color3.fromRGB(88, 86, 214),
        keyPromptBg = Color3.fromRGB(245, 245, 245),
        keyPromptTextboxBg = Color3.fromRGB(235, 235, 240),
        keyPromptButtonBg = Color3.fromRGB(0, 122, 255),
    },
     DarkerTheme = {
        name = "Darker",
        mainBg = Color3.fromRGB(24, 24, 24),
        headerBg = Color3.fromRGB(18, 18, 18),
        tabContainerBg = Color3.fromRGB(20, 20, 20),
        contentContainerBg = Color3.fromRGB(22, 22, 22),
        scrollbar = Color3.fromRGB(100, 100, 100),
        closeButton = Color3.fromRGB(255, 95, 95),
        closeButtonHover = Color3.fromRGB(255, 140, 140),
        title = Color3.fromRGB(200, 200, 200), -- Less vibrant title
        text = Color3.fromRGB(180, 180, 180),
        textLight = Color3.fromRGB(210, 210, 210),
        textDark = Color3.fromRGB(120, 120, 120),
        textButton = Color3.fromRGB(20, 20, 20), -- Dark text on accent
        elementBg = Color3.fromRGB(35, 35, 35),
        elementBgLight = Color3.fromRGB(40, 40, 40),
        elementHover = Color3.fromRGB(45, 45, 45),
        elementActive = Color3.fromRGB(55, 55, 55),
        elementOutline = Color3.fromRGB(50, 50, 50),
        tabButtonNormalBg = Color3.fromRGB(30, 30, 30),
        tabButtonSelectedBg = Color3.fromRGB(45, 45, 45),
        tabButtonSelectedText = Color3.fromRGB(210, 210, 210), -- Brighter text for selected tab
        toggleIndicatorOff = Color3.fromRGB(50, 50, 50),
        toggleIndicatorOn = Color3.fromRGB(60, 60, 60),
        toggleSwitchOff = Color3.fromRGB(150, 150, 150),
        toggleSwitchOn = Color3.fromRGB(190, 190, 190), -- Use lighter grey for ON switch
        sliderFill = Color3.fromRGB(100, 100, 100), -- Grey slider fill
        sliderHandle = Color3.fromRGB(200, 200, 200),
        error = Color3.fromRGB(255, 90, 90),
        warning = Color3.fromRGB(220, 220, 80),
        success = Color3.fromRGB(100, 220, 100),
        wmBar = Color3.fromRGB(100, 100, 100),
        wmEdge = Color3.fromRGB(50, 50, 50),
        wmGradientStart = Color3.fromRGB(28, 28, 28),
        wmGradientEnd = Color3.fromRGB(22, 22, 22),
        notifDefaultBar = Color3.fromRGB(100, 100, 100),
        notifAlertBar = Color3.fromRGB(220, 220, 80),
        notifErrorBar = Color3.fromRGB(255, 90, 90),
        notifSuccessBar = Color3.fromRGB(100, 220, 100),
        notifInfoBar = Color3.fromRGB(90, 90, 180),
        keyPromptBg = Color3.fromRGB(24, 24, 24),
        keyPromptTextboxBg = Color3.fromRGB(35, 35, 35),
        keyPromptButtonBg = Color3.fromRGB(100, 100, 100),
    }
}
library.activeTheme = library.themes.Default -- Set default theme

-- The correct key for the library (Consider more secure methods if needed)
local CorrectKey = "hh.hg**@@"
local KeyEntered = false -- Flag to track if the key has been entered successfully

-- Coroutine to update FPS counter
local fpsUpdateActive = true
coroutine.wrap(function()
    local lastUpdate = 0
    local updateInterval = 0.25 -- Update FPS display 4 times per second
    while fpsUpdateActive do
        local now = tick()
        local dt = RunService.Heartbeat:Wait()
        library.fps = math.floor(1 / dt + 0.5)

        -- Throttle UI updates
        if library.watermarkScreenGui and library.fpsWatermarkControls and (now - lastUpdate >= updateInterval) then
            pcall(function() -- Wrap in pcall in case element is destroyed
                 library.fpsWatermarkControls:Text("FPS: " .. library.fps)
            end)
            lastUpdate = now
        end
        if not fpsUpdateActive then break end -- Exit if flag is false
    end
end)()

-- Function to stop the FPS updater coroutine
function library:StopFpsUpdater()
    fpsUpdateActive = false
end

-- / Utility Functions

-- Rounds a number to a specified number of decimal places
function library:RoundNumber(float, int)
    int = int or 0
    return tonumber(string.format("%." .. int .. "f", float))
end

-- Gets the local player's username
function library:GetUsername()
    return Player.Name
end

-- Checks if the game has finished loading
function library:CheckIfLoaded()
    return game:IsLoaded()
end

-- Gets the local player's UserID
function library:GetUserId()
    return Player.UserId
end

-- Gets the current game's PlaceId
function library:GetPlaceId()
    return game.PlaceId
end

-- Gets the current server's JobId
function library:GetJobId()
    return game.JobId
end

-- Teleports the player back to the same server instance
function library:Rejoin()
    pcall(function() -- Wrap in pcall for safety
        TeleportService:TeleportToPlaceInstance(library:GetPlaceId(), library:GetJobId(), Player)
    end)
end

-- Copies text to the clipboard (Synapse X specific)
function library:Copy(input)
    if syn and syn.write_clipboard then -- Check if 'syn' and the function exist
        syn.write_clipboard(input)
    else
        warn("Synapse X specific function 'write_clipboard' is not available. Copy function will not work.")
        -- Provide a fallback or alternative if possible/needed
    end
end

-- Gets parts of the current date (Day)
function library:GetDay(type)
    type = string.lower(type or "")
    if type == "word" then return os.date("%A") -- Full weekday name
    elseif type == "short" then return os.date("%a") -- Abbreviated weekday name
    elseif type == "month" then return os.date("%d") -- Day of the month (01-31)
    elseif type == "year" then return os.date("%j") -- Day of the year (001-366)
    else return os.date("%d") -- Default to day of the month
    end
end

-- Gets parts of the current time
function library:GetTime(type)
    type = string.lower(type or "")
    if type == "24h" then return os.date("%H") -- Hour (24-hour clock, 00-23)
    elseif type == "12h" then return os.date("%I") -- Hour (12-hour clock, 01-12)
    elseif type == "minute" then return os.date("%M") -- Minute (00-59)
    elseif type == "half" then return os.date("%p") -- AM/PM designation
    elseif type == "second" then return os.date("%S") -- Second (00-59)
    elseif type == "full" then return os.date("%X") -- Locale-specific time representation
    elseif type == "iso" then return os.date("%z") -- ISO 8601 offset from UTC
    elseif type == "zone" then return os.date("%Z") -- Time zone name or abbreviation
    else return os.date("%X") -- Default to full time
    end
end

-- Gets parts of the current date (Month)
function library:GetMonth(type)
    type = string.lower(type or "")
    if type == "word" then return os.date("%B") -- Full month name
    elseif type == "short" then return os.date("%b") -- Abbreviated month name
    elseif type == "digit" then return os.date("%m") -- Month as a number (01-12)
    else return os.date("%m") -- Default to month digit
    end
end

-- Gets parts of the current date (Week)
function library:GetWeek(type)
    type = string.lower(type or "")
    if type == "year_s" then return os.date("%U") -- Week number of the year (Sunday as first day, 00-53)
    elseif type == "day" then return os.date("%w") -- Weekday as a number (0-6, Sunday is 0)
    elseif type == "year_m" then return os.date("%W") -- Week number of the year (Monday as first day, 00-53)
    else return os.date("%U") -- Default to week number (Sunday first)
    end
end

-- Gets parts of the current date (Year)
function library:GetYear(type)
    type = string.lower(type or "")
    if type == "digits" then return os.date("%y") -- Year without century (00-99)
    elseif type == "full" then return os.date("%Y") -- Year with century
    else return os.date("%Y") -- Default to full year
    end
end

-- Unlocks FPS cap (Synapse X specific)
function library:UnlockFps(newFps)
    if syn and setfpscap then -- Check if 'syn' and 'setfpscap' exist
        setfpscap(newFps)
    else
        warn("Synapse X specific function 'setfpscap' is not available. UnlockFps function will not work.")
    end
end

-- / UI Systems

-- Apply Theme Function (Point 5)
function library:ApplyTheme(themeName)
    if not self.themes[themeName] then
        warn("Theme '" .. tostring(themeName) .. "' not found.")
        return false
    end
    self.activeTheme = self.themes[themeName]
    print("Applied theme:", themeName)

    -- Update colors of existing core UI elements if they exist
    local theme = self.activeTheme

    if self.mainGui and self.mainFrame then
        self.mainFrame.BackgroundColor3 = theme.mainBg
        if self.headerFrame then
            self.headerFrame.BackgroundColor3 = theme.headerBg
            local title = self.headerFrame:FindFirstChild("title")
            local closeBtn = self.headerFrame:FindFirstChild("closeBtn")
            if title then title.TextColor3 = theme.title end
            if closeBtn then closeBtn.TextColor3 = theme.closeButton end
        end
        if self.tabContainerFrame then
            self.tabContainerFrame.BackgroundColor3 = theme.tabContainerBg
            local tabList = self.tabContainerFrame:FindFirstChild("tabList")
            if tabList then tabList.ScrollBarImageColor3 = theme.scrollbar end
             -- Update existing tab buttons (basic example)
            if tabList then
                for _, button in ipairs(tabList:GetChildren()) do
                    if button:IsA("TextButton") then
                        -- Logic to check if selected or not might be needed here for full update
                         button.BackgroundColor3 = theme.tabButtonNormalBg
                         button.TextColor3 = theme.text
                    end
                end
            end
        end
        if self.contentContainerFrame then
            self.contentContainerFrame.BackgroundColor3 = theme.contentContainerBg
            -- Update existing content frames (basic example)
             for _, content in ipairs(self.contentContainerFrame:GetChildren()) do
                  if content:IsA("ScrollingFrame") then
                       content.ScrollBarImageColor3 = theme.scrollbar
                  end
             end
        end
    end

    -- Update Watermark colors (if exists)
    if self.watermarkScreenGui then
         for _, edge in ipairs(self.watermarkScreenGui:GetChildren()) do
              if edge:IsA("Frame") and edge.Name == "edge" then
                   edge.BackgroundColor3 = theme.wmEdge
                   local bg = edge:FindFirstChild("background")
                   if bg then
                        local gradient = bg:FindFirstChild("backgroundGradient")
                        local bar = bg:FindFirstChild("barFolder"):FindFirstChild("bar")
                        local text = bg:FindFirstChild("waterText")
                        if gradient then gradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, theme.wmGradientStart), ColorSequenceKeypoint.new(1.00, theme.wmGradientEnd)} end
                        if bar then bar.BackgroundColor3 = theme.wmBar end
                        if text then text.TextColor3 = theme.text end
                   end
              end
         end
    end

     -- Update Notification colors (harder to do live, theme affects new ones)
    -- Could add logic here if storing references to active notifications

    print("Core UI elements updated with theme:", themeName)
    return true
end

-- Watermark System (Incorporates Theming and FPS - Point 2)
function library:Watermark(text)
    task.wait() -- Ensure PlayerGui is ready

    -- Constants for Watermark UI
    local WATERMARK_SCREEN_NAME = "SCUI_Watermark"
    local FONT = Enum.Font.Code
    local TEXT_SIZE = 14
    local PADDING = 4
    local EDGE_HEIGHT = 26
    local BAR_HEIGHT = 1
    local CORNER_RADIUS = 2

    -- Clear any existing watermarks
    local existingWatermark = Player.PlayerGui:FindFirstChild(WATERMARK_SCREEN_NAME)
    if existingWatermark then
        existingWatermark:Destroy()
        self.watermarkScreenGui = nil
        self.fpsWatermarkControls = nil
    end

    text = text or "SC v2" -- Default text

    -- Create ScreenGui
    local watermark = Instance.new("ScreenGui")
    watermark.Name = WATERMARK_SCREEN_NAME
    watermark.Parent = Player.PlayerGui
    watermark.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    watermark.DisplayOrder = 999 -- Ensure it's on top
    self.watermarkScreenGui = watermark -- Store reference

    -- Layout for multiple watermark elements
    local watermarkLayout = Instance.new("UIListLayout")
    watermarkLayout.Name = "watermarkLayout"
    watermarkLayout.Parent = watermark
    watermarkLayout.FillDirection = Enum.FillDirection.Horizontal
    watermarkLayout.SortOrder = Enum.SortOrder.LayoutOrder
    watermarkLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
    watermarkLayout.Padding = UDim.new(0, PADDING)

    -- Padding for the entire watermark area
    local watermarkPadding = Instance.new("UIPadding")
    watermarkPadding.Name = "watermarkPadding"
    watermarkPadding.Parent = watermark
    watermarkPadding.PaddingBottom = UDim.new(0, 6)
    watermarkPadding.PaddingLeft = UDim.new(0, 6)

    -- Function to create a single watermark element (reusable)
    local function createWatermarkElement(elementText)
        local theme = library.activeTheme -- Use active theme

        local edge = Instance.new("Frame")
        edge.Name = "edge"
        edge.AnchorPoint = Vector2.new(0, 1) -- Anchor to bottom-left for layout
        edge.BackgroundColor3 = theme.wmEdge
        edge.Size = UDim2.new(0, 0, 0, EDGE_HEIGHT) -- Initial size 0 width
        edge.BackgroundTransparency = 1 -- Start transparent

        local edgeCorner = Instance.new("UICorner")
        edgeCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
        edgeCorner.Name = "edgeCorner"
        edgeCorner.Parent = edge

        local background = Instance.new("Frame")
        background.Name = "background"
        background.Parent = edge
        background.AnchorPoint = Vector2.new(0.5, 0.5)
        background.BackgroundTransparency = 1 -- Start transparent
        background.ClipsDescendants = true
        background.Position = UDim2.new(0.5, 0, 0.5, 0)
        background.Size = UDim2.new(1, -2, 1, -2) -- Fit inside edge with padding

        local barFolder = Instance.new("Folder") -- To manage bar layout if needed
        barFolder.Name = "barFolder"
        barFolder.Parent = background

        local bar = Instance.new("Frame")
        bar.Name = "bar"
        bar.Parent = barFolder
        bar.BackgroundColor3 = theme.wmBar
        bar.BorderSizePixel = 0
        bar.Position = UDim2.new(0, 0, 0, 0) -- Position at top
        bar.Size = UDim2.new(0, 0, 0, BAR_HEIGHT) -- Initial size 0 width

        local barCorner = Instance.new("UICorner")
        barCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
        barCorner.Name = "barCorner"
        barCorner.Parent = bar

        local backgroundGradient = Instance.new("UIGradient")
        backgroundGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, theme.wmGradientStart), ColorSequenceKeypoint.new(1.00, theme.wmGradientEnd)}
        backgroundGradient.Rotation = 90
        backgroundGradient.Name = "backgroundGradient"
        backgroundGradient.Parent = background

        local backgroundCorner = Instance.new("UICorner")
        backgroundCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
        backgroundCorner.Name = "backgroundCorner"
        backgroundCorner.Parent = background

        local waterText = Instance.new("TextLabel")
        waterText.Name = "waterText" -- Changed name for clarity
        waterText.Parent = background
        waterText.BackgroundTransparency = 1.000
        waterText.Position = UDim2.new(0.5, 0, 0.5, 0) -- Center text
        waterText.AnchorPoint = Vector2.new(0.5, 0.5)
        waterText.Size = UDim2.new(1, - (PADDING * 2), 1, - (PADDING * 2)) -- Text area with padding
        waterText.Font = FONT
        waterText.Text = elementText
        waterText.TextColor3 = theme.text
        waterText.TextTransparency = 1 -- Start transparent
        waterText.TextSize = TEXT_SIZE
        waterText.RichText = true
        waterText.TextXAlignment = Enum.TextXAlignment.Center
        waterText.TextYAlignment = Enum.TextYAlignment.Center

        -- Calculate required size based on text
        local textSize = TextService:GetTextSize(waterText.Text, waterText.TextSize, waterText.Font, Vector2.new(math.huge, EDGE_HEIGHT - 2))
        local requiredWidth = textSize.X + (PADDING * 2) + 4 -- Add padding and a bit extra

        return edge, background, bar, waterText, requiredWidth
    end

    -- Create Tweens for animations
    CreateTween("wm_show", 0.24)
    CreateTween("wm_bar", 0.24, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
    CreateTween("wm_text", 0.15)
    CreateTween("wm_resize", 0.08) -- Faster resize tween

    -- Table to hold functions for managing watermarks
    local WatermarkFunctions = {}
    local watermarkElements = {} -- Keep track of elements for removal/theming

    -- Function to add another watermark element
    function WatermarkFunctions:AddWatermark(newText, isDynamic) -- isDynamic flag optional
        newText = newText or "SC v2"

        local newEdge, newBackground, newBar, newWaterText, newRequiredWidth = createWatermarkElement(newText)
        newEdge.Parent = watermark -- Parent to the main ScreenGui
        table.insert(watermarkElements, newEdge) -- Track element

        -- Animate the new watermark appearance (similar to the first one)
        coroutine.wrap(function()
            local sizeTweenEdge = TweenService:Create(newEdge, TweenTable["wm_show"], {Size = UDim2.new(0, newRequiredWidth + 2, 0, EDGE_HEIGHT), BackgroundTransparency = 0})
            local sizeTweenBg = TweenService:Create(newBackground, TweenTable["wm_show"], { BackgroundTransparency = 0 })
            sizeTweenEdge:Play()
            sizeTweenBg:Play()
            sizeTweenEdge.Completed:Wait()

            local barTween = TweenService:Create(newBar, TweenTable["wm_bar"], {Size = UDim2.new(1, 0, 0, BAR_HEIGHT)})
            barTween:Play()
            task.wait(0.1)

            local textTween = TweenService:Create(newWaterText, TweenTable["wm_text"], {TextTransparency = 0})
            textTween:Play()
        end)()

        -- Return functions specific to the newly added watermark
        local NewWatermarkFunctions = {}

        function NewWatermarkFunctions:Hide()
            newEdge.Visible = false
            return NewWatermarkFunctions
        end

        function NewWatermarkFunctions:Show()
            newEdge.Visible = true
            return NewWatermarkFunctions
        end

        function NewWatermarkFunctions:Text(updatedText)
            updatedText = updatedText or newText
             if not newEdge or not newEdge.Parent then return NewWatermarkFunctions end -- Check existence

             -- Only resize if it's not marked as dynamic (like FPS counter) to prevent jitter
             if not isDynamic then
                  local currentText = newWaterText.Text
                  if updatedText ~= currentText then
                      newWaterText.Text = updatedText
                      -- Recalculate size and animate resize
                      local newTextSize = TextService:GetTextSize(newWaterText.Text, newWaterText.TextSize, newWaterText.Font, Vector2.new(math.huge, EDGE_HEIGHT - 2))
                      local newWidth = newTextSize.X + (PADDING * 2) + 4
                      TweenService:Create(newEdge, TweenTable["wm_resize"], {Size = UDim2.new(0, newWidth + 2, 0, EDGE_HEIGHT)}):Play()
                  end
             else
                  newWaterText.Text = updatedText -- Just update text for dynamic elements
             end

            return NewWatermarkFunctions
        end

        function NewWatermarkFunctions:Remove()
             if not newEdge or not newEdge.Parent then return end
             -- Add fade out animation before destroying
             local fadeOutEdge = TweenService:Create(newEdge, TweenTable["wm_show"], {BackgroundTransparency = 1})
             local fadeOutBg = TweenService:Create(newBackground, TweenTable["wm_show"], {BackgroundTransparency = 1})
             local fadeOutText = TweenService:Create(newWaterText, TweenTable["wm_text"], {TextTransparency = 1})
             fadeOutEdge:Play()
             fadeOutBg:Play()
             fadeOutText:Play()
             fadeOutEdge.Completed:Wait()
              -- Remove from tracking table
              for i, el in ipairs(watermarkElements) do
                   if el == newEdge then
                        table.remove(watermarkElements, i)
                        break
                   end
              end
             newEdge:Destroy()
        end

        return NewWatermarkFunctions
    end

     -- Add the initial watermark text
     WatermarkFunctions:AddWatermark(text)
     -- Add the FPS watermark (Point 2)
     self.fpsWatermarkControls = WatermarkFunctions:AddWatermark("FPS: " .. self.fps, true) -- Mark as dynamic


    -- Function to remove the entire watermark system
    function WatermarkFunctions:Remove()
        -- Add fade out animation for all elements
        local tweens = {}
        for _, child in ipairs(watermark:GetChildren()) do
            if child:IsA("Frame") and child.Name == "edge" then
                table.insert(tweens, TweenService:Create(child, TweenTable["wm_show"], {BackgroundTransparency = 1}))
                local bg = child:FindFirstChild("background")
                if bg then
                    table.insert(tweens, TweenService:Create(bg, TweenTable["wm_show"], {BackgroundTransparency = 1}))
                    local wt = bg:FindFirstChild("waterText")
                    if wt then table.insert(tweens, TweenService:Create(wt, TweenTable["wm_text"], {TextTransparency = 1})) end
                end
            end
        end
        for _, t in ipairs(tweens) do t:Play() end
        if #tweens > 0 then
            -- Use task.spawn to wait without yielding the main thread excessively
            task.spawn(function()
                tweens[#tweens].Completed:Wait()
                if watermark and watermark.Parent then
                    watermark:Destroy()
                    library.watermarkScreenGui = nil
                    library.fpsWatermarkControls = nil
                    watermarkElements = {}
                end
            end)
        else
             if watermark and watermark.Parent then
                 watermark:Destroy()
                 library.watermarkScreenGui = nil
                 library.fpsWatermarkControls = nil
                 watermarkElements = {}
             end
        end
        -- No return needed after destruction
    end

    return WatermarkFunctions
end


-- Notification System (Incorporates Theming)
function library:InitNotifications()
    task.wait() -- Ensure PlayerGui is ready

    -- Constants for Notification UI
    local NOTIFICATION_SCREEN_NAME = "SCUI_Notifications"
    local FONT = Enum.Font.Code
    local TEXT_SIZE = 14
    local PADDING = 4
    local EDGE_HEIGHT = 26
    local BAR_HEIGHT = 1
    local CORNER_RADIUS = 2

    -- Clear any existing notification UIs
    local existingNotifications = Player.PlayerGui:FindFirstChild(NOTIFICATION_SCREEN_NAME)
    if existingNotifications then
        existingNotifications:Destroy()
        self.notificationScreenGui = nil
    end

    -- Create ScreenGui for notifications
    local Notifications = Instance.new("ScreenGui")
    Notifications.Name = NOTIFICATION_SCREEN_NAME
    Notifications.Parent = Player.PlayerGui
    Notifications.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Notifications.DisplayOrder = 1000 -- Ensure notifications are on top
    self.notificationScreenGui = Notifications -- Store reference

    -- Layout for multiple notifications
    local notificationsLayout = Instance.new("UIListLayout")
    notificationsLayout.Name = "notificationsLayout"
    notificationsLayout.Parent = Notifications
    notificationsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    notificationsLayout.Padding = UDim.new(0, PADDING)
    notificationsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    notificationsLayout.VerticalAlignment = Enum.VerticalAlignment.Top

    -- Padding for the notification area
    local notificationsPadding = Instance.new("UIPadding")
    notificationsPadding.Name = "notificationsPadding"
    notificationsPadding.Parent = Notifications
    notificationsPadding.PaddingLeft = UDim.new(0, 6)
    notificationsPadding.PaddingTop = UDim.new(0, 18)

    -- Create Tweens for animations
    CreateTween("notification_show", 0.2)
    CreateTween("notification_hide", 0.2)
    CreateTween("notification_bar_fill", 0) -- Duration set dynamically
    CreateTween("notification_resize", 0.1) -- Fast resize

    -- Table to hold the main notification function
    local Notification = {}

    -- Function to display a notification
    function Notification:Notify(text, duration, type, callback)
        text = text or "Please wait..."
        duration = duration or 5
        type = string.lower(type or "notification")
        callback = callback or function() end

        local theme = library.activeTheme -- Use active theme

        -- Notification type colors mapped to theme colors
        local NOTIFICATION_TYPES = {
            notification = theme.notifDefaultBar,
            alert = theme.notifAlertBar,
            error = theme.notifErrorBar,
            success = theme.notifSuccessBar,
            information = theme.notifInfoBar,
        }

        -- Determine bar color based on type
        local barColor = NOTIFICATION_TYPES[type] or theme.notifDefaultBar

        -- Create notification elements (similar structure to watermark)
        local edge = Instance.new("Frame")
        edge.Name = "edge"
        edge.Parent = Notifications -- Parent directly to the ScreenGui
        edge.BackgroundColor3 = theme.wmEdge -- Use watermark edge color
        edge.BackgroundTransparency = 1.000
        edge.Size = UDim2.new(0, 0, 0, EDGE_HEIGHT) -- Start collapsed

        local edgeCorner = Instance.new("UICorner")
        edgeCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
        edgeCorner.Parent = edge

        local background = Instance.new("Frame")
        background.Name = "background"
        background.Parent = edge
        background.AnchorPoint = Vector2.new(0.5, 0.5)
        background.BackgroundTransparency = 1.000
        background.ClipsDescendants = true
        background.Position = UDim2.new(0.5, 0, 0.5, 0)
        background.Size = UDim2.new(1, -2, 1, -2) -- Fit inside edge

        local barFolder = Instance.new("Folder")
        barFolder.Name = "barFolder"
        barFolder.Parent = background

        local bar = Instance.new("Frame")
        bar.Name = "bar"
        bar.Parent = barFolder
        bar.BackgroundColor3 = barColor
        bar.BackgroundTransparency = 0 -- Bar is initially visible but zero width
        bar.BorderSizePixel = 0
        bar.Position = UDim2.new(0, 0, 0, 0) -- Top position
        bar.Size = UDim2.new(0, 0, 0, BAR_HEIGHT) -- Start with zero width

        local barCorner = Instance.new("UICorner")
        barCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
        barCorner.Parent = bar

        local backgroundGradient = Instance.new("UIGradient")
        backgroundGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, theme.wmGradientStart), ColorSequenceKeypoint.new(1.00, theme.wmGradientEnd)} -- Use watermark gradient
        backgroundGradient.Rotation = 90
        backgroundGradient.Parent = background

        local backgroundCorner = Instance.new("UICorner")
        backgroundCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
        backgroundCorner.Parent = background

        local notifText = Instance.new("TextLabel")
        notifText.Name = "notifText"
        notifText.Parent = background
        notifText.BackgroundTransparency = 1.000
        notifText.Position = UDim2.new(0.5, 0, 0.5, 0)
        notifText.AnchorPoint = Vector2.new(0.5, 0.5)
        notifText.Size = UDim2.new(1, -(PADDING * 2), 1, -(PADDING * 2)) -- Text area with padding
        notifText.Font = FONT
        notifText.Text = text
        notifText.TextColor3 = theme.text -- Use standard text color
        notifText.TextSize = TEXT_SIZE
        notifText.TextTransparency = 1.000 -- Start transparent
        notifText.TextXAlignment = Enum.TextXAlignment.Left -- Align text left
        notifText.TextYAlignment = Enum.TextYAlignment.Center
        notifText.RichText = true

        -- Calculate required size
        local textSize = TextService:GetTextSize(notifText.Text, notifText.TextSize, notifText.Font, Vector2.new(300, math.huge)) -- Max width 300
        local requiredWidth = math.max(150, textSize.X + (PADDING * 2) + 4) -- Minimum width 150

        -- Create dynamic tween for the duration bar
        TweenTable["notification_bar_fill"] = TweenInfo.new(duration, Enum.EasingStyle.Linear) -- Use linear for time bar

        local isRunning = false -- Flag to manage state during animations
        local barTween -- Variable to hold the bar tween instance

        -- Coroutine for the notification lifecycle
        coroutine.wrap(function()
            isRunning = true

            -- Animate In
            local sizeTweenEdge = TweenService:Create(edge, TweenTable["notification_show"], {Size = UDim2.new(0, requiredWidth + 2, 0, EDGE_HEIGHT), BackgroundTransparency = 0})
            local bgTween = TweenService:Create(background, TweenTable["notification_show"], {BackgroundTransparency = 0})
            local textTween = TweenService:Create(notifText, TweenTable["notification_show"], {TextTransparency = 0})

            sizeTweenEdge:Play()
            bgTween:Play()
            textTween:Play()

            -- Wait for the longest animation (size) to complete before starting the bar
            sizeTweenEdge.Completed:Wait()

            -- Start the duration bar animation only if edge still exists
            if edge and edge.Parent then
                 barTween = TweenService:Create(bar, TweenTable["notification_bar_fill"], {Size = UDim2.new(1, 0, 0, BAR_HEIGHT)})
                 barTween:Play()
                 barTween.Completed:Wait() -- Wait for the duration to elapse
            end


            -- Check again if edge exists before animating out
            if not edge or not edge.Parent then return end
            isRunning = false

            -- Animate Out
            local hideSizeTween = TweenService:Create(edge, TweenTable["notification_hide"], {Size = UDim2.new(0, 0, 0, EDGE_HEIGHT), BackgroundTransparency = 1})
            local hideBgTween = TweenService:Create(background, TweenTable["notification_hide"], {BackgroundTransparency = 1})
            local hideTextTween = TweenService:Create(notifText, TweenTable["notification_hide"], {TextTransparency = 1})
            local hideBarTween = TweenService:Create(bar, TweenTable["notification_hide"], {BackgroundTransparency = 1}) -- Fade bar too

            hideSizeTween:Play()
            hideBgTween:Play()
            hideTextTween:Play()
            hideBarTween:Play()

            hideSizeTween.Completed:Wait()
            if edge and edge.Parent then edge:Destroy() end -- Clean up the notification

            -- Execute callback after notification is gone
            pcall(callback)
        end)()

        -- Return functions to control this specific notification instance
        local NotificationFunctions = {}

        -- Function to update the text of an active notification
        function NotificationFunctions:Text(newText)
            if not edge or not edge.Parent then return NotificationFunctions end -- Check if notification still exists

            newText = newText or text
            notifText.Text = newText

            -- Recalculate size and resize smoothly
            local newTextSize = TextService:GetTextSize(notifText.Text, notifText.TextSize, notifText.Font, Vector2.new(300, math.huge))
            local newRequiredWidth = math.max(150, newTextSize.X + (PADDING * 2) + 4)

            TweenService:Create(edge, TweenTable["notification_resize"], {Size = UDim2.new(0, newRequiredWidth + 2, 0, EDGE_HEIGHT)}):Play()

            return NotificationFunctions -- Allow chaining
        end

         -- Function to immediately dismiss the notification
        function NotificationFunctions:Dismiss()
            if not edge or not edge.Parent then return end -- Check if notification still exists
            if barTween and barTween.PlaybackState == Enum.PlaybackState.Playing then
                barTween:Cancel() -- Stop the timer bar
            end
            isRunning = false -- Prevent animation out if already dismissed

            -- Animate Out immediately
            local hideSizeTween = TweenService:Create(edge, TweenTable["notification_hide"], {Size = UDim2.new(0, 0, 0, EDGE_HEIGHT), BackgroundTransparency = 1})
            local hideBgTween = TweenService:Create(background, TweenTable["notification_hide"], {BackgroundTransparency = 1})
            local hideTextTween = TweenService:Create(notifText, TweenTable["notification_hide"], {TextTransparency = 1})
            local hideBarTween = TweenService:Create(bar, TweenTable["notification_hide"], {BackgroundTransparency = 1})

            hideSizeTween:Play()
            hideBgTween:Play()
            hideTextTween:Play()
            hideBarTween:Play()

            -- Use task.spawn to wait for completion without blocking
            task.spawn(function()
                 hideSizeTween.Completed:Wait()
                 if edge and edge.Parent then edge:Destroy() end
            end)
            -- Callback is typically NOT called on manual dismiss, unless specified.
        end


        return NotificationFunctions
    end

    return Notification -- Return the main Notify function
end


-- Key Prompt System (Incorporates Theming)
function library:KeyPrompt()
    task.wait() -- Ensure PlayerGui is ready

    -- Constants
    local KEYPROMPT_SCREEN_NAME = "SCUI_KeyPromptScreen"
    local FONT = Enum.Font.Code

    local theme = library.activeTheme -- Use active theme

    -- Clear existing UI
    local existingPrompt = Player.PlayerGui:FindFirstChild(KEYPROMPT_SCREEN_NAME)
    if existingPrompt then
        existingPrompt:Destroy()
    end

    -- Create ScreenGui
    local keyPrompt = Instance.new("ScreenGui")
    keyPrompt.Name = KEYPROMPT_SCREEN_NAME
    keyPrompt.Parent = Player.PlayerGui
    keyPrompt.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    keyPrompt.DisplayOrder = 1001 -- Ensure it's above notifications/watermarks

    -- Blur Background (Optional but nice effect)
    local blur = Instance.new("BlurEffect")
    blur.Size = 8
    blur.Parent = Lighting -- Parent to Lighting

    -- Main Frame
    local main = Instance.new("Frame")
    main.Name = "main"
    main.BackgroundColor3 = theme.keyPromptBg
    main.BorderSizePixel = 0
    main.Position = UDim2.new(0.5, 0, -0.5, 0) -- Start off-screen top
    main.AnchorPoint = Vector2.new(0.5, 0.5)
    main.Size = UDim2.new(0, 320, 0, 160) -- Slightly larger
    main.Parent = keyPrompt

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6) -- Slightly rounder
    corner.Parent = main

    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Parent = main
    title.BackgroundTransparency = 1
    title.Position = UDim2.new(0.5, 0, 0, 20) -- Centered positioning
    title.AnchorPoint = Vector2.new(0.5, 0)
    title.Size = UDim2.new(0.9, 0, 0, 25)
    title.Font = FONT
    title.Text = "SC UI Library - Key System"
    title.TextColor3 = theme.title -- Use theme title color
    title.TextSize = 18
    title.TextXAlignment = Enum.TextXAlignment.Center

    -- TextBox for Key Input
    local textBox = Instance.new("TextBox")
    textBox.Name = "KeyInput"
    textBox.Parent = main
    textBox.BackgroundColor3 = theme.keyPromptTextboxBg
    textBox.BorderSizePixel = 0
    textBox.Position = UDim2.new(0.5, 0, 0.5, -15) -- Positioned below title
    textBox.AnchorPoint = Vector2.new(0.5, 0.5)
    textBox.Size = UDim2.new(0.85, 0, 0, 35) -- Wider and taller
    textBox.Font = FONT
    textBox.PlaceholderText = "Enter key..."
    textBox.PlaceholderColor3 = theme.textDark -- Use theme placeholder color
    textBox.Text = ""
    textBox.TextColor3 = theme.textLight -- Use theme text color
    textBox.TextSize = 15
    textBox.ClearTextOnFocus = false
    textBox.TextXAlignment = Enum.TextXAlignment.Left -- Ensure left alignment
    textBox.TextYAlignment = Enum.TextYAlignment.Center

    local textBoxPadding = Instance.new("UIPadding")
    textBoxPadding.PaddingLeft = UDim.new(0, 10) -- Increased padding
    textBoxPadding.PaddingRight = UDim.new(0, 10)
    textBoxPadding.Parent = textBox

    local textBoxCorner = Instance.new("UICorner")
    textBoxCorner.CornerRadius = UDim.new(0, 4)
    textBoxCorner.Parent = textBox

    -- Submit Button
    local submitButton = Instance.new("TextButton")
    submitButton.Name = "SubmitButton"
    submitButton.Parent = main
    submitButton.BackgroundColor3 = theme.keyPromptButtonBg
    submitButton.BorderSizePixel = 0
    submitButton.Position = UDim2.new(0.5, 0, 0.8, 0) -- Positioned at the bottom
    submitButton.AnchorPoint = Vector2.new(0.5, 0.5)
    submitButton.Size = UDim2.new(0.5, 0, 0, 35) -- Wider
    submitButton.Font = FONT
    submitButton.Text = "Submit"
    submitButton.TextColor3 = theme.textButton -- Use theme button text color
    submitButton.TextSize = 16

    local submitCorner = Instance.new("UICorner")
    submitCorner.CornerRadius = UDim.new(0, 4)
    submitCorner.Parent = submitButton

    -- Promise-like mechanism using BindableEvent
    local resultPromise = Instance.new("BindableEvent")

    -- Animate prompt appearing
    CreateTween("prompt_in", 0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
    TweenService:Create(main, TweenTable["prompt_in"], {Position = UDim2.new(0.5, 0, 0.5, 0)}):Play()

    -- Shake animation function
    local function shakeElement(element)
        local originalPos = element.Position
        local shakeTweenInfo = TweenInfo.new(0.05)
        for _ = 1, 3 do
            TweenService:Create(element, shakeTweenInfo, {Position = originalPos + UDim2.new(0, 8, 0, 0)}):Play()
            task.wait(0.05)
            TweenService:Create(element, shakeTweenInfo, {Position = originalPos - UDim2.new(0, 8, 0, 0)}):Play()
            task.wait(0.05)
        end
        TweenService:Create(element, shakeTweenInfo, {Position = originalPos}):Play() -- Return to original position
    end

    -- Submit logic
    local handleSubmit
    local connectionSubmit, connectionFocusLost
    handleSubmit = function()
        local enteredKey = textBox.Text
        if enteredKey == CorrectKey then
            KeyEntered = true
            -- Disconnect listeners before animating out
            if connectionSubmit then connectionSubmit:Disconnect() end
            if connectionFocusLost then connectionFocusLost:Disconnect() end
            -- Animate out
            CreateTween("prompt_out", 0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)
            local outTween = TweenService:Create(main, TweenTable["prompt_out"], {Position = UDim2.new(0.5, 0, 1.5, 0)}) -- Animate off-screen bottom
            outTween:Play()
            outTween.Completed:Connect(function()
                 if keyPrompt and keyPrompt.Parent then keyPrompt:Destroy() end
                 if blur and blur.Parent then blur:Destroy() end -- Remove blur effect
                resultPromise:Fire(true) -- Signal success
            end)
        else
            -- Incorrect key
            shakeElement(main) -- Shake the prompt
            textBox.Text = ""
            textBox.PlaceholderText = "Incorrect key!"
            textBox.PlaceholderColor3 = theme.error -- Use theme error color
            -- Reset placeholder after a delay
            task.delay(1.5, function()
                if textBox and textBox.Parent then -- Check if textbox still exists
                    textBox.PlaceholderText = "Enter key..."
                    textBox.PlaceholderColor3 = theme.textDark -- Use theme placeholder color
                end
            end)
        end
    end

    connectionSubmit = submitButton.MouseButton1Click:Connect(handleSubmit)
    connectionFocusLost = textBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            handleSubmit()
        end
    end)

    -- Return the event that will fire when the correct key is entered
    return resultPromise.Event
end

-- Internal function to create the keybind prompt (Point 1 - Keybind Rework)
function library:_CreateKeybindPrompt(callback)
    local theme = library.activeTheme
    local FONT = Enum.Font.Code

    -- Check if a prompt already exists
    local existingPrompt = Player.PlayerGui:FindFirstChild("SCUI_KeybindModalPrompt")
    if existingPrompt then existingPrompt:Destroy() end

    local promptScreen = Instance.new("ScreenGui")
    promptScreen.Name = "SCUI_KeybindModalPrompt"
    promptScreen.Parent = Player.PlayerGui
    promptScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    promptScreen.DisplayOrder = 1005 -- Above main UI

    -- Backdrop (to catch clicks and provide focus)
    local backdrop = Instance.new("Frame")
    backdrop.Name = "Backdrop"
    backdrop.Parent = promptScreen
    backdrop.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    backdrop.BackgroundTransparency = 0.7
    backdrop.Size = UDim2.new(1, 0, 1, 0)
    backdrop.Position = UDim2.new(0, 0, 0, 0)
    backdrop.ZIndex = 1

    -- Main Prompt Frame
    local promptFrame = Instance.new("Frame")
    promptFrame.Name = "PromptFrame"
    promptFrame.Parent = promptScreen
    promptFrame.BackgroundColor3 = theme.elementBg -- Use element background
    promptFrame.BorderSizePixel = 1
    promptFrame.BorderColor3 = theme.elementOutline
    promptFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    promptFrame.Position = UDim2.new(0.5, 0, 0.45, 0) -- Slightly above center
    promptFrame.Size = UDim2.new(0, 280, 0, 120)
    promptFrame.ZIndex = 2

    local promptCorner = Instance.new("UICorner")
    promptCorner.CornerRadius = UDim.new(0, 5)
    promptCorner.Parent = promptFrame

    -- Instruction Label
    local instructionLabel = Instance.new("TextLabel")
    instructionLabel.Name = "InstructionLabel"
    instructionLabel.Parent = promptFrame
    instructionLabel.BackgroundTransparency = 1
    instructionLabel.Size = UDim2.new(0.9, 0, 0, 40)
    instructionLabel.Position = UDim2.new(0.5, 0, 0.3, 0)
    instructionLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    instructionLabel.Font = FONT
    instructionLabel.Text = "Press any key to bind...\n(ESC to Cancel, DEL to Clear)"
    instructionLabel.TextColor3 = theme.textLight
    instructionLabel.TextSize = 15
    instructionLabel.TextWrapped = true
    instructionLabel.TextXAlignment = Enum.TextXAlignment.Center
    instructionLabel.TextYAlignment = Enum.TextYAlignment.Center

    -- Button Container
    local buttonContainer = Instance.new("Frame")
    buttonContainer.Name = "ButtonContainer"
    buttonContainer.Parent = promptFrame
    buttonContainer.BackgroundTransparency = 1
    buttonContainer.Size = UDim2.new(0.9, 0, 0, 35)
    buttonContainer.Position = UDim2.new(0.5, 0, 0.8, 0)
    buttonContainer.AnchorPoint = Vector2.new(0.5, 0.5)

    local buttonLayout = Instance.new("UIListLayout")
    buttonLayout.Parent = buttonContainer
    buttonLayout.FillDirection = Enum.FillDirection.Horizontal
    buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    buttonLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    buttonLayout.SortOrder = Enum.SortOrder.LayoutOrder
    buttonLayout.Padding = UDim.new(0, 10)

    -- Clear Button
    local clearButton = Instance.new("TextButton")
    clearButton.Name = "ClearButton"
    clearButton.Parent = buttonContainer
    clearButton.BackgroundColor3 = theme.elementBgLight
    clearButton.BorderSizePixel = 1
    clearButton.BorderColor3 = theme.elementOutline
    clearButton.Size = UDim2.new(0.4, 0, 1, 0)
    clearButton.Font = FONT
    clearButton.Text = "Clear Bind"
    clearButton.TextColor3 = theme.text
    clearButton.TextSize = 14
    clearButton.AutoButtonColor = false
    clearButton.LayoutOrder = 1

    local clearCorner = Instance.new("UICorner")
    clearCorner.CornerRadius = UDim.new(0, 4)
    clearCorner.Parent = clearButton

    -- Cancel Button
    local cancelButton = Instance.new("TextButton")
    cancelButton.Name = "CancelButton"
    cancelButton.Parent = buttonContainer
    cancelButton.BackgroundColor3 = theme.elementBgLight
    cancelButton.BorderSizePixel = 1
    cancelButton.BorderColor3 = theme.elementOutline
    cancelButton.Size = UDim2.new(0.4, 0, 1, 0)
    cancelButton.Font = FONT
    cancelButton.Text = "Cancel"
    cancelButton.TextColor3 = theme.text
    cancelButton.TextSize = 14
    cancelButton.AutoButtonColor = false
    cancelButton.LayoutOrder = 2

    local cancelCorner = Instance.new("UICorner")
    cancelCorner.CornerRadius = UDim.new(0, 4)
    cancelCorner.Parent = cancelButton


    -- Button Hover Effects
    local btnHoverColor = theme.elementHover
    local btnOriginalColor = theme.elementBgLight
    local btnTweenInfo = TweenInfo.new(0.1)

    local function setupHover(button)
        button.MouseEnter:Connect(function() TweenService:Create(button, btnTweenInfo, {BackgroundColor3 = btnHoverColor}):Play() end)
        button.MouseLeave:Connect(function() TweenService:Create(button, btnTweenInfo, {BackgroundColor3 = btnOriginalColor}):Play() end)
    end
    setupHover(clearButton)
    setupHover(cancelButton)

    -- Animate In
    promptFrame.Position = UDim2.new(0.5, 0, 0.35, 0)
    promptFrame.Size = UDim2.new(0, 0, 0, 0)
    TweenService:Create(promptFrame, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Position = UDim2.new(0.5, 0, 0.45, 0),
        Size = UDim2.new(0, 280, 0, 120)
    }):Play()

    -- Input Handling
    local connection = nil
    local function cleanup(resultKey)
        if connection then connection:Disconnect() end
        if promptScreen and promptScreen.Parent then
            -- Animate Out
            TweenService:Create(promptFrame, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
                Position = UDim2.new(0.5, 0, 0.55, 0),
                Size = UDim2.new(0, 280, 0, 0)
            }):Play()
             TweenService:Create(backdrop, TweenInfo.new(0.2), { BackgroundTransparency = 1 }):Play()
            task.wait(0.2)
            if promptScreen and promptScreen.Parent then promptScreen:Destroy() end
        end
        pcall(callback, resultKey) -- Callback with nil for cancel/clear, KeyCode for success
    end

    -- Global Input Listener
    connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed then
            if input.UserInputType == Enum.UserInputType.Keyboard then
                if input.KeyCode == Enum.KeyCode.Escape then
                    cleanup(nil) -- Cancel
                elseif input.KeyCode == Enum.KeyCode.Delete or input.KeyCode == Enum.KeyCode.Backspace then -- Use Delete/Backspace for Clear
                     cleanup("None") -- Special value for clear
                elseif input.KeyCode ~= Enum.KeyCode.Unknown and
                       input.KeyCode ~= Enum.KeyCode.LeftShift and input.KeyCode ~= Enum.KeyCode.RightShift and
                       input.KeyCode ~= Enum.KeyCode.LeftControl and input.KeyCode ~= Enum.KeyCode.RightControl and
                       input.KeyCode ~= Enum.KeyCode.LeftAlt and input.KeyCode ~= Enum.KeyCode.RightAlt and
                       input.KeyCode ~= Enum.KeyCode.LeftSuper and input.KeyCode ~= Enum.KeyCode.RightSuper and
                       input.KeyCode ~= Enum.KeyCode.CapsLock and input.KeyCode ~= Enum.KeyCode.Menu then
                    cleanup(input.KeyCode) -- Success
                end
            elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
                 if input.SourceUserInput == clearButton or (input.GuiObject and input.GuiObject:IsDescendantOf(clearButton)) then
                      cleanup("None") -- Clear
                 elseif input.SourceUserInput == cancelButton or (input.GuiObject and input.GuiObject:IsDescendantOf(cancelButton)) then
                      cleanup(nil) -- Cancel
                 elseif input.SourceUserInput == backdrop then
                      cleanup(nil) -- Cancel if clicking backdrop
                 end
            end
        end
    end)

    -- Also handle button clicks directly for robustness
    clearButton.MouseButton1Click:Connect(function() cleanup("None") end)
    cancelButton.MouseButton1Click:Connect(function() cleanup(nil) end)
    backdrop.MouseButton1Click:Connect(function() cleanup(nil) end)

end


-- Main UI Initialization (Window - Incorporates Theming)
function library:Init(key)
    -- Set keybind or use provided key
    self.keybind = key or Enum.KeyCode.RightAlt -- Point 3: Default confirmed

    -- Use active theme
    local theme = self.activeTheme
    if not theme then
         warn("No active theme set. Falling back to default.")
         self.activeTheme = self.themes.Default
         theme = self.activeTheme
    end

    -- Check if key is already entered (allows bypassing the key check for development/if already done)
    if not KeyEntered then
        -- Wait for correct key to be entered using the prompt
        local keySuccessConnection
        local success = false
        keySuccessConnection = self:KeyPrompt():Connect(function(result)
             success = result
             if keySuccessConnection then keySuccessConnection:Disconnect() end -- Disconnect self
         end)
        -- Wait until the promise resolves (key entered correctly)
        repeat task.wait() until success == true

        if not success then
            warn("Key prompt failed or was bypassed incorrectly.")
            return nil -- Stop initialization if key is wrong
        end
    end

    -- Constants for Main UI
    local MAIN_SCREEN_NAME = "SCUI_Main"
    local FONT = Enum.Font.Code
    local CORNER_RADIUS = 5
    local PADDING = 5

    -- Clear existing main UI if present
    local existingUI = Player.PlayerGui:FindFirstChild(MAIN_SCREEN_NAME)
    if existingUI then
        existingUI:Destroy()
        self.mainGui = nil
        self.mainFrame = nil
        self.headerFrame = nil
        self.tabContainerFrame = nil
        self.contentContainerFrame = nil
    end

    -- Create main ScreenGui
    local SCUI = Instance.new("ScreenGui")
    SCUI.Name = MAIN_SCREEN_NAME
    SCUI.Parent = Player.PlayerGui
    SCUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    SCUI.DisplayOrder = 100 -- Lower than notifications/key prompt
    SCUI.Enabled = true -- Start enabled
    self.mainGui = SCUI -- Store reference

    -- Main Window Frame
    local main = Instance.new("Frame")
    main.Name = "main"
    main.Parent = SCUI
    main.BackgroundColor3 = theme.mainBg
    main.BorderSizePixel = 0
    main.AnchorPoint = Vector2.new(0.5, 0.5)
    main.Position = UDim2.new(0.5, 0, 0.5, 0) -- Center the window
    main.Size = UDim2.new(0, 550, 0, 350) -- Slightly larger default size
    main.ClipsDescendants = true -- Clip content within main frame bounds
    self.mainFrame = main -- Store reference

    local mainCorner = Instance.new("UICorner")
    mainCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
    mainCorner.Parent = main

    -- Header Frame
    local header = Instance.new("Frame")
    header.Name = "header"
    header.Parent = main
    header.BackgroundColor3 = theme.headerBg
    header.BorderSizePixel = 0
    header.Size = UDim2.new(1, 0, 0, 35) -- Taller header
    header.Position = UDim2.new(0, 0, 0, 0)
    header.ZIndex = 2 -- Ensure header is above other content in main
    self.headerFrame = header -- Store reference

    -- Apply corner radius only to top corners of header
    local headerCorner = Instance.new("UICorner")
    headerCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
    headerCorner.Parent = header -- Apply to header itself

    -- Header Title
    local headerTitle = Instance.new("TextLabel")
    headerTitle.Name = "title"
    headerTitle.Parent = header
    headerTitle.BackgroundTransparency = 1
    headerTitle.Position = UDim2.new(0, 15, 0.5, 0) -- Indent left, center vertically
    headerTitle.AnchorPoint = Vector2.new(0, 0.5)
    headerTitle.Size = UDim2.new(0.7, 0, 1, 0) -- Take up most width
    headerTitle.Font = FONT
    headerTitle.Text = self.title -- Use library title
    headerTitle.TextColor3 = theme.title
    headerTitle.TextSize = 16 -- Larger title
    headerTitle.TextXAlignment = Enum.TextXAlignment.Left
    headerTitle.TextYAlignment = Enum.TextYAlignment.Center

    -- Close Button
    local closeBtn = Instance.new("TextButton")
    closeBtn.Name = "closeBtn"
    closeBtn.Parent = header
    closeBtn.BackgroundTransparency = 1
    closeBtn.AnchorPoint = Vector2.new(1, 0.5)
    closeBtn.Position = UDim2.new(1, -10, 0.5, 0) -- Position top right
    closeBtn.Size = UDim2.new(0, 20, 0, 20) -- Square size
    closeBtn.Font = FONT
    closeBtn.Text = "X"
    closeBtn.TextColor3 = theme.closeButton
    closeBtn.TextSize = 18
    closeBtn.AutoButtonColor = false -- Disable default button color changes

    -- Close button interactions
    closeBtn.MouseEnter:Connect(function()
        TweenService:Create(closeBtn, TweenInfo.new(0.1), {TextColor3 = theme.closeButtonHover}):Play()
    end)
    closeBtn.MouseLeave:Connect(function()
        TweenService:Create(closeBtn, TweenInfo.new(0.1), {TextColor3 = theme.closeButton}):Play()
    end)
    closeBtn.MouseButton1Click:Connect(function()
        SCUI.Enabled = not SCUI.Enabled -- Toggle visibility
    end)

    -- Tab Container (Left Panel)
    local tabContainer = Instance.new("Frame")
    tabContainer.Name = "tabContainer"
    tabContainer.Parent = main
    tabContainer.BackgroundColor3 = theme.tabContainerBg
    tabContainer.BorderSizePixel = 0
    tabContainer.Position = UDim2.new(0, PADDING, 0, 35 + PADDING) -- Below header, padded
    tabContainer.Size = UDim2.new(0, 130, 1, -(35 + PADDING * 2)) -- Padded size
    tabContainer.ClipsDescendants = true
    tabContainer.ZIndex = 1
    self.tabContainerFrame = tabContainer -- Store reference

    local tabContainerCorner = Instance.new("UICorner")
    tabContainerCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
    tabContainerCorner.Parent = tabContainer

    -- Scrolling Frame for Tabs
    local tabList = Instance.new("ScrollingFrame")
    tabList.Name = "tabList"
    tabList.Parent = tabContainer
    tabList.Active = true
    tabList.BackgroundTransparency = 1
    tabList.BorderSizePixel = 0
    tabList.Position = UDim2.new(0, 0, 0, PADDING) -- Padding inside container
    tabList.Size = UDim2.new(1, 0, 1, -PADDING * 2) -- Fill container with padding
    tabList.ScrollBarThickness = 4
    tabList.ScrollBarImageColor3 = theme.scrollbar
    tabList.CanvasSize = UDim2.new(0, 0, 0, 0) -- Start with 0 canvas size
    tabList.ScrollingDirection = Enum.ScrollingDirection.Y -- Vertical scrolling only

    local tabListLayout = Instance.new("UIListLayout")
    tabListLayout.Parent = tabList
    tabListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    tabListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    tabListLayout.Padding = UDim.new(0, PADDING)
    tabListLayout.FillDirection = Enum.FillDirection.Vertical

    -- Content Container (Right Panel)
    local contentContainer = Instance.new("Frame")
    contentContainer.Name = "contentContainer"
    contentContainer.Parent = main
    contentContainer.BackgroundColor3 = theme.contentContainerBg
    contentContainer.BorderSizePixel = 0
    contentContainer.Position = UDim2.new(0, 130 + PADDING * 2, 0, 35 + PADDING) -- Right of tab container, padded
    contentContainer.Size = UDim2.new(1, -(130 + PADDING * 3), 1, -(35 + PADDING * 2)) -- Fill remaining space, padded
    contentContainer.ClipsDescendants = true
    contentContainer.ZIndex = 1
    self.contentContainerFrame = contentContainer -- Store reference

    local contentContainerCorner = Instance.new("UICorner")
    contentContainerCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
    contentContainerCorner.Parent = contentContainer

    -- Enable dragging of the main window (using the main frame as the target)
    -- Dragging initiated by the header, but moves the 'main' frame.
    drag(header, main, 0.08) -- Pass header to initiate, main to move

    -- Enable keybind to toggle UI visibility
    -- Disconnect previous listener if exists
    if self.activeKeybindConnection then
        self.activeKeybindConnection:Disconnect()
        self.activeKeybindConnection = nil
    end
    self.activeKeybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        -- Check if input is not processed by game (e.g., typing in chat) and matches the keybind
        if not gameProcessed and input.KeyCode == self.keybind then
            -- Check if a TextBox is focused, if so, don't toggle UI
             local focused = UserInputService:GetFocusedTextBox()
             -- Also check if our custom keybind prompt is visible
             local keybindPromptVisible = Player.PlayerGui:FindFirstChild("SCUI_KeybindModalPrompt")
            if not focused and not keybindPromptVisible then
                 SCUI.Enabled = not SCUI.Enabled
            end
        end
    end)

    -- Table to hold Window functions (like NewTab)
    local Window = {}
    local activeTabButton = nil -- Track the currently selected tab button
    local activeTabContent = nil -- Track the currently visible content frame
    local tabs = {} -- Store tab data

    -- Function to create a new Tab
    function Window:NewTab(name)
        name = name or "Tab"
        local safeName = name:gsub("%W", "") -- Make name safe for instance names

         -- Check if tab already exists
         if tabs[name] then
              warn("Tab with name '"..name.."' already exists.")
              return tabs[name].Tab -- Return existing tab object
         end

        local theme = library.activeTheme -- Use active theme for elements

        -- Create Tab Button
        local tabButton = Instance.new("TextButton")
        tabButton.Name = "tab_" .. safeName
        tabButton.Parent = tabList
        tabButton.BackgroundColor3 = theme.tabButtonNormalBg
        tabButton.BorderSizePixel = 0
        tabButton.Size = UDim2.new(1, -PADDING * 2, 0, 30) -- Full width minus padding, fixed height
        tabButton.Font = FONT
        tabButton.Text = name
        tabButton.TextColor3 = theme.text -- Use standard text color
        tabButton.TextSize = 14
        tabButton.AutoButtonColor = false

        local tabButtonCorner = Instance.new("UICorner")
        tabButtonCorner.CornerRadius = UDim.new(0, 4)
        tabButtonCorner.Parent = tabButton

        -- Update canvas size for the tab list scrolling frame
        tabList.CanvasSize = UDim2.new(0, 0, 0, tabListLayout.AbsoluteContentSize.Y + PADDING)

        -- Create Tab Content Frame (Scrolling)
        local tabContent = Instance.new("ScrollingFrame")
        tabContent.Name = "content_" .. safeName
        tabContent.Parent = contentContainer
        tabContent.Active = true
        tabContent.BackgroundTransparency = 1
        tabContent.BorderSizePixel = 0
        tabContent.ClipsDescendants = true
        tabContent.Size = UDim2.new(1, 0, 1, 0) -- Fill content container
        tabContent.ScrollBarThickness = 4
        tabContent.Visible = false -- Start hidden
        tabContent.CanvasSize = UDim2.new(0, 0, 0, 0) -- Start with 0 canvas size
        tabContent.ScrollBarImageColor3 = theme.scrollbar
        tabContent.ScrollingDirection = Enum.ScrollingDirection.Y

        local tabContentLayout = Instance.new("UIListLayout")
        tabContentLayout.Parent = tabContent
        tabContentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center -- Center elements horizontally
        tabContentLayout.SortOrder = Enum.SortOrder.LayoutOrder
        tabContentLayout.Padding = UDim.new(0, PADDING)
        tabContentLayout.FillDirection = Enum.FillDirection.Vertical

        local tabContentPadding = Instance.new("UIPadding")
        tabContentPadding.Parent = tabContent
        tabContentPadding.PaddingTop = UDim.new(0, PADDING * 2) -- More padding at top/bottom
        tabContentPadding.PaddingBottom = UDim.new(0, PADDING * 2)
        tabContentPadding.PaddingLeft = UDim.new(0, PADDING)
        tabContentPadding.PaddingRight = UDim.new(0, PADDING)

        -- Auto-update canvas size for content scrolling frame
        local contentSizeConnection = tabContentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
             -- Check if tabContent still exists before updating
             if tabContent and tabContent.Parent then
                  tabContent.CanvasSize = UDim2.new(0, 0, 0, tabContentLayout.AbsoluteContentSize.Y + PADDING * 4) -- Add padding to canvas size
             else
                  if contentSizeConnection then contentSizeConnection:Disconnect() end -- Disconnect if parent is gone
             end
        end)
         -- Cleanup connection on destroy
        tabContent.Destroying:Connect(function()
             if contentSizeConnection then contentSizeConnection:Disconnect() end
        end)


        -- Tab button click handler
        tabButton.MouseButton1Click:Connect(function()
            -- Deselect previous tab
            if activeTabButton and activeTabButton.Parent then -- Check parent existence
                 TweenService:Create(activeTabButton, TweenInfo.new(0.15), {
                      BackgroundColor3 = theme.tabButtonNormalBg,
                      TextColor3 = theme.text
                 }):Play()
            end
             if activeTabContent and activeTabContent.Parent then
                  activeTabContent.Visible = false
             end

            -- Select this tab
            TweenService:Create(tabButton, TweenInfo.new(0.15), {
                BackgroundColor3 = theme.tabButtonSelectedBg,
                TextColor3 = theme.tabButtonSelectedText -- Use selected text color from theme
            }):Play()
            tabContent.Visible = true

            -- Update active tab tracking
            activeTabButton = tabButton
            activeTabContent = tabContent
        end)

        -- If this is the first tab added, select it by default
        if not activeTabButton then
            tabButton.BackgroundColor3 = theme.tabButtonSelectedBg
            tabButton.TextColor3 = theme.tabButtonSelectedText
            tabContent.Visible = true
            activeTabButton = tabButton
            activeTabContent = tabContent
        end

        -- Table to hold functions for adding elements to this Tab
        local Tab = {}
        local elementUpdateFunctions = {} -- Store update functions for elements like sliders
        tabs[name] = { Tab = Tab, Button = tabButton, Content = tabContent } -- Store tab info


        -- Helper function to create a standard element frame
        local function createElementFrame(height)
            local frame = Instance.new("Frame")
            frame.Parent = tabContent
            frame.BackgroundTransparency = 1
            frame.Size = UDim2.new(1, -(PADDING * 2), 0, height) -- Full width minus padding
            return frame
        end

        -- Label Element
        function Tab:NewLabel(text, alignment)
            text = text or "Label"
            alignment = string.lower(alignment or "left")
            local theme = library.activeTheme

            local labelFrame = createElementFrame(25) -- Standard height for a label row
            labelFrame.Name = "labelFrame"

            local label = Instance.new("TextLabel")
            label.Name = "label"
            label.Parent = labelFrame
            label.BackgroundTransparency = 1
            label.Size = UDim2.new(1, 0, 1, 0) -- Fill frame
            label.Font = FONT
            label.Text = text
            label.TextColor3 = theme.text -- Use consistent text color
            label.TextSize = 14
            label.TextYAlignment = Enum.TextYAlignment.Center

            if alignment == "left" then
                label.TextXAlignment = Enum.TextXAlignment.Left
            elseif alignment == "right" then
                label.TextXAlignment = Enum.TextXAlignment.Right
            elseif alignment == "center" then
                label.TextXAlignment = Enum.TextXAlignment.Center
            else
                label.TextXAlignment = Enum.TextXAlignment.Left -- Default
            end

            local LabelFunctions = {}
            function LabelFunctions:SetText(newText)
                label.Text = newText or ""
                return LabelFunctions
            end
            return LabelFunctions -- Return control object
        end

        -- Section Separator Element
        function Tab:NewSection(text)
            text = text or "Section"
            local theme = library.activeTheme

            local sectionFrame = createElementFrame(25) -- Height for section row
            sectionFrame.Name = "sectionFrame"

            local lineThickness = 1
            local lineYPos = 0.5

            -- Calculate line widths based on text size
            local textSize = TextService:GetTextSize(text, 14, FONT, Vector2.new(math.huge, 25))
            local textWidth = textSize.X + 20 -- Add padding around text
            local totalWidth = sectionFrame.AbsoluteSize.X -- Get frame width (might be 0 initially, handle this)
            if totalWidth == 0 then totalWidth = contentContainer.AbsoluteSize.X - (PADDING * 4) end -- Estimate width
            local lineWidth = math.max(10, (totalWidth - textWidth) / 2) -- Ensure minimum line width

            local leftLine = Instance.new("Frame")
            leftLine.Name = "leftLine"
            leftLine.Parent = sectionFrame
            leftLine.BackgroundColor3 = theme.elementOutline
            leftLine.BorderSizePixel = 0
            leftLine.AnchorPoint = Vector2.new(0, 0.5)
            leftLine.Position = UDim2.new(0, 0, lineYPos, 0)
            leftLine.Size = UDim2.new(0, lineWidth, 0, lineThickness)

            local rightLine = Instance.new("Frame")
            rightLine.Name = "rightLine"
            rightLine.Parent = sectionFrame
            rightLine.BackgroundColor3 = theme.elementOutline
            rightLine.BorderSizePixel = 0
            rightLine.AnchorPoint = Vector2.new(1, 0.5)
            rightLine.Position = UDim2.new(1, 0, lineYPos, 0)
            rightLine.Size = UDim2.new(0, lineWidth, 0, lineThickness)

            local sectionLabel = Instance.new("TextLabel")
            sectionLabel.Name = "sectionLabel"
            sectionLabel.Parent = sectionFrame
            sectionLabel.BackgroundTransparency = 1
            sectionLabel.AnchorPoint = Vector2.new(0.5, 0.5)
            sectionLabel.Position = UDim2.new(0.5, 0, 0.5, 0) -- Center label
            sectionLabel.Size = UDim2.new(0, textWidth, 1, 0) -- Size based on text
            sectionLabel.Font = FONT
            sectionLabel.Text = text
            sectionLabel.TextColor3 = theme.title -- Use highlight color for section titles
            sectionLabel.TextSize = 14
            sectionLabel.TextXAlignment = Enum.TextXAlignment.Center
            sectionLabel.TextYAlignment = Enum.TextYAlignment.Center

            -- Handle resize if window size changes (optional, but good practice)
            local resizeConnection
            resizeConnection = sectionFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                 if not sectionFrame or not sectionFrame.Parent then
                      if resizeConnection then resizeConnection:Disconnect() end
                      return
                 end
                 local newTotalWidth = sectionFrame.AbsoluteSize.X
                 local newLineWidth = math.max(10, (newTotalWidth - textWidth) / 2)
                 leftLine.Size = UDim2.new(0, newLineWidth, 0, lineThickness)
                 rightLine.Size = UDim2.new(0, newLineWidth, 0, lineThickness)
            end)
            sectionFrame.Destroying:Connect(function() if resizeConnection then resizeConnection:Disconnect() end end)

            -- No functions needed for a static section
        end

        -- Simple Separator Line Element
        function Tab:NewSeparator() -- Renamed for clarity
            local theme = library.activeTheme
            local separatorFrame = createElementFrame(10) -- Small height for separator
            separatorFrame.Name = "separatorFrame"

            local line = Instance.new("Frame")
            line.Name = "line"
            line.Parent = separatorFrame
            line.BackgroundColor3 = theme.elementOutline
            line.BorderSizePixel = 0
            line.AnchorPoint = Vector2.new(0.5, 0.5)
            line.Position = UDim2.new(0.5, 0, 0.5, 0) -- Center the line
            line.Size = UDim2.new(1, 0, 0, 1) -- Full width, 1 pixel high

            -- No functions needed for a static separator
        end

        -- Button Element
        function Tab:NewButton(text, callback)
            text = text or "Button"
            callback = callback or function() print("Button '" .. text .. "' clicked") end
            local theme = library.activeTheme

            local buttonFrame = createElementFrame(35) -- Standard button height
            buttonFrame.Name = "buttonFrame"

            local button = Instance.new("TextButton")
            button.Name = "button"
            button.Parent = buttonFrame
            button.BackgroundColor3 = theme.elementBg -- Use general element bg
            button.BorderSizePixel = 0
            button.Size = UDim2.new(1, 0, 1, 0) -- Fill frame
            button.Font = FONT
            button.Text = text
            button.TextColor3 = theme.text -- Standard text color
            button.TextSize = 14
            button.AutoButtonColor = false

            local buttonCorner = Instance.new("UICorner")
            buttonCorner.CornerRadius = UDim.new(0, 4)
            buttonCorner.Parent = button

            -- Button hover/click effects
            local hoverColor = theme.elementHover
            local clickColor = theme.elementActive
            local originalColor = button.BackgroundColor3
            local tweenInfo = TweenInfo.new(0.15)

            button.MouseEnter:Connect(function()
                TweenService:Create(button, tweenInfo, {BackgroundColor3 = hoverColor}):Play()
            end)
            button.MouseLeave:Connect(function()
                TweenService:Create(button, tweenInfo, {BackgroundColor3 = originalColor}):Play()
            end)
            button.MouseButton1Down:Connect(function()
                TweenService:Create(button, tweenInfo, {BackgroundColor3 = clickColor}):Play()
            end)
            button.MouseButton1Up:Connect(function()
                TweenService:Create(button, tweenInfo, {BackgroundColor3 = hoverColor}):Play() -- Return to hover color
                pcall(callback) -- Safely call the callback
            end)

            local ButtonFunctions = {}
            function ButtonFunctions:SetText(newText)
                button.Text = newText or ""
                return ButtonFunctions
            end
            return ButtonFunctions
        end

        -- Toggle Element
        function Tab:NewToggle(text, defaultState, callback)
            text = text or "Toggle"
            defaultState = defaultState or false
            callback = callback or function(state) print("Toggle '" .. text .. "' state:", state) end
            local theme = library.activeTheme

            local state = defaultState
            local toggleFrame = createElementFrame(30) -- Height for toggle row
            toggleFrame.Name = "toggleFrame"

            local toggleButton = Instance.new("TextButton") -- Use a button for the whole area
            toggleButton.Name = "toggleButton"
            toggleButton.Parent = toggleFrame
            toggleButton.BackgroundColor3 = theme.elementBg
            toggleButton.BorderSizePixel = 0
            toggleButton.Size = UDim2.new(1, 0, 1, 0)
            toggleButton.Font = FONT
            toggleButton.Text = "" -- Text handled by separate label
            toggleButton.AutoButtonColor = false

            local toggleCorner = Instance.new("UICorner")
            toggleCorner.CornerRadius = UDim.new(0, 4)
            toggleCorner.Parent = toggleButton

            -- Label for the toggle text
            local toggleLabel = Instance.new("TextLabel")
            toggleLabel.Name = "toggleLabel"
            toggleLabel.Parent = toggleButton -- Parent to button for alignment
            toggleLabel.BackgroundTransparency = 1
            toggleLabel.AnchorPoint = Vector2.new(0, 0.5)
            toggleLabel.Position = UDim2.new(0, 10, 0.5, 0) -- Position left, centered vertically
            toggleLabel.Size = UDim2.new(0.7, -50, 1, 0) -- Size relative to button, leave space for indicator
            toggleLabel.Font = FONT
            toggleLabel.Text = text
            toggleLabel.TextColor3 = theme.text
            toggleLabel.TextSize = 14
            toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
            toggleLabel.TextYAlignment = Enum.TextYAlignment.Center

            -- Toggle Indicator Background
            local indicatorWidth = 40
            local indicatorHeight = 20
            local toggleIndicator = Instance.new("Frame")
            toggleIndicator.Name = "toggleIndicator"
            toggleIndicator.Parent = toggleButton
            toggleIndicator.AnchorPoint = Vector2.new(1, 0.5)
            toggleIndicator.BackgroundColor3 = theme.toggleIndicatorOff -- Off state background
            toggleIndicator.Position = UDim2.new(1, -10, 0.5, 0) -- Position right, centered vertically
            toggleIndicator.Size = UDim2.new(0, indicatorWidth, 0, indicatorHeight)

            local toggleIndicatorCorner = Instance.new("UICorner")
            toggleIndicatorCorner.CornerRadius = UDim.new(1, 0) -- Fully rounded ends
            toggleIndicatorCorner.Parent = toggleIndicator

            -- Toggle Switch (the moving part)
            local switchSize = indicatorHeight - 4 -- Slightly smaller than indicator height
            local toggleSwitch = Instance.new("Frame")
            toggleSwitch.Name = "toggleSwitch"
            toggleSwitch.Parent = toggleIndicator
            toggleSwitch.BackgroundColor3 = theme.toggleSwitchOff -- Off state color
            toggleSwitch.AnchorPoint = Vector2.new(0, 0.5) -- Anchor left for positioning
            toggleSwitch.Position = UDim2.new(0, 2, 0.5, 0) -- Start position (left)
            toggleSwitch.Size = UDim2.new(0, switchSize, 0, switchSize)

            local toggleSwitchCorner = Instance.new("UICorner")
            toggleSwitchCorner.CornerRadius = UDim.new(1, 0) -- Circle
            toggleSwitchCorner.Parent = toggleSwitch

            -- Toggle hover effect (on the main button)
            local hoverColor = theme.elementHover
            local originalColor = toggleButton.BackgroundColor3
            local tweenInfo = TweenInfo.new(0.15)

            toggleButton.MouseEnter:Connect(function()
                TweenService:Create(toggleButton, tweenInfo, {BackgroundColor3 = hoverColor}):Play()
            end)
            toggleButton.MouseLeave:Connect(function()
                TweenService:Create(toggleButton, tweenInfo, {BackgroundColor3 = originalColor}):Play()
            end)

            -- Function to update toggle visual state
            local function updateToggleVisuals()
                 -- Check if elements exist before tweening
                 if not toggleSwitch or not toggleSwitch.Parent or not toggleIndicator or not toggleIndicator.Parent then
                      return
                 end
                 local theme = library.activeTheme -- Get current theme state
                 local targetPos, targetColor, targetBgColor
                 if state then
                      targetPos = UDim2.new(1, -(switchSize + 2), 0.5, 0) -- Position right
                      targetColor = theme.toggleSwitchOn -- Use theme color for ON state
                      targetBgColor = theme.toggleIndicatorOn -- Background for ON
                 else
                      targetPos = UDim2.new(0, 2, 0.5, 0) -- Position left
                      targetColor = theme.toggleSwitchOff -- Default switch color for OFF
                      targetBgColor = theme.toggleIndicatorOff -- Default background for OFF
                 end
                 TweenService:Create(toggleSwitch, TweenInfo.new(0.2), {Position = targetPos, BackgroundColor3 = targetColor}):Play()
                 TweenService:Create(toggleIndicator, TweenInfo.new(0.2), {BackgroundColor3 = targetBgColor}):Play()
            end

            -- Toggle click handler
            toggleButton.MouseButton1Click:Connect(function()
                state = not state
                updateToggleVisuals()
                pcall(callback, state) -- Safely call callback with the new state
            end)

            -- Set initial visual state
            updateToggleVisuals()

            local ToggleFunctions = {}
            function ToggleFunctions:Set(newState)
                if type(newState) == "boolean" and newState ~= state then
                    state = newState
                    updateToggleVisuals()
                    pcall(callback, state) -- Call callback on programmatic change too
                end
                return ToggleFunctions
            end
            function ToggleFunctions:Get()
                return state
            end
             -- Function to add keybind (optional - now just adds indicator, binding handled by NewKeybind)
            function ToggleFunctions:AddKeybindIndicator(keyName)
                 if not keyName or type(keyName) ~= "string" then return ToggleFunctions end

                 local keyIndicator = toggleButton:FindFirstChild("keyIndicator")
                 if not keyIndicator then
                      keyIndicator = Instance.new("TextLabel")
                      keyIndicator.Name = "keyIndicator"
                      keyIndicator.Parent = toggleButton -- Parent to button
                      keyIndicator.AnchorPoint = Vector2.new(1, 0.5)
                      keyIndicator.BackgroundTransparency = 1
                      keyIndicator.Position = UDim2.new(1, -(indicatorWidth + 15), 0.5, 0) -- Position left of toggle
                      keyIndicator.Size = UDim2.new(0, 40, 1, 0) -- Auto width based on text later
                      keyIndicator.Font = FONT
                      keyIndicator.TextColor3 = theme.title -- Use highlight color
                      keyIndicator.TextSize = 12
                      keyIndicator.TextXAlignment = Enum.TextXAlignment.Right
                      keyIndicator.TextYAlignment = Enum.TextYAlignment.Center
                      keyIndicator.TextWrapped = false
                      keyIndicator.TextTruncate = Enum.TextTruncate.AtEnd
                      keyIndicator.ZIndex = 2
                      -- Adjust label size to leave space for keybind indicator
                      toggleLabel.Size = UDim2.new(0.7, -(indicatorWidth + 60), 1, 0)
                 end

                 keyIndicator.Text = "[" .. keyName .. "]"

                 return ToggleFunctions
            end

            return ToggleFunctions
        end

        -- Keybind Element (Reworked - Point 1)
        function Tab:NewKeybind(text, defaultKey, callback)
            text = text or "Keybind"
            -- Default key is now nil (None)
            defaultKey = defaultKey -- Keep parameter but don't default it here
            callback = callback or function(key) print("Keybind '" .. text .. "' set to:", key and key.Name or "None") end
            local theme = library.activeTheme

            local currentKey = defaultKey -- Store the KeyCode or nil
            local keybindFrame = createElementFrame(30)
            keybindFrame.Name = "keybindFrame"

            local keybindButton = Instance.new("TextButton") -- Still use a button for visuals and right-click
            keybindButton.Name = "keybindButton"
            keybindButton.Parent = keybindFrame
            keybindButton.BackgroundColor3 = theme.elementBg
            keybindButton.BorderSizePixel = 0
            keybindButton.Size = UDim2.new(1, 0, 1, 0)
            keybindButton.Font = FONT
            keybindButton.Text = "" -- Text handled by label + key display
            keybindButton.AutoButtonColor = false
            keybindButton.Selectable = true -- Allow right click context menu maybe? No, handle manually.

            local keybindCorner = Instance.new("UICorner")
            keybindCorner.CornerRadius = UDim.new(0, 4)
            keybindCorner.Parent = keybindButton

            -- Label for the keybind text
            local keybindLabel = Instance.new("TextLabel")
            keybindLabel.Name = "keybindLabel"
            keybindLabel.Parent = keybindButton
            keybindLabel.BackgroundTransparency = 1
            keybindLabel.AnchorPoint = Vector2.new(0, 0.5)
            keybindLabel.Position = UDim2.new(0, 10, 0.5, 0)
            keybindLabel.Size = UDim2.new(0.6, 0, 1, 0) -- Take up part of the button
            keybindLabel.Font = FONT
            keybindLabel.Text = text
            keybindLabel.TextColor3 = theme.text
            keybindLabel.TextSize = 14
            keybindLabel.TextXAlignment = Enum.TextXAlignment.Left
            keybindLabel.TextYAlignment = Enum.TextYAlignment.Center

            -- TextLabel to display the current key
            local keyDisplay = Instance.new("TextLabel")
            keyDisplay.Name = "keyDisplay"
            keyDisplay.Parent = keybindButton
            keyDisplay.BackgroundTransparency = 1
            keyDisplay.AnchorPoint = Vector2.new(1, 0.5)
            keyDisplay.Position = UDim2.new(1, -10, 0.5, 0) -- Position right
            keyDisplay.Size = UDim2.new(0.35, 0, 1, 0) -- Size for key display
            keyDisplay.Font = FONT
            keyDisplay.Text = "[" .. (currentKey and currentKey.Name or "None") .. "]"
            keyDisplay.TextColor3 = theme.title -- Highlight color for the key
            keyDisplay.TextSize = 13
            keyDisplay.TextXAlignment = Enum.TextXAlignment.Right
            keyDisplay.TextYAlignment = Enum.TextYAlignment.Center

            -- Keybind hover effect
            local hoverColor = theme.elementHover
            local originalColor = keybindButton.BackgroundColor3
            local tweenInfo = TweenInfo.new(0.15)

            keybindButton.MouseEnter:Connect(function()
                 TweenService:Create(keybindButton, tweenInfo, {BackgroundColor3 = hoverColor}):Play()
            end)
            keybindButton.MouseLeave:Connect(function()
                 TweenService:Create(keybindButton, tweenInfo, {BackgroundColor3 = originalColor}):Play()
            end)

            -- Right-Click Handler to initiate binding
            keybindButton.InputBegan:Connect(function(input)
                 if input.UserInputType == Enum.UserInputType.MouseButton2 then -- Right Mouse Button
                      -- Create and show the binding prompt
                      library:_CreateKeybindPrompt(function(selectedKey)
                           -- This callback receives the result from the prompt
                           if selectedKey == "None" then -- Cleared
                                currentKey = nil
                                keyDisplay.Text = "[None]"
                                pcall(callback, nil)
                           elseif selectedKey then -- New key selected (is a KeyCode)
                                currentKey = selectedKey
                                keyDisplay.Text = "[" .. currentKey.Name .. "]"
                                pcall(callback, currentKey)
                           end
                           -- If selectedKey is nil, it means cancelled, do nothing
                      end)
                 end
            end)


            local KeybindFunctions = {}
            function KeybindFunctions:Set(newKey)
                 if newKey == nil or newKey == Enum.KeyCode.Unknown or (type(newKey) == "string" and string.lower(newKey) == "none") then
                      currentKey = nil
                      keyDisplay.Text = "[None]"
                      pcall(callback, nil)
                 elseif typeof(newKey) == "EnumItem" and newKey:IsA("KeyCode") then
                      currentKey = newKey
                      keyDisplay.Text = "[" .. currentKey.Name .. "]"
                      pcall(callback, currentKey)
                 else
                      warn("Invalid KeyCode provided for :Set() on keybind '"..text.."'")
                 end
                 return KeybindFunctions
            end
            function KeybindFunctions:Get()
                 return currentKey
            end

             -- Add listener for the actual keybind activation
             local activationConnection = nil
             local function updateActivationListener()
                  if activationConnection then activationConnection:Disconnect(); activationConnection = nil end
                  if currentKey and currentKey ~= Enum.KeyCode.Unknown then
                       activationConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                            if not gameProcessed and input.KeyCode == currentKey then
                                 local focused = UserInputService:GetFocusedTextBox()
                                 if not focused then
                                     pcall(callback, currentKey) -- Trigger callback when key is pressed
                                 end
                            end
                       end)
                  end
             end

             -- Update listener when key changes or element is destroyed
             keyDisplay:GetPropertyChangedSignal("Text"):Connect(updateActivationListener)
             keybindFrame.Destroying:Connect(function() if activationConnection then activationConnection:Disconnect() end end)
             -- Set initial listener
             updateActivationListener()


            return KeybindFunctions
        end

        -- Textbox Element
        function Tab:NewTextbox(text, placeholder, isPassword, callback)
            text = text or ""
            placeholder = placeholder or "Enter text..."
            isPassword = isPassword or false
            callback = callback or function(newText) print("Textbox content:", newText) end
            local theme = library.activeTheme

            local textboxFrame = createElementFrame(35) -- Standard height
            textboxFrame.Name = "textboxFrame"

            local textbox = Instance.new("TextBox")
            textbox.Name = "textbox"
            textbox.Parent = textboxFrame
            textbox.BackgroundColor3 = theme.elementBg
            textbox.BorderSizePixel = 0
            textbox.Size = UDim2.new(1, 0, 1, 0) -- Fill frame
            textbox.Font = FONT
            textbox.Text = text
            textbox.PlaceholderText = placeholder
            textbox.PlaceholderColor3 = theme.textDark
            textbox.TextColor3 = theme.textLight
            textbox.TextSize = 14
            textbox.TextWrapped = false
            textbox.ClearTextOnFocus = false
            textbox.TextXAlignment = Enum.TextXAlignment.Left
            textbox.TextYAlignment = Enum.TextYAlignment.Center
            textbox.TextEditable = true
            textbox.TextPassword = isPassword
            textbox.ClipsDescendants = true

            local textboxPadding = Instance.new("UIPadding")
            textboxPadding.PaddingLeft = UDim.new(0, 10)
            textboxPadding.PaddingRight = UDim.new(0, 10)
            textboxPadding.PaddingTop = UDim.new(0, 2)
            textboxPadding.PaddingBottom = UDim.new(0, 2)
            textboxPadding.Parent = textbox

            local textboxCorner = Instance.new("UICorner")
            textboxCorner.CornerRadius = UDim.new(0, 4)
            textboxCorner.Parent = textbox

            -- Focus/unfocus visual feedback
            local focusColor = theme.elementActive -- Use active color for focus
            local originalColor = textbox.BackgroundColor3
            local tweenInfo = TweenInfo.new(0.15)

            textbox.Focused:Connect(function()
                TweenService:Create(textbox, tweenInfo, {BackgroundColor3 = focusColor}):Play()
            end)

            textbox.FocusLost:Connect(function(enterPressed)
                TweenService:Create(textbox, tweenInfo, {BackgroundColor3 = originalColor}):Play()
                pcall(callback, textbox.Text) -- Call callback when focus lost (or enter pressed)
            end)

            local TextboxFunctions = {}
            function TextboxFunctions:SetText(newText)
                textbox.Text = newText or ""
                return TextboxFunctions
            end
            function TextboxFunctions:GetText()
                return textbox.Text
            end
            function TextboxFunctions:Clear()
                textbox.Text = ""
                pcall(callback, "") -- Call callback on clear too
                return TextboxFunctions
            end
            function TextboxFunctions:SetEditable(editable)
                textbox.TextEditable = (editable == true)
                return TextboxFunctions
            end

            return TextboxFunctions
        end

        -- Slider Element
        function Tab:NewSlider(text, min, max, default, precision, callback)
            text = text or "Slider"
            min = tonumber(min) or 0
            max = tonumber(max) or 100
            default = math.clamp(tonumber(default) or min, min, max)
            precision = tonumber(precision) or 0 -- Number of decimal places
            callback = callback or function(value) print("Slider '" .. text .. "' value:", value) end
            local theme = library.activeTheme

            local currentValue = default
            local sliderFrame = createElementFrame(45) -- Taller frame for slider + label
            sliderFrame.Name = "sliderFrame"

            -- Label for the slider
            local sliderLabel = Instance.new("TextLabel")
            sliderLabel.Name = "sliderLabel"
            sliderLabel.Parent = sliderFrame
            sliderLabel.BackgroundTransparency = 1
            sliderLabel.Position = UDim2.new(0, 0, 0, 0) -- Top position
            sliderLabel.Size = UDim2.new(0.7, 0, 0, 20) -- Size for label text
            sliderLabel.Font = FONT
            sliderLabel.Text = text
            sliderLabel.TextColor3 = theme.text
            sliderLabel.TextSize = 14
            sliderLabel.TextXAlignment = Enum.TextXAlignment.Left
            sliderLabel.TextYAlignment = Enum.TextYAlignment.Center

            -- Label to display the current value
            local valueLabel = Instance.new("TextLabel")
            valueLabel.Name = "valueLabel"
            valueLabel.Parent = sliderFrame
            valueLabel.BackgroundTransparency = 1
            valueLabel.AnchorPoint = Vector2.new(1, 0)
            valueLabel.Position = UDim2.new(1, 0, 0, 0) -- Top right position
            valueLabel.Size = UDim2.new(0.3, 0, 0, 20) -- Size for value display
            valueLabel.Font = FONT
            valueLabel.Text = string.format("%." .. precision .. "f", currentValue) -- Format initial value
            valueLabel.TextColor3 = theme.title -- Highlight color for value
            valueLabel.TextSize = 13
            valueLabel.TextXAlignment = Enum.TextXAlignment.Right
            valueLabel.TextYAlignment = Enum.TextYAlignment.Center

            -- Slider background/track
            local trackHeight = 6
            local track = Instance.new("Frame")
            track.Name = "track"
            track.Parent = sliderFrame
            track.BackgroundColor3 = theme.elementBg
            track.BorderSizePixel = 0
            track.AnchorPoint = Vector2.new(0.5, 1)
            track.Position = UDim2.new(0.5, 0, 1, -5) -- Position at bottom, centered
            track.Size = UDim2.new(1, 0, 0, trackHeight) -- Full width, fixed height

            local trackCorner = Instance.new("UICorner")
            trackCorner.CornerRadius = UDim.new(1, 0) -- Fully rounded track
            trackCorner.Parent = track

            -- Slider fill/progress bar
            local fill = Instance.new("Frame")
            fill.Name = "fill"
            fill.Parent = track -- Parent to track
            fill.BackgroundColor3 = theme.sliderFill -- Use highlight color for fill
            fill.BorderSizePixel = 0
            fill.Position = UDim2.new(0, 0, 0, 0) -- Start at left
            fill.Size = UDim2.new(0, 0, 1, 0) -- Initial size based on default value

            local fillCorner = Instance.new("UICorner")
            fillCorner.CornerRadius = UDim.new(1, 0)
            fillCorner.Parent = fill

            -- Slider handle/thumb
            local handleSize = 12
            local handle = Instance.new("Frame")
            handle.Name = "handle"
            handle.Parent = track -- Parent to track for positioning
            handle.BackgroundColor3 = theme.sliderHandle -- Bright handle
            handle.BorderSizePixel = 0
            handle.AnchorPoint = Vector2.new(0.5, 0.5)
            handle.Position = UDim2.new(0, 0, 0.5, 0) -- Center vertically, position horizontally based on value
            handle.Size = UDim2.new(0, handleSize, 0, handleSize)
            handle.ZIndex = 3 -- Ensure handle is above fill

            local handleCorner = Instance.new("UICorner")
            handleCorner.CornerRadius = UDim.new(1, 0) -- Circular handle
            handleCorner.Parent = handle

            -- Dragging logic variables
            local isDragging = false
            local dragInput = nil
            local inputChangedConn = nil
            local inputEndedConn = nil

            -- Function to update slider value and visuals based on X coordinate relative to track
            local function updateSliderFromX(absoluteX)
                 -- Ensure elements exist
                 if not track or not track.Parent or not fill or not fill.Parent or not handle or not handle.Parent then
                      if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end
                      if inputEndedConn then inputEndedConn:Disconnect(); inputEndedConn = nil end
                      isDragging = false
                      return
                 end

                local trackStartX = track.AbsolutePosition.X
                local trackWidth = track.AbsoluteSize.X
                if trackWidth <= 0 then return end -- Avoid division by zero

                local relativeX = absoluteX - trackStartX
                local fraction = math.clamp(relativeX / trackWidth, 0, 1)

                local newValue = min + (max - min) * fraction
                local power = 10^precision
                newValue = math.floor(newValue * power + 0.5) / power
                newValue = math.clamp(newValue, min, max)

                if newValue ~= currentValue then
                    currentValue = newValue
                    valueLabel.Text = string.format("%." .. precision .. "f", currentValue)
                    local fillFraction = (currentValue - min) / (max - min)
                     if max == min then fillFraction = 0 end -- Handle division by zero if min == max

                    -- Use TweenService for smoother visual update
                    local tweenInfoFast = TweenInfo.new(0.05)
                    TweenService:Create(fill, tweenInfoFast, {Size = UDim2.new(fillFraction, 0, 1, 0)}):Play()
                    TweenService:Create(handle, tweenInfoFast, {Position = UDim2.new(fillFraction, 0, 0.5, 0)}):Play()
                    pcall(callback, currentValue) -- Call callback
                end
            end

            -- Set initial visual state based on default value
            local initialFraction = 0
            if max > min then initialFraction = (default - min) / (max - min) end
            fill.Size = UDim2.new(initialFraction, 0, 1, 0)
            handle.Position = UDim2.new(initialFraction, 0, 0.5, 0)

            -- Function to stop dragging
            local function stopDragging()
                 if isDragging then
                      isDragging = false
                      dragInput = nil
                      if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end
                      if inputEndedConn then inputEndedConn:Disconnect(); inputEndedConn = nil end
                       -- Reset handle color slightly on release
                       if handle and handle.Parent then
                           TweenService:Create(handle, TweenInfo.new(0.1), { BackgroundColor3 = theme.sliderHandle }):Play()
                       end
                 end
            end

            -- Function to start dragging
            local function startDragging(input)
                 if isDragging then return end
                 isDragging = true
                 dragInput = input
                 updateSliderFromX(input.Position.X)

                  -- Slightly change handle color on drag
                  if handle and handle.Parent then
                      TweenService:Create(handle, TweenInfo.new(0.1), { BackgroundColor3 = theme.sliderHandle:Lerp(Color3.new(1,1,1), 0.2) }):Play()
                  end

                 if inputChangedConn then inputChangedConn:Disconnect() end
                 if inputEndedConn then inputEndedConn:Disconnect() end

                 inputChangedConn = UserInputService.InputChanged:Connect(function(changedInput)
                      if isDragging and (changedInput.UserInputType == Enum.UserInputType.MouseMovement or changedInput.UserInputType == Enum.UserInputType.Touch) then
                           updateSliderFromX(changedInput.Position.X)
                      end
                 end)

                 inputEndedConn = dragInput.Changed:Connect(function()
                      if dragInput.UserInputState == Enum.UserInputState.End then
                           stopDragging()
                      end
                 end)
            end

            track.InputBegan:Connect(function(input)
                 if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                      startDragging(input)
                 end
            end)
            handle.InputBegan:Connect(function(input)
                 if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                      startDragging(input)
                 end
            end)
            track.InputEnded:Connect(function(input) if input == dragInput then stopDragging() end end)
            handle.InputEnded:Connect(function(input) if input == dragInput then stopDragging() end end)


            local SliderFunctions = {}
            function SliderFunctions:Set(newValue)
                newValue = tonumber(newValue)
                if newValue then
                     local power = 10^precision
                     newValue = math.floor(newValue * power + 0.5) / power
                     newValue = math.clamp(newValue, min, max)
                     if newValue ~= currentValue then
                          currentValue = newValue
                          valueLabel.Text = string.format("%." .. precision .. "f", currentValue)
                          local fillFraction = 0
                          if max > min then fillFraction = (currentValue - min) / (max - min) end
                          fill.Size = UDim2.new(fillFraction, 0, 1, 0)
                          handle.Position = UDim2.new(fillFraction, 0, 0.5, 0)
                          pcall(callback, currentValue)
                     end
                end
                return SliderFunctions
            end
            function SliderFunctions:Get()
                return currentValue
            end

            return SliderFunctions
        end

        -- Dropdown Element (Reworked - Point 1)
        function Tab:NewDropdown(text, options, defaultIndex, callback)
            text = text or "Dropdown"
            options = options or {"Option 1", "Option 2"}
            defaultIndex = math.clamp(tonumber(defaultIndex) or 1, 1, #options)
            callback = callback or function(selectedOption, index) print("Dropdown '" .. text .. "' selected:", selectedOption, "at index", index) end
            local theme = library.activeTheme

            local isOpen = false
            local currentSelectionIndex = defaultIndex
            local currentSelectionText = #options > 0 and options[currentSelectionIndex] or "" -- Handle empty options

            local dropdownFrame = createElementFrame(35) -- Standard height for collapsed state
            dropdownFrame.Name = "dropdownFrame_"..safeName.."_"..text:gsub("%W","") -- More specific name
            dropdownFrame.ClipsDescendants = false -- Allow options list to overflow
            dropdownFrame.ZIndex = 2 -- Base ZIndex

            -- Main button to show current selection and toggle dropdown
            local dropdownButton = Instance.new("TextButton")
            dropdownButton.Name = "dropdownButton"
            dropdownButton.Parent = dropdownFrame
            dropdownButton.BackgroundColor3 = theme.elementBg
            dropdownButton.BorderSizePixel = 0
            dropdownButton.Size = UDim2.new(1, 0, 1, 0) -- Fill frame
            dropdownButton.Font = FONT
            dropdownButton.Text = "" -- Text handled by label
            dropdownButton.AutoButtonColor = false
            dropdownButton.ZIndex = 3

            local dropdownCorner = Instance.new("UICorner")
            dropdownCorner.CornerRadius = UDim.new(0, 4)
            dropdownCorner.Parent = dropdownButton

            -- Label showing the dropdown title/current selection
            local dropdownLabel = Instance.new("TextLabel")
            dropdownLabel.Name = "dropdownLabel"
            dropdownLabel.Parent = dropdownButton
            dropdownLabel.BackgroundTransparency = 1
            dropdownLabel.AnchorPoint = Vector2.new(0, 0.5)
            dropdownLabel.Position = UDim2.new(0, 10, 0.5, 0) -- Left aligned
            dropdownLabel.Size = UDim2.new(0.8, -20, 1, 0) -- Leave space for arrow + padding
            dropdownLabel.Font = FONT
            dropdownLabel.Text = currentSelectionText -- Display only selected text
            -- dropdownLabel.Text = text .. ": " .. currentSelectionText -- Alternative: Show title too
            dropdownLabel.TextColor3 = theme.textLight -- Brighter text for selection
            dropdownLabel.TextSize = 14
            dropdownLabel.TextXAlignment = Enum.TextXAlignment.Left
            dropdownLabel.TextYAlignment = Enum.TextYAlignment.Center
            dropdownLabel.TextTruncate = Enum.TextTruncate.AtEnd
            dropdownLabel.ZIndex = 4

            -- Arrow indicator
            local arrowSize = 10
            local arrow = Instance.new("ImageLabel")
            arrow.Name = "arrow"
            arrow.Parent = dropdownButton
            arrow.BackgroundTransparency = 1
            arrow.AnchorPoint = Vector2.new(1, 0.5)
            arrow.Position = UDim2.new(1, -10, 0.5, 0) -- Right aligned
            arrow.Size = UDim2.new(0, arrowSize, 0, arrowSize)
            arrow.Image = "rbxassetid://3926305904" -- Chevron down icon
            arrow.ImageColor3 = theme.textDark -- Use darker text color for arrow
            arrow.Rotation = 0 -- Start pointing down
            arrow.ZIndex = 4

            -- Options List Container (ScrollingFrame)
            local optionsListMaxHeight = 130 -- Max height before scrolling
            local optionHeight = 30
            local optionsList = Instance.new("ScrollingFrame")
            optionsList.Name = "optionsList"
            optionsList.Parent = dropdownFrame -- Parent to main frame
            optionsList.BackgroundColor3 = theme.elementBgLight -- Slightly lighter background
            optionsList.BorderSizePixel = 1
            optionsList.BorderColor3 = theme.elementOutline
            optionsList.Position = UDim2.new(0, 0, 1, 3) -- Position below the button
            optionsList.Size = UDim2.new(1, 0, 0, 0) -- Start collapsed (height 0)
            optionsList.Visible = false -- Start hidden
            optionsList.Active = true
            optionsList.ScrollBarThickness = 4
            optionsList.ScrollBarImageColor3 = theme.scrollbar
            optionsList.CanvasSize = UDim2.new(0, 0, 0, #options * optionHeight + 4) -- Calculate canvas size + padding
            optionsList.ClipsDescendants = true
            optionsList.ZIndex = 10 -- High ZIndex to appear on top when open

            local optionsListCorner = Instance.new("UICorner")
            optionsListCorner.CornerRadius = UDim.new(0, 4)
            optionsListCorner.Parent = optionsList

            local optionsListLayout = Instance.new("UIListLayout")
            optionsListLayout.Parent = optionsList
            optionsListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            optionsListLayout.Padding = UDim.new(0, 2) -- Small padding between options
            optionsListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center

            local optionsListPadding = Instance.new("UIPadding")
            optionsListPadding.Parent = optionsList
            optionsListPadding.PaddingTop = UDim.new(0, 3)
            optionsListPadding.PaddingBottom = UDim.new(0, 3)
            optionsListPadding.PaddingLeft = UDim.new(0, 3)
            optionsListPadding.PaddingRight = UDim.new(0, 3)

            local optionButtons = {} -- Store references to option buttons for easy update

            -- Dropdown hover effect
            local btnHoverColor = theme.elementHover
            local btnOriginalColor = dropdownButton.BackgroundColor3
            local btnTweenInfo = TweenInfo.new(0.1)
            dropdownButton.MouseEnter:Connect(function() if not isOpen then TweenService:Create(dropdownButton, btnTweenInfo, {BackgroundColor3 = btnHoverColor}):Play() end end)
            dropdownButton.MouseLeave:Connect(function() if not isOpen then TweenService:Create(dropdownButton, btnTweenInfo, {BackgroundColor3 = btnOriginalColor}):Play() end end)


            -- Function to close the dropdown
            local function closeDropdown()
                if not isOpen or not optionsList or not optionsList.Parent then return end
                isOpen = false
                optionsList.ZIndex = 2 -- Lower ZIndex when closed
                dropdownFrame.ZIndex = 2 -- Reset frame ZIndex
                TweenService:Create(optionsList, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, 0, 0, 0)}):Play()
                TweenService:Create(arrow, TweenInfo.new(0.15), {Rotation = 0}):Play() -- Arrow points down
                 TweenService:Create(dropdownButton, btnTweenInfo, {BackgroundColor3 = btnOriginalColor}):Play() -- Reset button color
                task.delay(0.16, function()
                     if optionsList and optionsList.Parent and not isOpen then optionsList.Visible = false end -- Hide after animation
                end)
            end

            -- Function to open the dropdown
            local function openDropdown()
                if isOpen or not optionsList or not optionsList.Parent then return end
                isOpen = true
                dropdownFrame.ZIndex = 10 -- Bring frame to front
                optionsList.ZIndex = 11 -- Ensure list is above frame
                optionsList.Visible = true
                local totalOptionsHeight = optionsList.CanvasSize.Y.Offset
                local targetHeight = math.min(optionsListMaxHeight, totalOptionsHeight)
                TweenService:Create(optionsList, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, 0, 0, targetHeight)}):Play()
                TweenService:Create(arrow, TweenInfo.new(0.2), {Rotation = 180}):Play() -- Arrow points up
                 TweenService:Create(dropdownButton, btnTweenInfo, {BackgroundColor3 = btnHoverColor}):Play() -- Set hover color while open
            end

            -- Function to populate options (reusable)
            local function populateOptions()
                 -- Clear existing options UI first
                 for _, button in ipairs(optionButtons) do
                      if button and button.Parent then button:Destroy() end
                 end
                 table.clear(optionButtons) -- Clear the tracking table

                 -- Update canvas size
                 local totalHeight = #options * optionHeight + (#options > 0 and (#options - 1) * optionsListLayout.Padding.Offset or 0) + optionsListPadding.PaddingTop.Offset + optionsListPadding.PaddingBottom.Offset
                 optionsList.CanvasSize = UDim2.new(0, 0, 0, totalHeight)

                 -- Create new option buttons
                 for i, optionText in ipairs(options) do
                      local optionButton = Instance.new("TextButton")
                      optionButton.Name = "option_" .. i
                      optionButton.Parent = optionsList
                      optionButton.BackgroundColor3 = theme.elementBgLight -- Option background
                      optionButton.BorderSizePixel = 0
                      optionButton.Size = UDim2.new(1, -6, 0, optionHeight) -- Full width minus padding
                      optionButton.Font = FONT
                      optionButton.Text = optionText
                      optionButton.TextColor3 = theme.text
                      optionButton.TextSize = 14
                      optionButton.AutoButtonColor = false
                      optionButton.TextXAlignment = Enum.TextXAlignment.Left
                      optionButton.LayoutOrder = i
                      table.insert(optionButtons, optionButton) -- Track button

                      local optionPadding = Instance.new("UIPadding")
                      optionPadding.PaddingLeft = UDim.new(0, 8)
                      optionPadding.Parent = optionButton

                       local optionCorner = Instance.new("UICorner")
                       optionCorner.CornerRadius = UDim.new(0, 3)
                       optionCorner.Parent = optionButton


                      -- Highlight selected option
                      if i == currentSelectionIndex then
                           optionButton.BackgroundColor3 = theme.elementActive -- Use active color for selected
                           optionButton.TextColor3 = theme.textLight
                      end

                      -- Option hover effect
                      local optHoverColor = theme.elementHover
                      local optOriginalColor = optionButton.BackgroundColor3 -- Store initial color (might be selected color)
                      local optTweenInfo = TweenInfo.new(0.1)

                      optionButton.MouseEnter:Connect(function()
                           if i ~= currentSelectionIndex then -- Don't change bg of selected on hover
                                TweenService:Create(optionButton, optTweenInfo, {BackgroundColor3 = optHoverColor}):Play()
                           end
                      end)
                      optionButton.MouseLeave:Connect(function()
                           if i ~= currentSelectionIndex then
                                TweenService:Create(optionButton, optTweenInfo, {BackgroundColor3 = theme.elementBgLight}):Play() -- Reset to base light color
                           end
                      end)

                      -- Option click handler
                      optionButton.MouseButton1Click:Connect(function()
                           -- Deselect previous in UI only if it exists and is different
                           if currentSelectionIndex >= 1 and currentSelectionIndex <= #optionButtons then
                                local previousSelected = optionButtons[currentSelectionIndex]
                                if previousSelected and previousSelected.Parent then
                                     previousSelected.BackgroundColor3 = theme.elementBgLight
                                     previousSelected.TextColor3 = theme.text
                                end
                           end

                           -- Update selection
                           currentSelectionIndex = i
                           currentSelectionText = optionText
                           dropdownLabel.Text = currentSelectionText -- Update label

                           -- Select new in UI
                           optionButton.BackgroundColor3 = theme.elementActive
                           optionButton.TextColor3 = theme.textLight

                           closeDropdown()
                           pcall(callback, currentSelectionText, currentSelectionIndex) -- Call callback
                      end)
                 end
            end

            -- Initial population
            populateOptions()

            -- Toggle dropdown open/close on main button click
            dropdownButton.MouseButton1Click:Connect(function()
                if isOpen then
                    closeDropdown()
                else
                     -- Close other open dropdowns first? (Optional, adds complexity)
                    openDropdown()
                end
            end)

            -- Close dropdown if clicked outside
            local clickOutsideConnection
             clickOutsideConnection = UserInputService.InputBegan:Connect(function(input)
                 if isOpen and (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
                      -- Check if click was outside the dropdown frame and options list
                      local clickPos = input.Position
                      local isDescendant = false
                       if input.GuiObject then
                           isDescendant = input.GuiObject == dropdownFrame or input.GuiObject:IsDescendantOf(dropdownFrame)
                       end

                      if not isDescendant then
                           closeDropdown()
                      end
                 end
             end)
             -- Disconnect click listener if dropdown is destroyed
             dropdownFrame.Destroying:Connect(function()
                 if clickOutsideConnection then clickOutsideConnection:Disconnect() end
             end)


            local DropdownFunctions = {}
            function DropdownFunctions:SetSelected(indexOrValue)
                 local targetIndex = -1
                 if type(indexOrValue) == "number" then
                      targetIndex = math.floor(indexOrValue)
                 elseif type(indexOrValue) == "string" then
                      for i, opt in ipairs(options) do
                           if opt == indexOrValue then
                                targetIndex = i
                                break
                           end
                      end
                 end

                 if targetIndex >= 1 and targetIndex <= #options and targetIndex ~= currentSelectionIndex then
                       -- Deselect previous in UI
                       if currentSelectionIndex >= 1 and currentSelectionIndex <= #optionButtons then
                            local previousSelected = optionButtons[currentSelectionIndex]
                            if previousSelected and previousSelected.Parent then
                                 previousSelected.BackgroundColor3 = theme.elementBgLight
                                 previousSelected.TextColor3 = theme.text
                            end
                       end

                      -- Update selection state
                      currentSelectionIndex = targetIndex
                      currentSelectionText = options[currentSelectionIndex]
                      dropdownLabel.Text = currentSelectionText

                       -- Select new in UI
                       if targetIndex >= 1 and targetIndex <= #optionButtons then
                            local newSelected = optionButtons[targetIndex]
                            if newSelected and newSelected.Parent then
                                 newSelected.BackgroundColor3 = theme.elementActive
                                 newSelected.TextColor3 = theme.textLight
                            end
                       end

                      pcall(callback, currentSelectionText, currentSelectionIndex) -- Call callback
                 end
                 return DropdownFunctions
            end
            function DropdownFunctions:GetSelected()
                return currentSelectionText, currentSelectionIndex
            end
            function DropdownFunctions:GetOptions()
                 return options -- Return the actual table (can be modified externally)
            end
             function DropdownFunctions:UpdateOptions(newOptions, maintainSelection)
                 if type(newOptions) ~= "table" then
                      warn("UpdateOptions requires a table.")
                      return DropdownFunctions
                 end

                 local oldSelectionText = currentSelectionText
                 options = newOptions -- Update the internal options table

                 -- Try to maintain selection if flag is true
                 local newIndex = -1
                 if maintainSelection then
                      for i, opt in ipairs(options) do
                           if opt == oldSelectionText then
                                newIndex = i
                                break
                           end
                      end
                 end

                 if newIndex > 0 then
                      currentSelectionIndex = newIndex
                      currentSelectionText = options[currentSelectionIndex]
                 else -- Reset selection if not found or not maintaining
                      currentSelectionIndex = math.clamp(1, 1, #options) -- Clamp to 1 if options is empty
                      if #options == 0 then
                           currentSelectionText = ""
                           currentSelectionIndex = 0 -- Indicate no valid selection
                      else
                           currentSelectionText = options[currentSelectionIndex] or ""
                      end
                 end

                 dropdownLabel.Text = currentSelectionText
                 populateOptions() -- Repopulate the visual list

                 -- If selection was reset, call callback
                 if newIndex <= 0 then
                     pcall(callback, currentSelectionText, currentSelectionIndex)
                 end

                 return DropdownFunctions
            end

            return DropdownFunctions
        end

        -- Add Settings Tab (Point 5)
        local settingsTab = Window:NewTab("Settings")
        settingsTab:NewSection("Appearance")

        local themeNames = {}
        for name, _ in pairs(library.themes) do
             table.insert(themeNames, name)
        end
        table.sort(themeNames) -- Sort alphabetically

        local currentThemeIndex = 1
        for i, name in ipairs(themeNames) do
            if name == library.activeTheme.name then
                currentThemeIndex = i
                break
            end
        end

        settingsTab:NewDropdown("Theme", themeNames, currentThemeIndex, function(selectedThemeName, index)
            library:ApplyTheme(selectedThemeName)
            -- Note: Re-applying theme might not update *all* elements live.
            -- A more robust implementation might require recreating elements or storing references.
        end)


        return Tab -- Return the Tab object with its element functions
    end -- End of Window:NewTab

    -- Return the Window object with its NewTab function
    return Window

end -- End of library:Init

-- Make sure to clean up FPS counter when library is no longer needed (e.g., script destroyed)
-- This is a basic example; you might need a more robust cleanup mechanism
-- game:GetService("ScriptContext").Error:Connect(function() library:StopFpsUpdater() end) -- Example cleanup on error
-- Player.CharacterRemoving:Connect(function() library:StopFpsUpdater() end) -- Example cleanup on char removal

-- Return the library table itself
return library
