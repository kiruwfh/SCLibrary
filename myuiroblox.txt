-- SC UI Lib by sc.owner (reuploaded)
-- init
local player = game.Players.LocalPlayer
-- local mouse = player:GetMouse() -- Deprecated, use UserInputService if needed

-- services
local input = game:GetService("UserInputService")
local run = game:GetService("RunService")
local tween = game:GetService("TweenService")
local TextService = game:GetService("TextService")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local tweeninfo = TweenInfo.new

-- additional
local utility = {}

-- themes
local objects = {} -- Stores weak references to themed objects
local themes = {
	Background = Color3.fromRGB(24, 24, 24),
	Glow = Color3.fromRGB(0, 0, 0),
	Accent = Color3.fromRGB(10, 10, 10),
	LightContrast = Color3.fromRGB(20, 20, 20),
	DarkContrast = Color3.fromRGB(14, 14, 14),
	TextColor = Color3.fromRGB(255, 255, 255),
	-- Notification Colors
	NotifInfo = Color3.fromRGB(100, 150, 255),
	NotifSuccess = Color3.fromRGB(100, 255, 150),
	NotifWarning = Color3.fromRGB(255, 255, 100),
	NotifError = Color3.fromRGB(255, 100, 100)
}

do -- Utility Functions block (Keep the improved versions from the previous response)
	function utility:Create(instance, properties, children)
		local object = Instance.new(instance)
		local success, err = pcall(function() -- Wrap in pcall for safety
			for i, v in pairs(properties or {}) do
                -- Handle Color3 specifically for theme tracking
				if i == "ImageColor3" or i == "TextColor3" or i == "BackgroundColor3" then
                    if typeof(v) == "Color3" then
                        local themeName = utility:Find(themes, v)
                        if themeName then
                            objects[themeName] = objects[themeName] or {}
                            objects[themeName][i] = objects[themeName][i] or setmetatable({}, {__mode = "k"}) -- Weak keys for objects
                            objects[themeName][i][object] = true
                        end
                    end
                end
                -- Set the property
				object[i] = v
			end

			for _, module in ipairs(children or {}) do -- Use ipairs for arrays
				if module then -- Check if child is valid
					module.Parent = object
				end
			end
		end)
        if not success then
            warn("[SCUI Error] Creating "..instance..":", err)
            warn("Properties:", properties)
        end
		return object
	end

	function utility:Tween(instance, properties, duration, ...)
		if not instance or not instance.Parent then return nil end
		local success, tweenInstance = pcall(tween.Create, tween, instance, tweeninfo(duration, ...), properties)
		if success and tweenInstance then
			tweenInstance:Play()
            return tweenInstance
		else
			warn("[SCUI Tween Error] Instance:", instance:GetFullName(), "Properties:", properties, "Error:", tweenInstance)
            return nil
		end
	end

	function utility:Wait()
		return run.RenderStepped:Wait()
	end

	function utility:Find(tbl, value)
		for i, v in pairs(tbl) do if v == value then return i end end
		return nil
	end

	function utility:Sort(pattern, values)
		local new = {}
		pattern = pattern:lower()
		if pattern == "" then return values end
		for _, value in ipairs(values) do
			if tostring(value):lower():find(pattern, 1, true) then
				table.insert(new, value)
			end
		end
		return new
	end

	function utility:Pop(object, shrink)
        if not object or not object.Parent then return nil end
		local clone = object:Clone()
		clone.AnchorPoint = Vector2.new(0.5, 0.5)
        local currentSize = object.AbsoluteSize
        local newShrink = math.min(shrink, currentSize.X / 2, currentSize.Y / 2)
		clone.Size = UDim2.fromOffset(currentSize.X - newShrink, currentSize.Y - newShrink)
		clone.Position = UDim2.new(0.5, 0, 0.5, 0)
		clone.Parent = object
		clone:ClearAllChildren()
        local originalTransparency = object.ImageTransparency
		object.ImageTransparency = 1
		utility:Tween(clone, {Size = object.Size}, 0.2)
		task.spawn(function()
			task.wait(0.2)
            if object and object.Parent then object.ImageTransparency = originalTransparency end
            if clone and clone.Parent then clone:Destroy() end
		end)
		return clone
	end

	function utility:InitializeKeybind()
        if self.keybindsInitialized then return end
		self.keybinds = {}
		self.ended = {}
		input.InputBegan:Connect(function(key, proc)
            if self.keybinds and self.keybinds[key.KeyCode] and not proc then
				for _, bindEntry in ipairs(self.keybinds[key.KeyCode]) do
					task.spawn(bindEntry.callback)
				end
			end
		end)
		input.InputEnded:Connect(function(key)
			if key.UserInputType == Enum.UserInputType.MouseButton1 then
                if self.ended then
                    for _, callback in ipairs(self.ended) do task.spawn(callback) end
				end
			end
		end)
        self.keybindsInitialized = true
	end

	function utility:BindToKey(key, callback)
        if not self.keybindsInitialized then utility:InitializeKeybind() end
		self.keybinds[key] = self.keybinds[key] or {}
        local bindEntry = { callback = callback }
		table.insert(self.keybinds[key], bindEntry)
		return {
			UnBind = function()
                if self.keybinds and self.keybinds[key] then
                    for i = #self.keybinds[key], 1, -1 do
                        if self.keybinds[key][i] == bindEntry then
                            table.remove(self.keybinds[key], i); break
                        end
                    end
                end
			end
		}
	end

	function utility:KeyPressed()
		while true do
			local key, gameProcessedEvent = input.InputBegan:Wait()
			if not gameProcessedEvent and key.UserInputType == Enum.UserInputType.Keyboard then
				local kc = key.KeyCode
				if kc ~= Enum.KeyCode.Unknown and kc ~= Enum.KeyCode.LeftShift and kc ~= Enum.KeyCode.RightShift and kc ~= Enum.KeyCode.LeftControl and kc ~= Enum.KeyCode.RightControl and kc ~= Enum.KeyCode.LeftAlt and kc ~= Enum.KeyCode.RightAlt and kc ~= Enum.KeyCode.LeftSuper and kc ~= Enum.KeyCode.RightSuper and kc ~= Enum.KeyCode.CapsLock and kc ~= Enum.KeyCode.Menu then
					return key
				end
			end
            task.wait()
		end
	end

	function utility:DraggingEnabled(frame, parent)
		parent = parent or frame; if not frame or not parent then return end
		local dragging, dragInput, mousePos, framePos, inputChangedConn = false
		frame.InputBegan:Connect(function(inputObj)
			if inputObj.UserInputType == Enum.UserInputType.MouseButton1 then
				dragging, mousePos, framePos = true, inputObj.Position, parent.Position
                if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end
				inputChangedConn = inputObj.Changed:Connect(function()
					if inputObj.UserInputState == Enum.UserInputState.End then
						dragging = false; if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end
					end
				end)
			end
		end)
		frame.InputChanged:Connect(function(inputObj)
			if inputObj.UserInputType == Enum.UserInputType.MouseMovement then dragInput = inputObj end
		end)
		input.InputChanged:Connect(function(globalInputObj)
			if globalInputObj == dragInput and dragging then
				local delta = globalInputObj.Position - mousePos
				if parent and parent.Parent then
					parent.Position = UDim2.new(framePos.X.Scale, framePos.X.Offset + delta.X, framePos.Y.Scale, framePos.Y.Offset + delta.Y)
                else
                    dragging = false; if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end
				end
			end
		end)
	end

	function utility:DraggingEnded(callback)
        if not self.ended then self.ended = {} end
		table.insert(self.ended, callback)
	end

    -- KeyPrompt function (Keep improved version from previous response)
    function utility:KeyPrompt(...)
        --[[ Paste the improved KeyPrompt function here ]]
        -- Ensure it uses task.wait/spawn and has robustness checks
        local theme = themes
        local keyPromptScreen = utility:Create("ScreenGui", { Name = "SCUI_KeyPromptScreen", Parent = CoreGui, ZIndexBehavior = Enum.ZIndexBehavior.Sibling, DisplayOrder = 1001, ResetOnSpawn = false })
        local blur = utility:Create("BlurEffect", { Size = 8, Parent = Lighting })
        local main = utility:Create("ImageLabel", { Name = "main", Parent = keyPromptScreen, BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, -0.5, 0), AnchorPoint = Vector2.new(0.5, 0.5), Size = UDim2.new(0, 320, 0, 160), Image = "rbxassetid://5028857472", ImageColor3 = theme.Background, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(4, 4, 296, 296), ZIndex = 1 }, { utility:Create("ImageLabel", { Name = "Glow", BackgroundTransparency = 1, Position = UDim2.new(0, -15, 0, -15), Size = UDim2.new(1, 30, 1, 30), ZIndex = 0, Image = "rbxassetid://5028857084", ImageColor3 = theme.Glow, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(24, 24, 276, 276) }), utility:Create("TextLabel", { Name = "Title", BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0, 20), AnchorPoint = Vector2.new(0.5, 0), Size = UDim2.new(0.9, 0, 0, 25), ZIndex = 2, Font = Enum.Font.GothamBold, Text = "SC UI - Key Required", TextColor3 = theme.TextColor, TextSize = 18, TextXAlignment = Enum.TextXAlignment.Center }), utility:Create("ImageLabel", { Name = "InputBackground", BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0.5, -15), AnchorPoint = Vector2.new(0.5, 0.5), Size = UDim2.new(0.85, 0, 0, 35), Image = "rbxassetid://5028857472", ImageColor3 = theme.DarkContrast, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298), ZIndex = 2 }, { utility:Create("TextBox", { Name = "KeyInput", BackgroundTransparency = 1, Size = UDim2.new(1, -10, 1, -4), Position = UDim2.new(0.5, 0, 0.5, 0), AnchorPoint = Vector2.new(0.5, 0.5), Font = Enum.Font.GothamSemibold, PlaceholderText = "Enter key...", PlaceholderColor3 = Color3.fromRGB(180, 180, 180), Text = "", TextColor3 = theme.TextColor, TextSize = 15, ClearTextOnFocus = false, TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Center, ZIndex = 3 }) }), utility:Create("ImageButton", { Name = "SubmitButton", BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0.8, 0), AnchorPoint = Vector2.new(0.5, 0.5), Size = UDim2.new(0.5, 0, 0, 35), Image = "rbxassetid://5028857472", ImageColor3 = theme.Accent, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298), ZIndex = 2, AutoButtonColor = false }, { utility:Create("TextLabel", { Name = "SubmitText", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Font = Enum.Font.GothamBold, Text = "Submit", TextColor3 = theme.TextColor, TextSize = 16, ZIndex = 3 }) }) })
        if not main or not main.Parent then warn("[SCUI Error] KeyPrompt main frame failed.") if keyPromptScreen and keyPromptScreen.Parent then keyPromptScreen:Destroy() end; if blur and blur.Parent then blur:Destroy() end; return end
        local keyInput = main:FindFirstChild("KeyInput", true); local submitButton = main:FindFirstChild("SubmitButton")
        if not keyInput or not submitButton then warn("[SCUI Error] KeyPrompt input/button not found.") if keyPromptScreen and keyPromptScreen.Parent then keyPromptScreen:Destroy() end; if blur and blur.Parent then blur:Destroy() end; return end
        utility:Tween(main, {Position = UDim2.new(0.5, 0, 0.5, 0)}, 0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
        local function shakeElement(element) if not element or not element.Parent then return end; local originalPos = element.Position; for _ = 1, 3 do utility:Tween(element, {Position = originalPos + UDim2.fromOffset(8, 0)}, 0.05); task.wait(0.05); utility:Tween(element, {Position = originalPos - UDim2.fromOffset(8, 0)}, 0.05); task.wait(0.05) end; utility:Tween(element, {Position = originalPos}, 0.05) end
        local connectionSubmit, connectionFocusLost; local isSubmitting = false
        local handleSubmit = function() if isSubmitting then return end; isSubmitting = true; local enteredKey = keyInput.Text; local correctKey = "hh.hg**@@"; if enteredKey == correctKey then if connectionSubmit then connectionSubmit:Disconnect(); connectionSubmit = nil end; if connectionFocusLost then connectionFocusLost:Disconnect(); connectionFocusLost = nil end; utility:Tween(main, {Position = UDim2.new(0.5, 0, 1.5, 0)}, 0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In); task.wait(0.3); if keyPromptScreen and keyPromptScreen.Parent then keyPromptScreen:Destroy() end; if blur and blur.Parent then blur:Destroy() end; pcall(...) else shakeElement(main); if keyInput and keyInput.Parent then keyInput.Text = ""; keyInput.PlaceholderText = "Incorrect key!" end; task.spawn(function() task.wait(1.5); if keyInput and keyInput.Parent then keyInput.PlaceholderText = "Enter key..." end end); isSubmitting = false end end
        connectionSubmit = submitButton.MouseButton1Click:Connect(handleSubmit)
        connectionFocusLost = keyInput.FocusLost:Connect(function(enterPressed) if enterPressed then handleSubmit() end end)
    end

end -- End of Utility Functions block


-- classes
local library = {}
local page = {}
local section = {}

do -- Class implementations block
	library.__index = library
	page.__index = page
	section.__index = section

	-- library.new (Keep improved version)
	function library.new(...)
        --[[ Paste the improved library.new function here ]]
        local self = setmetatable({ container = nil, pagesContainer = nil, pageContentContainer = nil, pages = {}, focusedPage = nil, notificationContainer = nil, toggling = false, position = nil, watermarkScreenGui = nil, watermarkElements = {}, fpsUpdaterRunning = false, fpsWatermarkControls = nil, keybindsInitialized = false }, library)
		print("-- SC UI Initializing... --"); local keyEnteredEvent = Instance.new("BindableEvent"); utility:KeyPrompt(function() keyEnteredEvent:Fire() end); keyEnteredEvent.Event:Wait(); keyEnteredEvent:Destroy(); local title = ... or "SC UI"; local container = utility:Create("ScreenGui", { Name = title, Parent = CoreGui, ZIndexBehavior = Enum.ZIndexBehavior.Sibling, Enabled = false, ResetOnSpawn = false }); self.container = container; local mainFrame = utility:Create("ImageLabel", { Name = "Main", Parent = container, BackgroundTransparency = 1, Position = UDim2.new(0.25, 0, 0.05, 0), Size = UDim2.new(0, 511, 0, 428), Image = "rbxassetid://4641149554", ImageColor3 = themes.Background, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(4, 4, 296, 296) }); self.pageContentContainer = mainFrame; if not mainFrame or not mainFrame.Parent then warn("[SCUI Error] Failed to create Main UI Frame."); if container and container.Parent then container:Destroy() end; return nil end; local mainChildren = { utility:Create("ImageLabel", { Name = "Glow", BackgroundTransparency = 1, Position = UDim2.new(0, -18, 0, -18), Size = UDim2.new(1, 36, 1, 36), ZIndex = 0, Image = "rbxassetid://5028857084", ImageColor3 = themes.Glow, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(24, 24, 276, 276) }), utility:Create("ImageLabel", { Name = "Pages", BackgroundTransparency = 1, ClipsDescendants = true, Position = UDim2.new(0, 0, 0, 38), Size = UDim2.new(0, 126, 1, -38), ZIndex = 3, Image = "rbxassetid://5012534273", ImageColor3 = themes.DarkContrast, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(4, 4, 296, 296) }, { utility:Create("ScrollingFrame", { Name = "Pages_Container", Active = true, BackgroundTransparency = 1, Position = UDim2.new(0, 0, 0, 0), Size = UDim2.new(1, 0, 1, 0), CanvasSize = UDim2.new(0, 0, 0, 0), AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollBarThickness = 4, ScrollBarImageColor3 = themes.Accent }, { utility:Create("UIListLayout", { Name = "PageButtonLayout", SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 10), FillDirection = Enum.FillDirection.Vertical, HorizontalAlignment = Enum.HorizontalAlignment.Center, VerticalAlignment = Enum.VerticalAlignment.Top }), utility:Create("UIPadding", { PaddingTop = UDim.new(0, 10), PaddingBottom = UDim.new(0, 10) }) }) }), utility:Create("ImageLabel", { Name = "TopBar", BackgroundTransparency = 1, ClipsDescendants = true, Size = UDim2.new(1, 0, 0, 38), Position = UDim2.new(0,0,0,0), ZIndex = 5, Image = "rbxassetid://4595286933", ImageColor3 = themes.Accent, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(4, 4, 296, 296) }, { utility:Create("TextLabel", { Name = "Title", AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1, Position = UDim2.new(0, 12, 0.5, 0), Size = UDim2.new(1, -46, 0, 16), ZIndex = 5, Font = Enum.Font.GothamBold, Text = title, TextColor3 = themes.TextColor, TextSize = 14, TextXAlignment = Enum.TextXAlignment.Left }) }) }; for _, child in ipairs(mainChildren) do if child then child.Parent = mainFrame end end; self.pagesContainer = mainFrame:FindFirstChild("Pages_Container", true); local notificationContainer = utility:Create("Frame", { Name = "NotificationContainer", Parent = container, BackgroundTransparency = 1, Size = UDim2.new(0, 250, 0, 300), Position = UDim2.new(1, -260, 0, 10), ZIndex = 100, ClipsDescendants = true }, { utility:Create("UIListLayout", { Name = "Layout", SortOrder = Enum.SortOrder.LayoutOrder, FillDirection = Enum.FillDirection.Vertical, HorizontalAlignment = Enum.HorizontalAlignment.Right, VerticalAlignment = Enum.VerticalAlignment.Top, Padding = UDim.new(0, 5) }) }); self.notificationContainer = notificationContainer; pcall(utility.InitializeKeybind, self); local topBar = mainFrame:FindFirstChild("TopBar"); if topBar then pcall(utility.DraggingEnabled, self, topBar, mainFrame) end; task.spawn(function() pcall(self.Watermark, self) end); task.delay(0.5, function() pcall(self.Notify, self, "Welcome!", "SC UI Initialized.", { type = "success", duration = 3 }) end); container.Enabled = true; mainFrame.BackgroundTransparency = 1; local glow = mainFrame:FindFirstChild("Glow"); local pagesFrame = mainFrame:FindFirstChild("Pages"); if glow then glow.ImageTransparency = 1 end; if pagesFrame then pagesFrame.ImageTransparency = 1 end; if topBar then topBar.ImageTransparency = 1 end; utility:Tween(mainFrame, { BackgroundTransparency = 0 }, 0.3); if glow then utility:Tween(glow, { ImageTransparency = 0 }, 0.3) end; if pagesFrame then utility:Tween(pagesFrame, { ImageTransparency = 0 }, 0.3) end; if topBar then utility:Tween(topBar, { ImageTransparency = 0 }, 0.3) end; return self
	end

	-- page.new (Keep improved version)
	function page.new(...)
        --[[ Paste the improved page.new function here ]]
        local library, title, icon = ...; local theme = themes; local contentContainer = utility:Create("ScrollingFrame", { Name = title .. "_Content", Parent = library.pageContentContainer, Active = true, BackgroundTransparency = 1, BorderSizePixel = 0, Position = UDim2.new(0, 126, 0, 38), Size = UDim2.new(1, -126, 1, -38), CanvasSize = UDim2.new(0, 0, 0, 0), AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollBarThickness = 4, ScrollBarImageColor3 = theme.Accent, Visible = false, ZIndex = 2 }, { utility:Create("UIListLayout", { Name = "SectionLayout", SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 10), FillDirection = Enum.FillDirection.Vertical, HorizontalAlignment = Enum.HorizontalAlignment.Center, VerticalAlignment = Enum.VerticalAlignment.Top }), utility:Create("UIPadding", { PaddingLeft = UDim.new(0, 8), PaddingRight = UDim.new(0, 8), PaddingTop = UDim.new(0, 8), PaddingBottom = UDim.new(0, 8) }) }); local buttonChildren = { utility:Create("TextLabel", { Name = "Title", AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1, Position = UDim2.new(0, icon and 40 or 15, 0.5, 0), Size = UDim2.new(1, -(icon and 45 or 20), 1, 0), ZIndex = 3, Font = Enum.Font.Gotham, Text = title, TextColor3 = theme.TextColor, TextSize = 12, TextTransparency = 0.65, TextXAlignment = Enum.TextXAlignment.Left }), utility:Create("Frame", { Name = "HoverBG", BackgroundTransparency = 1, BackgroundColor3 = theme.LightContrast, Size = UDim2.new(1, 0, 1, 0), ZIndex = 1, Visible = false }) }; if icon then table.insert(buttonChildren, 1, utility:Create("ImageLabel", { Name = "Icon", AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1, Position = UDim2.new(0, 15, 0.5, 0), Size = UDim2.new(0, 16, 0, 16), ZIndex = 3, Image = icon, ImageColor3 = theme.TextColor, ImageTransparency = 0.65 })) end; local button = utility:Create("TextButton", { Name = title .. "_Button", Parent = library.pagesContainer, BackgroundTransparency = 1, BorderSizePixel = 0, Size = UDim2.new(1, -10, 0, 26), Position = UDim2.new(0.5, 0, 0, 0), AnchorPoint = Vector2.new(0.5, 0), ZIndex = 3, AutoButtonColor = false, Text = "", LayoutOrder = #library.pages + 1 }, buttonChildren); local pageInstance = setmetatable({ library = library, container = contentContainer, button = button, sections = {}, lastScrollPosition = 0 }, page); local hoverBG = button:FindFirstChild("HoverBG"); if hoverBG then button.MouseEnter:Connect(function() if library.focusedPage ~= pageInstance then hoverBG.BackgroundTransparency = 0.8; hoverBG.Visible = true end end); button.MouseLeave:Connect(function() if library.focusedPage ~= pageInstance then hoverBG.Visible = false end end) end; button.MouseButton1Click:Connect(function() library:SelectPage(pageInstance) end); return pageInstance
	end

	-- section.new (Keep improved version)
	function section.new(...)
        --[[ Paste the improved section.new function here ]]
        local page, title = ...; local theme = themes; local sectionFrame = utility:Create("ImageLabel", { Name = title .. "_Section", Parent = page.container, BackgroundTransparency = 1, AutomaticSize = Enum.AutomaticSize.Y, Size = UDim2.new(1, 0, 0, 30), ZIndex = 2, Image = "rbxassetid://5028857472", ImageColor3 = theme.LightContrast:Lerp(theme.Background, 0.1), ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(4, 4, 296, 296), ClipsDescendants = true, LayoutOrder = #page.sections + 1 }); local moduleContainer = utility:Create("Frame", { Name = "Container", Parent = sectionFrame, BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), AutomaticSize = Enum.AutomaticSize.Y }); local moduleContainerChildren = { utility:Create("UIPadding", { PaddingLeft = UDim.new(0, 8), PaddingRight = UDim.new(0, 8), PaddingTop = UDim.new(0, 8), PaddingBottom = UDim.new(0, 8) }), utility:Create("TextLabel", { Name = "Title", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 20), AutomaticSize = Enum.AutomaticSize.Y, ZIndex = 2, Font = Enum.Font.GothamSemibold, Text = title, TextColor3 = theme.TextColor, TextSize = 12, TextXAlignment = Enum.TextXAlignment.Left, TextWrapped = true, LayoutOrder = 0 }), utility:Create("UIListLayout", { Name = "ModuleLayout", SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 6), FillDirection = Enum.FillDirection.Vertical, HorizontalAlignment = Enum.HorizontalAlignment.Center, VerticalAlignment = Enum.VerticalAlignment.Top, ItemLineAlignment = Enum.ItemLineAlignment.Width, LayoutOrder = 1 }) }; for _, child in ipairs(moduleContainerChildren) do if child then child.Parent = moduleContainer end end; local sectionInstance = setmetatable({ page = page, container = moduleContainer, frame = sectionFrame }, section); task.wait(); sectionInstance:Resize(); return sectionInstance
	end

	-- Library Methods (Keep improved versions)
	function library:addPage(...) --[[ Paste improved library:addPage here ]]
        local title, icon = ...; local newPage = page.new(self, title, icon); if newPage then table.insert(self.pages, newPage); if #self.pages == 1 then self:SelectPage(newPage) end; return newPage else warn("[SCUI Error] Failed to create page:", title); return nil end
    end
	function library:setTheme(...) --[[ Paste improved library:setTheme here ]]
        local themeName, color3 = ...; if not themes[themeName] then warn("[SCUI Warning] Theme '"..tostring(themeName).."' does not exist."); return end; themes[themeName] = color3; if objects[themeName] then for property, weakObjMap in pairs(objects[themeName]) do for objectRef, _ in pairs(weakObjMap) do if objectRef and objectRef.Parent then local success, err = pcall(function() objectRef[property] = color3 end); if not success then warn("[SCUI Theme Error] Failed to set", property, "on", objectRef:GetFullName(), "-", err) end else weakObjMap[objectRef] = nil end end end end
    end
	function library:toggle(...) --[[ Paste improved library:toggle here ]]
        if self.toggling or not self.container or not self.container.Parent then return end; self.toggling = true; local mainFrame = self.container:FindFirstChild("Main"); if not mainFrame then self.toggling = false; return end; if self.position then mainFrame.ClipsDescendants = false; utility:Tween(mainFrame, { Size = UDim2.new(0, 511, 0, 428), Position = self.position }, 0.2); self.position = nil else self.position = mainFrame.Position; utility:Tween(mainFrame, { Size = UDim2.new(0, 511, 0, 38), }, 0.2); task.wait(0.2); mainFrame.ClipsDescendants = true end; task.delay(0.3, function() self.toggling = false end)
    end
	function library:Watermark(...) --[[ Paste your Watermark function here, ensure task.wait/spawn ]]
        if not self.container or not self.container.Parent then warn("[SCUI Warning] Cannot create watermark, main container missing."); return nil end; print("[SCUI Info] Watermark function called."); return { AddWatermark = function() return { Hide=function()end, Show=function()end, Text=function()end, Remove=function()end } end, Remove=function()end }
    end
	function library:Notify(...) --[[ Paste your Notify function here, ensure task.wait/spawn ]]
        if not self.notificationContainer or not self.notificationContainer.Parent then warn("[SCUI Warning] Notification container not found."); return end; print("[SCUI Info] Notify function called."); -- ... Your Notify logic ...
    end
	function library:SelectPage(...) --[[ Paste improved library:SelectPage here ]]
        local pageToSelect = ...; if not pageToSelect or self.focusedPage == pageToSelect then return end; local found = false; for _, p in ipairs(self.pages) do if p == pageToSelect then found = true; break end end; if not found then warn("[SCUI Warning] Attempted to select unregistered page."); return end; local previouslyFocused = self.focusedPage; self.focusedPage = pageToSelect; for _, pageInstance in ipairs(self.pages) do local isSelected = (pageInstance == pageToSelect); local button = pageInstance.button; local container = pageInstance.container; if container and container.Parent then if not isSelected and container.Visible and previouslyFocused == pageInstance then pageInstance.lastScrollPosition = container.CanvasPosition.Y end; container.Visible = isSelected end; if button and button.Parent then local titleLabel = button:FindFirstChild("Title"); local iconLabel = button:FindFirstChild("Icon"); local hoverBG = button:FindFirstChild("HoverBG"); if titleLabel then titleLabel.TextTransparency = isSelected and 0 or 0.65; titleLabel.Font = isSelected and Enum.Font.GothamSemibold or Enum.Font.Gotham end; if iconLabel then iconLabel.ImageTransparency = isSelected and 0 or 0.65 end; if hoverBG then hoverBG.Visible = isSelected; if isSelected then hoverBG.BackgroundTransparency = 0 end end end end; if pageToSelect.container and pageToSelect.container.Parent then task.defer(pageToSelect.Resize, pageToSelect, true) end
    end

	-- Page Methods (Keep improved versions)
	function page:addSection(...) --[[ Paste improved page:addSection here ]]
        local title = ...; local newSection = section.new(self, title); if newSection then table.insert(self.sections, newSection); return newSection else warn("[SCUI Error] Failed to create section:", title, "on page:", self.button and self.button.Name or "Unknown"); return nil end
    end
	function page:Resize(...) --[[ Paste improved page:Resize here ]]
        if not self.container or not self.container.Parent then return end; local applyScroll = ...; if applyScroll then local targetY = self.lastScrollPosition or 0; local maxScroll = self.container.CanvasSize.Y.Offset - self.container.AbsoluteSize.Y; targetY = math.clamp(targetY, 0, math.max(0, maxScroll)); utility:Tween(self.container, { CanvasPosition = Vector2.new(0, targetY) }, 0.2) end; task.delay(0.1, function() if self.container and self.container.Parent then local contentHeight = self.container.CanvasSize.Y.Offset; local viewHeight = self.container.AbsoluteSize.Y; self.container.ScrollBarImageTransparency = contentHeight <= viewHeight and 1 or 0 end end)
    end

	-- Section Methods --

	function section:Resize(...) --[[ Paste improved section:Resize here ]]
        if self.page and self.page.Resize then task.delay(0.05, function() if self.page and self.page.Resize then self.page:Resize() end end) end
    end
	function section:getModule(...) --[[ Paste improved section:getModule here ]]
        local info = ...; if not self.container or not self.container.Parent then return nil end; if typeof(info) == "Instance" and info:IsDescendantOf(self.container) then return info end; if typeof(info) == "string" then local potentialName = (info:match("^[A-Za-z]+_") and info) or ("Button_"..info:gsub("%s+","")); local found = self.container:FindFirstChild(potentialName); if found then return found end; for _, moduleFrame in ipairs(self.container:GetChildren()) do local titleSource = moduleFrame:FindFirstChild("Title") or moduleFrame:FindFirstChildWhichIsA("TextBox"); if titleSource and titleSource.Text == info then return moduleFrame end; local searchBox = moduleFrame:FindFirstChild("Search", true); if searchBox and searchBox:IsA("ImageLabel") then local dropTextBox = searchBox:FindFirstChild("TextBox"); if dropTextBox and dropTextBox.Text == info then return moduleFrame end end end end; warn("[SCUI Warning] Module not found:", tostring(info), "in section:", self.frame.Name); return nil
    end
	function section:updateButton(...) --[[ Paste improved section:updateButton here ]]
        local button, title = ...; button = self:getModule(button); if not button or not button.Parent then return end; local textLabel = button:FindFirstChild("Title"); if textLabel and title then textLabel.Text = title end
    end
	function section:updateToggle(...) --[[ Paste improved section:updateToggle here ]]
         local toggleFrame, title, value = ...; toggleFrame = self:getModule(toggleFrame); if not toggleFrame or not toggleFrame.Parent then return end; local titleLabel = toggleFrame:FindFirstChild("Title"); local switchButton = toggleFrame:FindFirstChild("Switch"); local knob = switchButton and switchButton:FindFirstChild("Knob"); if not titleLabel or not switchButton or not knob then return end; if title then titleLabel.Text = title end; if type(value) == "boolean" then local theme = themes; local buttonSize = switchButton.AbsoluteSize; local knobSize = knob.AbsoluteSize; local targetX = value and (buttonSize.X - knobSize.X/2 - 2) or (knobSize.X/2 + 2); local targetPos = UDim2.new(0, targetX, 0.5, 0); local targetColor = value and theme.NotifSuccess or theme.LightContrast; utility:Tween(knob, { Position = targetPos }, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out); utility:Tween(switchButton, { ImageColor3 = targetColor }, 0.15) end
    end
	function section:addButton(...) --[[ Paste improved section:addButton here ]]
        local title, callback = ...; local theme = themes; local button = utility:Create("ImageButton", { Name = "Button_" .. title:gsub("%s+", ""), Parent = self.container, BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 30), ZIndex = 2, Image = "rbxassetid://5028857472", ImageColor3 = theme.DarkContrast, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298), AutoButtonColor = false, LayoutOrder = #self.container:GetChildren() }, { utility:Create("TextLabel", { Name = "Title", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), ZIndex = 3, Font = Enum.Font.Gotham, Text = title, TextColor3 = theme.TextColor, TextSize = 12, TextTransparency = 0.1 }), utility:Create("UICorner", { CornerRadius = UDim.new(0, 3) }) }); local debounce = false; button.MouseButton1Click:Connect(function() if debounce then return end; debounce = true; utility:Pop(button, 6); local text = button:FindFirstChild("Title"); if text then local tween1 = utility:Tween(text, {TextSize = 13}, 0.1); if tween1 then tween1.Completed:Wait() end; local tween2 = utility:Tween(text, {TextSize = 12}, 0.1) end; if callback then local updateFunc = function(newTitle) if button and button.Parent and text then text.Text = newTitle or title end end; task.spawn(callback, updateFunc) end; task.delay(0.3, function() debounce = false end) end); self:Resize(); return button
    end
	function section:addToggle(...) --[[ Paste improved section:addToggle here ]]
        local title, default, callback = ...; local theme = themes; local toggleFrame = utility:Create("Frame", { Name = "Toggle_"..title:gsub("%s+", ""), Parent = self.container, BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 30), LayoutOrder = #self.container:GetChildren() }); utility:Create("TextLabel", { Name = "Title", Parent = toggleFrame, AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0.5, 0), Size = UDim2.new(1, -65, 1, -4), ZIndex = 3, Font = Enum.Font.Gotham, Text = title, TextColor3 = theme.TextColor, TextSize = 12, TextTransparency = 0.1, TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Center }); local buttonSize = Vector2.new(40, 16); local switchButton = utility:Create("ImageButton", { Name = "Switch", Parent = toggleFrame, AnchorPoint = Vector2.new(1, 0.5), Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.fromOffset(buttonSize.X, buttonSize.Y), ZIndex = 2, Image = "rbxassetid://5028857472", ImageColor3 = theme.LightContrast, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298), AutoButtonColor = false }, { utility:Create("UICorner", { CornerRadius = UDim.new(1, 0) }), utility:Create("Frame", { Name = "Knob", AnchorPoint = Vector2.new(0.5, 0.5), Size = UDim2.fromOffset(buttonSize.Y - 4, buttonSize.Y - 4), Position = UDim2.new(0, (buttonSize.Y - 4)/2 + 2, 0.5, 0), BackgroundColor3 = theme.TextColor, ZIndex = 3, BorderSizePixel = 0 }, { utility:Create("UICorner", { CornerRadius = UDim.new(1, 0) }) }) }); local knob = switchButton:FindFirstChild("Knob"); local active = default or false; local function updateVisuals(isOn) if not knob or not knob.Parent or not switchButton or not switchButton.Parent then return end; local knobSize = knob.AbsoluteSize; local targetX = isOn and (buttonSize.X - knobSize.X/2 - 2) or (knobSize.X/2 + 2); local targetPos = UDim2.new(0, targetX, 0.5, 0); local targetColor = isOn and theme.NotifSuccess or theme.LightContrast; utility:Tween(knob, { Position = targetPos }, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out); utility:Tween(switchButton, { ImageColor3 = targetColor }, 0.15) end; updateVisuals(active); switchButton.MouseButton1Click:Connect(function() active = not active; updateVisuals(active); if callback then local updateFunc = function(forceState) if type(forceState) == "boolean" and forceState ~= active then active = forceState; updateVisuals(active) end end; task.spawn(callback, active, updateFunc) end end); self:Resize(); return toggleFrame
    end

    -- ADD MISSING MODULES HERE --

	function section:addTextbox(title, default, callback)
        local theme = themes
        -- Frame to hold the textbox elements
        local textboxFrame = utility:Create("Frame", {
            Name = "Textbox_"..title:gsub("%s+", ""), Parent = self.container,
            BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 30),
            LayoutOrder = #self.container:GetChildren()
        })

        -- Title Label
        utility:Create("TextLabel", {
            Name = "Title", Parent = textboxFrame,
            AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1,
            Position = UDim2.new(0, 10, 0.5, 0), Size = UDim2.new(0.5, 0, 1, -4), -- Half width approx
            ZIndex = 3, Font = Enum.Font.Gotham, Text = title, TextColor3 = theme.TextColor,
            TextSize = 12, TextTransparency = 0.1,
            TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Center
        })

        -- Input Area Background (ImageLabel for styling)
        local inputBg = utility:Create("ImageLabel", {
            Name = "InputBg", Parent = textboxFrame,
            AnchorPoint = Vector2.new(1, 0.5), BackgroundTransparency = 1,
            Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 100, 0, 18), -- Default size
            ZIndex = 2, Image = "rbxassetid://5028857472", ImageColor3 = theme.LightContrast,
            ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298)
        }, {
            utility:Create("UICorner", { CornerRadius = UDim.new(0, 3) }),
            utility:Create("TextBox", {
                Name = "Input", BackgroundTransparency = 1,
                Position = UDim2.new(0.5, 0, 0.5, 0), AnchorPoint = Vector2.new(0.5, 0.5),
                Size = UDim2.new(1, -10, 1, -4), -- Padding inside
                ZIndex = 3, Font = Enum.Font.GothamSemibold,
                Text = default or "", PlaceholderText = "...", PlaceholderColor3 = theme.TextColor:Lerp(theme.Background, 0.6),
                TextColor3 = theme.TextColor, TextSize = 11,
                ClearTextOnFocus = false, -- Keep text on focus
                TextXAlignment = Enum.TextXAlignment.Center -- Start centered
            })
        })

        local input = inputBg:FindFirstChild("Input")
        local isEditing = false
        local originalSize = inputBg.Size
        local expandedSize = UDim2.new(0, 200, 0, 18) -- Size when focused

        -- Expand on focus
        input.Focused:Connect(function()
            isEditing = true
            utility:Tween(inputBg, { Size = expandedSize }, 0.2)
            input.TextXAlignment = Enum.TextXAlignment.Left -- Align left when editing
        end)

        -- Text changed callback
        input.Changed:Connect(function(property)
            if property == "Text" and isEditing and callback then
                -- Pop animation only if editing?
                -- utility:Pop(inputBg, 4) -- Maybe too much?
                local updateFunc = function(newTitle, newValue)
                    if textboxFrame and textboxFrame.Parent then
                         local titleLabel = textboxFrame:FindFirstChild("Title")
                         if titleLabel and newTitle then titleLabel.Text = newTitle end
                         if input and input.Parent and newValue then input.Text = newValue end
                    end
                end
                task.spawn(callback, input.Text, false, updateFunc) -- Pass text, editing=false, update func
            end
        end)

        -- Shrink on focus lost, trigger callback finalized
        input.FocusLost:Connect(function(enterPressed)
            isEditing = false
            utility:Tween(inputBg, { Size = originalSize }, 0.2)
            input.TextXAlignment = Enum.TextXAlignment.Center -- Re-center text

            if callback then
                local updateFunc = function(newTitle, newValue)
                     if textboxFrame and textboxFrame.Parent then
                         local titleLabel = textboxFrame:FindFirstChild("Title")
                         if titleLabel and newTitle then titleLabel.Text = newTitle end
                         if input and input.Parent and newValue then input.Text = newValue end
                    end
                end
                task.spawn(callback, input.Text, true, updateFunc) -- Pass text, editing=true (finalized), update func
            end
        end)

        self:Resize()
		return textboxFrame
	end

	function section:addKeybind(title, defaultKeyCode, callback, changedCallback)
        local theme = themes
        -- Base Frame
        local keybindFrame = utility:Create("Frame", {
            Name = "Keybind_"..title:gsub("%s+", ""), Parent = self.container,
            BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 30),
            LayoutOrder = #self.container:GetChildren()
        })

        -- Title Label
        utility:Create("TextLabel", {
            Name = "Title", Parent = keybindFrame,
            AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1,
            Position = UDim2.new(0, 10, 0.5, 0), Size = UDim2.new(1, -115, 1, -4), -- Leave space for button
            ZIndex = 3, Font = Enum.Font.Gotham, Text = title, TextColor3 = theme.TextColor,
            TextSize = 12, TextTransparency = 0.1,
            TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Center
        })

        -- Keybind Button (displays current key)
        local keyButton = utility:Create("ImageButton", {
            Name = "KeyButton", Parent = keybindFrame,
            AnchorPoint = Vector2.new(1, 0.5), BackgroundTransparency = 1,
            Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 100, 0, 18),
            ZIndex = 2, Image = "rbxassetid://5028857472", ImageColor3 = theme.LightContrast,
            ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298),
            AutoButtonColor = false
        }, {
            utility:Create("UICorner", { CornerRadius = UDim.new(0, 3) }),
            utility:Create("TextLabel", {
                Name = "KeyText", BackgroundTransparency = 1,
                Size = UDim2.new(1, -10, 1, 0), Position = UDim2.new(0.5, 0, 0.5, 0), AnchorPoint = Vector2.new(0.5, 0.5),
                ZIndex = 3, Font = Enum.Font.GothamSemibold,
                Text = (defaultKeyCode and defaultKeyCode.Name) or "None", -- Initial text
                TextColor3 = theme.TextColor, TextSize = 11
            })
        })

        local keyText = keyButton:FindFirstChild("KeyText")
        local currentBind = nil -- Stores the bind object from utility:BindToKey
        local currentKeyCode = defaultKeyCode -- Stores the actual KeyCode enum

        -- Function to update the keybind
        local function updateBind(newKeyCode)
            if currentBind then currentBind:UnBind(); currentBind = nil end -- Unbind previous

            currentKeyCode = newKeyCode -- Update stored KeyCode
            if keyText and keyText.Parent then -- Update display text
                keyText.Text = (newKeyCode and newKeyCode.Name) or "None"
            end

            if newKeyCode and callback then -- Bind new key if valid and callback exists
                currentBind = utility:BindToKey(newKeyCode, function()
                    -- Provide update function to the main callback
                    local updateFunc = function(newTitle, newKey)
                        if keybindFrame and keybindFrame.Parent then
                             local titleLabel = keybindFrame:FindFirstChild("Title")
                             if titleLabel and newTitle then titleLabel.Text = newTitle end
                             -- If newKey is provided, update the whole bind
                             if newKey ~= nil then updateBind(newKey) end
                        end
                    end
                    task.spawn(callback, updateFunc) -- Call the original callback
                end)
            end

            -- Call the changedCallback if it exists
            if changedCallback then
                 local updateFunc = function(newTitle, newKey)
                     if keybindFrame and keybindFrame.Parent then
                         local titleLabel = keybindFrame:FindFirstChild("Title")
                         if titleLabel and newTitle then titleLabel.Text = newTitle end
                         if newKey ~= nil then updateBind(newKey) end
                     end
                 end
                task.spawn(changedCallback, newKeyCode, updateFunc)
            end
        end

        -- Initialize the first bind
        updateBind(currentKeyCode)

        -- Handle Button Click to Capture Next Key
        local isBinding = false
        keyButton.MouseButton1Click:Connect(function()
            if isBinding then return end
            isBinding = true

            utility:Pop(keyButton, 4)
            if keyText then keyText.Text = "..." end

            -- Use task.spawn to wait for keypress without blocking
            task.spawn(function()
                local keyInputObject = utility:KeyPressed() -- Wait for a valid key
                isBinding = false -- Reset binding state

                if keyInputObject.KeyCode == Enum.KeyCode.Delete or keyInputObject.KeyCode == Enum.KeyCode.Backspace then
                    updateBind(nil) -- Clear bind
                else
                    updateBind(keyInputObject.KeyCode) -- Set new bind
                end
                 utility:Pop(keyButton, 4) -- Pop again after setting
            end)
        end)

        self:Resize()
		return keybindFrame
	end

	function section:addColorPicker(title, defaultColor, callback)
        local theme = themes
        -- Base Frame
        local cpFrame = utility:Create("Frame", {
            Name = "ColorPicker_"..title:gsub("%s+", ""), Parent = self.container,
            BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 30),
            LayoutOrder = #self.container:GetChildren()
        })

        -- Title Label
        utility:Create("TextLabel", {
            Name = "Title", Parent = cpFrame,
            AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1,
            Position = UDim2.new(0, 10, 0.5, 0), Size = UDim2.new(1, -65, 1, -4),
            ZIndex = 3, Font = Enum.Font.Gotham, Text = title, TextColor3 = theme.TextColor,
            TextSize = 12, TextTransparency = 0.1,
            TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Center
        })

        -- Color Preview Button
        local colorButton = utility:Create("ImageButton", {
            Name = "ColorButton", Parent = cpFrame,
            AnchorPoint = Vector2.new(1, 0.5), BackgroundTransparency = 1,
            Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 40, 0, 18),
            ZIndex = 2, Image = "rbxassetid://5028857472", -- Use square texture
            ImageColor3 = defaultColor or Color3.new(1,1,1), -- Initial color
            ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298), -- Or Fit? Test Slice
            AutoButtonColor = false
        }, {
            utility:Create("UICorner", { CornerRadius = UDim.new(0, 3) }),
            utility:Create("UIStroke", { Color = theme.LightContrast, Thickness = 1}) -- Border
        })

        -- Color Picker Popup (Initially Hidden)
        -- This part is complex, using the structure from your original code but adapted
        local popupSize = Vector2.new(162, 185) -- Adjusted size for Alpha input
        local pickerPopup = utility:Create("ImageLabel", {
			Name = "PickerPopup", Parent = self.page.library.container, -- Parent to main ScreenGui
			BackgroundTransparency = 1, Selectable = true, Visible = false, -- Start hidden
			AnchorPoint = Vector2.new(0, 0), -- Position relative to button later
			Size = UDim2.fromOffset(popupSize.X, popupSize.Y),
			Image = "rbxassetid://5028857472", ImageColor3 = theme.Background,
			ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(4, 4, 296, 296),
            ZIndex = 200 -- High ZIndex
		})

        -- Add Dragging to Popup
        utility:DraggingEnabled(pickerPopup)

        -- Popup Contents
        local popupChildren = {
            utility:Create("ImageLabel", { Name = "Glow", BackgroundTransparency = 1, Position = UDim2.new(0, -15, 0, -15), Size = UDim2.new(1, 30, 1, 30), ZIndex = 0, Image = "rbxassetid://5028857084", ImageColor3 = theme.Glow, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(22, 22, 278, 278) }),
			utility:Create("TextLabel", { Name = "PopupTitle", BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 8), Size = UDim2.new(1, -40, 0, 16), ZIndex = 2, Font = Enum.Font.GothamSemibold, Text = title, TextColor3 = theme.TextColor, TextSize = 14, TextXAlignment = Enum.TextXAlignment.Left }),
			utility:Create("ImageButton", { Name = "Close", BackgroundTransparency = 1, Position = UDim2.new(1, -26, 0, 8), Size = UDim2.new(0, 16, 0, 16), ZIndex = 2, Image = "rbxassetid://5012538583", ImageColor3 = theme.TextColor, AutoButtonColor = false }),
			utility:Create("Frame", { Name = "Container", BackgroundTransparency = 1, Position = UDim2.new(0, 8, 0, 32), Size = UDim2.new(1, -16, 1, -40) }, { -- Changed padding
				utility:Create("UIListLayout", { SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 6) }),
                -- Saturation/Value Canvas
				utility:Create("ImageButton", { Name = "Canvas", BackgroundTransparency = 1, BorderColor3 = theme.LightContrast, Size = UDim2.new(1, 0, 0, 60), AutoButtonColor = false, Image = "rbxassetid://5108535320", ImageColor3 = Color3.new(1, 0, 0), ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298) }, {
					utility:Create("ImageLabel", { Name = "White_Overlay", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Image = "rbxassetid://5107152351", ScaleType=Enum.ScaleType.Slice, SliceCenter = Rect.new(2,2,298,298)}), -- Corrected size/slice
					utility:Create("ImageLabel", { Name = "Black_Overlay", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Image = "rbxassetid://5107152095", ScaleType=Enum.ScaleType.Slice, SliceCenter = Rect.new(2,2,298,298)}),
					utility:Create("ImageLabel", { Name = "Cursor", BackgroundColor3 = theme.TextColor, AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, Size = UDim2.new(0, 10, 0, 10), Position = UDim2.new(1, 0, 0, 0), Image = "rbxassetid://5100115962", ScaleType=Enum.ScaleType.Slice, SliceCenter = Rect.new(2,2,298,298) }) -- Start top right
				}),
                -- Hue Slider
				utility:Create("ImageButton", { Name = "ColorSlider", BackgroundTransparency = 1, BorderSizePixel = 0, Size = UDim2.new(1, 0, 0, 16), AutoButtonColor = false, Image = "rbxassetid://5028857472", ImageColor3=theme.LightContrast, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298) }, {
					utility:Create("Frame", { Name = "Select", BackgroundColor3 = theme.TextColor, BorderSizePixel = 1, Position = UDim2.new(0, 0, 0, 0), Size = UDim2.new(0, 2, 1, 0), ZIndex = 2 }),
					utility:Create("UIGradient", { Color = ColorSequence.new({ ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 0, 0)), ColorSequenceKeypoint.new(0.17, Color3.fromRGB(255, 255, 0)), ColorSequenceKeypoint.new(0.33, Color3.fromRGB(0, 255, 0)), ColorSequenceKeypoint.new(0.50, Color3.fromRGB(0, 255, 255)), ColorSequenceKeypoint.new(0.66, Color3.fromRGB(0, 0, 255)), ColorSequenceKeypoint.new(0.82, Color3.fromRGB(255, 0, 255)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 0, 0)) }) })
				}),
				-- Alpha Slider (Added)
				utility:Create("ImageButton", { Name = "AlphaSlider", BackgroundTransparency = 1, BorderSizePixel = 0, Size = UDim2.new(1, 0, 0, 16), ZIndex = 2, Image = "rbxassetid://5028857472", ImageColor3 = theme.LightContrast, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298), AutoButtonColor = false }, {
                    utility:Create("ImageLabel", { Name = "Checkered", BackgroundTransparency = 0, Size = UDim2.new(1,0,1,0), Image = "rbxassetid://5107152879", ImageColor3=Color3.fromRGB(120,120,120), ImageTransparency=0.5, TileSize=UDim2.new(0,10,0,10), ZIndex = 2 }), -- Checkered Background
                    utility:Create("ImageLabel", { Name = "Fill", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), ZIndex = 3, Image = "rbxassetid://5028857472", ImageColor3 = theme.TextColor, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298) }),
                    utility:Create("UIGradient", { Name="AlphaGradient", Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1), NumberSequenceKeypoint.new(1,0)}), Rotation=90, ZIndex=4 }), -- Alpha gradient on Fill
					utility:Create("Frame", { Name = "Select", BackgroundColor3 = theme.TextColor, BorderSizePixel = 1, Position = UDim2.new(1, 0, 0, 0), Size = UDim2.new(0, 2, 1, 0), ZIndex = 5 })
				}),
                -- RGBA Input Fields Frame
				utility:Create("Frame", { Name = "Inputs", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 18) }, { -- Height adjusted
					utility:Create("UIListLayout", { FillDirection = Enum.FillDirection.Horizontal, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 4), VerticalAlignment=Enum.VerticalAlignment.Center }),
                    -- R, G, B, A Input fields (each in an ImageLabel bg)
                    utility:Create("ImageLabel",{Name="R",BackgroundTransparency=1,Size=UDim2.new(0.23,0,1,0),Image="rbxassetid://5028857472",ImageColor3=theme.DarkContrast,ScaleType=Enum.ScaleType.Slice,SliceCenter=Rect.new(2,2,298,298)},{utility:Create("TextLabel",{Name="Label",BackgroundTransparency=1,Size=UDim2.new(0.3,0,1,0),Font=Enum.Font.Gotham,Text="R",TextColor3=theme.TextColor,TextSize=10}),utility:Create("TextBox",{Name="Input",BackgroundTransparency=1,Position=UDim2.new(0.3,0,0,0),Size=UDim2.new(0.7,0,1,0),Font=Enum.Font.Gotham,Text="255",TextColor3=theme.TextColor,TextSize=10,ClearTextOnFocus=false})}),
                    utility:Create("ImageLabel",{Name="G",BackgroundTransparency=1,Size=UDim2.new(0.23,0,1,0),Image="rbxassetid://5028857472",ImageColor3=theme.DarkContrast,ScaleType=Enum.ScaleType.Slice,SliceCenter=Rect.new(2,2,298,298)},{utility:Create("TextLabel",{Name="Label",BackgroundTransparency=1,Size=UDim2.new(0.3,0,1,0),Font=Enum.Font.Gotham,Text="G",TextColor3=theme.TextColor,TextSize=10}),utility:Create("TextBox",{Name="Input",BackgroundTransparency=1,Position=UDim2.new(0.3,0,0,0),Size=UDim2.new(0.7,0,1,0),Font=Enum.Font.Gotham,Text="255",TextColor3=theme.TextColor,TextSize=10,ClearTextOnFocus=false})}),
                    utility:Create("ImageLabel",{Name="B",BackgroundTransparency=1,Size=UDim2.new(0.23,0,1,0),Image="rbxassetid://5028857472",ImageColor3=theme.DarkContrast,ScaleType=Enum.ScaleType.Slice,SliceCenter=Rect.new(2,2,298,298)},{utility:Create("TextLabel",{Name="Label",BackgroundTransparency=1,Size=UDim2.new(0.3,0,1,0),Font=Enum.Font.Gotham,Text="B",TextColor3=theme.TextColor,TextSize=10}),utility:Create("TextBox",{Name="Input",BackgroundTransparency=1,Position=UDim2.new(0.3,0,0,0),Size=UDim2.new(0.7,0,1,0),Font=Enum.Font.Gotham,Text="255",TextColor3=theme.TextColor,TextSize=10,ClearTextOnFocus=false})}),
                    utility:Create("ImageLabel",{Name="A",BackgroundTransparency=1,Size=UDim2.new(0.23,0,1,0),Image="rbxassetid://5028857472",ImageColor3=theme.DarkContrast,ScaleType=Enum.ScaleType.Slice,SliceCenter=Rect.new(2,2,298,298)},{utility:Create("TextLabel",{Name="Label",BackgroundTransparency=1,Size=UDim2.new(0.3,0,1,0),Font=Enum.Font.Gotham,Text="A",TextColor3=theme.TextColor,TextSize=10}),utility:Create("TextBox",{Name="Input",BackgroundTransparency=1,Position=UDim2.new(0.3,0,0,0),Size=UDim2.new(0.7,0,1,0),Font=Enum.Font.Gotham,Text="1.0",TextColor3=theme.TextColor,TextSize=10,ClearTextOnFocus=false})})
				})
			})
		}
        -- Parent popup children
        for _, child in ipairs(popupChildren) do
            if child then child.Parent = pickerPopup end
        end

        -- Color Picker Logic --
        local canvas = pickerPopup:FindFirstChild("Canvas", true)
        local colorSlider = pickerPopup:FindFirstChild("ColorSlider", true)
        local alphaSlider = pickerPopup:FindFirstChild("AlphaSlider", true)
        local cursor = canvas and canvas:FindFirstChild("Cursor")
        local hueSelector = colorSlider and colorSlider:FindFirstChild("Select")
        local alphaSelector = alphaSlider and alphaSlider:FindFirstChild("Select")
        local alphaFill = alphaSlider and alphaSlider:FindFirstChild("Fill")
        local inputsFrame = pickerPopup:FindFirstChild("Inputs", true)
        local rInput, gInput, bInput, aInput -- TextBoxes

        if inputsFrame then
             rInput = inputsFrame:FindFirstChild("R", true) and inputsFrame.R:FindFirstChild("Input")
             gInput = inputsFrame:FindFirstChild("G", true) and inputsFrame.G:FindFirstChild("Input")
             bInput = inputsFrame:FindFirstChild("B", true) and inputsFrame.B:FindFirstChild("Input")
             aInput = inputsFrame:FindFirstChild("A", true) and inputsFrame.A:FindFirstChild("Input")
        end

        -- Check if all required elements exist
        if not (canvas and colorSlider and alphaSlider and cursor and hueSelector and alphaSelector and alphaFill and rInput and gInput and bInput and aInput) then
             warn("[SCUI Error] Failed to create all elements for ColorPicker:", title)
             -- Cleanup potentially partially created popup?
             if pickerPopup and pickerPopup.Parent then pickerPopup:Destroy() end
             -- Maybe destroy cpFrame too? Or return nil?
             self:Resize(); return cpFrame -- Return base frame but picker won't work
        end

        local currentColor = defaultColor or Color3.new(1,1,1)
        local currentAlpha = 1.0 -- Store alpha separately (0-1)
        local currentHue, currentSat, currentVal = Color3.toHSV(currentColor)

        local draggingCanvas, draggingHue, draggingAlpha = false, false, false
        local pickerOpen = false

        -- Function to update all visuals based on H, S, V, A
        local function updatePickerVisuals(h, s, v, a)
            local baseColor = Color3.fromHSV(h, s, v)
            local hueColor = Color3.fromHSV(h, 1, 1)

            -- Update sliders and canvas
            if canvas and canvas.Parent then canvas.ImageColor3 = hueColor end
            if cursor and cursor.Parent then cursor.Position = UDim2.new(s, 0, 1 - v, 0) end
            if hueSelector and hueSelector.Parent then hueSelector.Position = UDim2.new(h, 0, 0, 0) end
            if alphaSelector and alphaSelector.Parent then alphaSelector.Position = UDim2.new(a, 0, 0, 0) end
            if alphaFill and alphaFill.Parent then
                 alphaFill.Size = UDim2.new(a, 0, 1, 0)
                 -- Update gradient on fill to show transparency effect
                 local grad = alphaFill:FindFirstChildOfClass("UIGradient")
                 if grad then
                     grad.Color = ColorSequence.new(baseColor, baseColor) -- Show base color through alpha
                 end
            end

            -- Update RGB inputs (if not focused)
            if rInput and not rInput.IsFocused then rInput.Text = math.floor(baseColor.R * 255 + 0.5) end
            if gInput and not gInput.IsFocused then gInput.Text = math.floor(baseColor.G * 255 + 0.5) end
            if bInput and not bInput.IsFocused then bInput.Text = math.floor(baseColor.B * 255 + 0.5) end
            if aInput and not aInput.IsFocused then aInput.Text = string.format("%.2f", a) end -- Format alpha

            -- Update main button preview (Color only)
            if colorButton and colorButton.Parent then colorButton.ImageColor3 = baseColor end
        end

        -- Function to handle final color update and callback
        local function finalizeColorUpdate()
             currentColor = Color3.fromHSV(currentHue, currentSat, currentVal)
             -- Call the main callback
             if callback then
                 local updateFunc = function(newTitle, newColor, newAlpha)
                     if cpFrame and cpFrame.Parent then
                         local titleLabel = cpFrame:FindFirstChild("Title")
                         if titleLabel and newTitle then titleLabel.Text = newTitle end
                         -- If new color/alpha provided, update the picker state
                         if newColor then
                             currentHue, currentSat, currentVal = Color3.toHSV(newColor)
                             currentAlpha = math.clamp(newAlpha or currentAlpha, 0, 1)
                             updatePickerVisuals(currentHue, currentSat, currentVal, currentAlpha)
                         elseif newAlpha ~= nil then
                              currentAlpha = math.clamp(newAlpha, 0, 1)
                              updatePickerVisuals(currentHue, currentSat, currentVal, currentAlpha)
                         end
                     end
                 end
                 task.spawn(callback, currentColor, currentAlpha, updateFunc)
             end
        end

        -- Input Handling (RGBA TextBoxes)
        local function handleRGBInput()
             local r = tonumber(rInput.Text) or 0
             local g = tonumber(gInput.Text) or 0
             local b = tonumber(bInput.Text) or 0
             r = math.clamp(r, 0, 255) / 255
             g = math.clamp(g, 0, 255) / 255
             b = math.clamp(b, 0, 255) / 255
             currentHue, currentSat, currentVal = Color3.toHSV(Color3.new(r, g, b))
             updatePickerVisuals(currentHue, currentSat, currentVal, currentAlpha)
             finalizeColorUpdate()
        end
         local function handleAlphaInput()
             local a = tonumber(aInput.Text) or 0
             currentAlpha = math.clamp(a, 0, 1)
             updatePickerVisuals(currentHue, currentSat, currentVal, currentAlpha)
             finalizeColorUpdate()
         end
         rInput.FocusLost:Connect(handleRGBInput); gInput.FocusLost:Connect(handleRGBInput); bInput.FocusLost:Connect(handleRGBInput); aInput.FocusLost:Connect(handleAlphaInput)
         rInput:GetPropertyChangedSignal("Text"):Connect(function() if rInput.IsFocused then handleRGBInput() end end) -- Update while typing
         gInput:GetPropertyChangedSignal("Text"):Connect(function() if gInput.IsFocused then handleRGBInput() end end)
         bInput:GetPropertyChangedSignal("Text"):Connect(function() if bInput.IsFocused then handleRGBInput() end end)
         aInput:GetPropertyChangedSignal("Text"):Connect(function() if aInput.IsFocused then handleAlphaInput() end end)


        -- Dragging Logic
        local function updateDrag(dragType)
            local mouseLoc = input:GetMouseLocation() - pickerPopup.AbsolutePosition -- Relative mouse pos

            if dragType == "Canvas" then
                local canvasPos = canvas.AbsolutePosition - pickerPopup.AbsolutePosition
                local canvasSize = canvas.AbsoluteSize
                currentSat = math.clamp((mouseLoc.X - canvasPos.X) / canvasSize.X, 0, 1)
                currentVal = 1 - math.clamp((mouseLoc.Y - canvasPos.Y) / canvasSize.Y, 0, 1)
            elseif dragType == "Hue" then
                local sliderPos = colorSlider.AbsolutePosition - pickerPopup.AbsolutePosition
                local sliderSize = colorSlider.AbsoluteSize
                currentHue = math.clamp((mouseLoc.X - sliderPos.X) / sliderSize.X, 0, 1)
            elseif dragType == "Alpha" then
                 local sliderPos = alphaSlider.AbsolutePosition - pickerPopup.AbsolutePosition
                 local sliderSize = alphaSlider.AbsoluteSize
                 currentAlpha = math.clamp((mouseLoc.X - sliderPos.X) / sliderSize.X, 0, 1)
            end
            updatePickerVisuals(currentHue, currentSat, currentVal, currentAlpha)
            finalizeColorUpdate() -- Update continuously while dragging
        end

        canvas.MouseButton1Down:Connect(function() draggingCanvas = true; updateDrag("Canvas") end)
        colorSlider.MouseButton1Down:Connect(function() draggingHue = true; updateDrag("Hue") end)
        alphaSlider.MouseButton1Down:Connect(function() draggingAlpha = true; updateDrag("Alpha") end)

        utility:DraggingEnded(function() -- Use utility to detect mouse up anywhere
            draggingCanvas, draggingHue, draggingAlpha = false, false, false
        end)

        input.InputChanged:Connect(function(inputObj)
            if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
                 if draggingCanvas then updateDrag("Canvas")
                 elseif draggingHue then updateDrag("Hue")
                 elseif draggingAlpha then updateDrag("Alpha")
                 end
            end
        end)

        -- Toggle Popup Visibility
        local function togglePicker(forceClose)
             if not pickerPopup or not pickerPopup.Parent then return end -- Check validity

             if forceClose == true or pickerOpen then -- Close
                 utility:Tween(pickerPopup, {Size = UDim2.fromOffset(0,0), Position = colorButton.AbsolutePosition - self.page.library.container.AbsolutePosition + Vector2.new(colorButton.AbsoluteSize.X/2, colorButton.AbsoluteSize.Y/2)}, 0.2)
                 task.wait(0.2)
                 pickerPopup.Visible = false
                 pickerOpen = false
             else -- Open
                 -- Calculate position relative to main container, next to button
                 local buttonPos = colorButton.AbsolutePosition - self.page.library.container.AbsolutePosition
                 local buttonSize = colorButton.AbsoluteSize
                 local screenHeight = self.page.library.container.AbsoluteSize.Y
                 local popupPosX = buttonPos.X - popupSize.X - 5 -- Position left of button
                 local popupPosY = math.clamp(buttonPos.Y + buttonSize.Y/2 - popupSize.Y/2, 5, screenHeight - popupSize.Y - 5) -- Center vertically, clamp to screen

                 pickerPopup.Position = UDim2.fromOffset(buttonPos.X + buttonSize.X/2, buttonPos.Y + buttonSize.Y/2) -- Start at button center
                 pickerPopup.Size = UDim2.fromOffset(0,0)
                 pickerPopup.Visible = true
                 updatePickerVisuals(currentHue, currentSat, currentVal, currentAlpha) -- Update visuals on open
                 utility:Tween(pickerPopup, {Size = UDim2.fromOffset(popupSize.X, popupSize.Y), Position = UDim2.fromOffset(popupPosX, popupPosY)}, 0.2)
                 pickerOpen = true
                 -- Bring to front (might not be necessary with high ZIndex)
                 -- pickerPopup.ZIndex = pickerPopup.ZIndex + 1
             end
        end

        colorButton.MouseButton1Click:Connect(togglePicker)
        local closeButton = pickerPopup:FindFirstChild("Close")
        if closeButton then closeButton.MouseButton1Click:Connect(function() togglePicker(true) end) end


        -- Initial visual update
        updatePickerVisuals(currentHue, currentSat, currentVal, currentAlpha)
        self:Resize()
		return cpFrame
	end

	function section:addSlider(title, default, min, max, callback)
        local theme = themes
        -- Base Frame
        local sliderFrame = utility:Create("Frame", {
            Name = "Slider_"..title:gsub("%s+", ""), Parent = self.container,
            BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 50), -- Taller frame for slider
            LayoutOrder = #self.container:GetChildren()
        })

        -- Top Row: Title and Value Input
        local topRow = utility:Create("Frame", {
            Name = "TopRow", Parent = sliderFrame, BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 0, 20), Position = UDim2.new(0,0,0,4)
        })
        utility:Create("TextLabel", {
            Name = "Title", Parent = topRow,
            AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1,
            Position = UDim2.new(0, 10, 0.5, 0), Size = UDim2.new(1, -55, 1, 0), -- Leave space for input
            ZIndex = 3, Font = Enum.Font.Gotham, Text = title, TextColor3 = theme.TextColor,
            TextSize = 12, TextTransparency = 0.1,
            TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Center
        })
        local valueInput = utility:Create("TextBox", {
            Name = "ValueInput", Parent = topRow,
            AnchorPoint = Vector2.new(1, 0.5), BackgroundTransparency = 1, BorderSizePixel = 0,
            Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 40, 1, -2), -- Small input box
            ZIndex = 3, Font = Enum.Font.GothamSemibold, Text = tostring(default or min),
            TextColor3 = theme.TextColor, TextSize = 11, ClearTextOnFocus = false,
            TextXAlignment = Enum.TextXAlignment.Right, TextYAlignment = Enum.TextYAlignment.Center
        }, { utility:Create("UICorner", {CornerRadius=UDim.new(0,3)}) })

        -- Bottom Row: Slider Bar
        local sliderBarBg = utility:Create("ImageButton", { -- Use ImageButton for click detection anywhere on bar
            Name = "SliderBarBg", Parent = sliderFrame,
            AnchorPoint = Vector2.new(0.5, 0), BackgroundTransparency = 1, AutoButtonColor=false,
            Position = UDim2.new(0.5, 0, 0, 28), Size = UDim2.new(1, -20, 0, 10), -- Bar size
            ZIndex = 2, Image = "rbxassetid://5028857472", ImageColor3 = theme.LightContrast,
            ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298)
        }, { utility:Create("UICorner",{CornerRadius=UDim.new(1,0)}) })

        local fillBar = utility:Create("ImageLabel", {
            Name = "Fill", Parent = sliderBarBg,
            AnchorPoint = Vector2.new(0, 0.5), Position = UDim2.new(0, 0, 0.5, 0),
            Size = UDim2.new(0, 0, 1, 0), -- Start at 0 width
            ZIndex = 3, Image = "rbxassetid://5028857472", ImageColor3 = theme.TextColor,
            ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298)
        }, { utility:Create("UICorner",{CornerRadius=UDim.new(1,0)}) })

        local handle = utility:Create("ImageLabel", {
            Name = "Handle", Parent = fillBar, -- Parent to fill bar
            AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1,
            Position = UDim2.new(1, 0, 0.5, 0), Size = UDim2.new(0, 14, 0, 14), -- Slightly larger handle
            ZIndex = 4, Image = "rbxassetid://4608020054", ImageColor3 = theme.TextColor, -- Circle image
            Visible = false -- Only visible when dragging
        })

        -- Slider Logic
        local currentValue = default or min
        local isDragging = false

        -- Function to update slider visuals and value based on percentage
        local function updateSlider(percent, triggerCallback)
            percent = math.clamp(percent, 0, 1)
            currentValue = min + (max - min) * percent
            -- Round to reasonable precision if needed (e.g., integers)
            -- currentValue = math.floor(currentValue + 0.5) -- Example rounding

            if valueInput and valueInput.Parent and not valueInput.IsFocused then
                valueInput.Text = tostring(currentValue) -- Update input box
            end
            if fillBar and fillBar.Parent then
                fillBar.Size = UDim2.new(percent, 0, 1, 0) -- Update fill bar size
            end

            if triggerCallback and callback then
                local updateFunc = function(newTitle, newValue, newMin, newMax)
                    -- Update slider parameters if provided
                    if sliderFrame and sliderFrame.Parent then
                        local titleLabel = sliderFrame:FindFirstChild("Title", true)
                        if titleLabel and newTitle then titleLabel.Text = newTitle end
                        min = newMin or min
                        max = newMax or max
                        if newValue ~= nil then
                            local newPercent = math.clamp((newValue - min) / (max - min), 0, 1)
                            updateSlider(newPercent, false) -- Update visuals without triggering callback again
                        end
                    end
                end
                task.spawn(callback, currentValue, updateFunc)
            end
        end

        -- Initialize slider position
        updateSlider(math.clamp(((default or min) - min) / (max - min), 0, 1), false)

        -- Dragging Logic
        sliderBarBg.MouseButton1Down:Connect(function()
            isDragging = true
            handle.Visible = true
            local barPos = sliderBarBg.AbsolutePosition
            local barSize = sliderBarBg.AbsoluteSize
            local percent = math.clamp((input:GetMouseLocation().X - barPos.X) / barSize.X, 0, 1)
            updateSlider(percent, true) -- Update on initial click
        end)

        utility:DraggingEnded(function()
            if isDragging then
                isDragging = false
                handle.Visible = false
            end
        end)

        input.InputChanged:Connect(function(inputObj)
            if inputObj.UserInputType == Enum.UserInputType.MouseMovement and isDragging then
                local barPos = sliderBarBg.AbsolutePosition
                local barSize = sliderBarBg.AbsoluteSize
                local percent = math.clamp((inputObj.Position.X - barPos.X) / barSize.X, 0, 1)
                updateSlider(percent, true)
            end
        end)

        -- Text Input Logic
        valueInput.FocusLost:Connect(function()
            local num = tonumber(valueInput.Text)
            local percent
            if num then
                percent = math.clamp((num - min) / (max - min), 0, 1)
            else
                percent = math.clamp((currentValue - min) / (max - min), 0, 1) -- Reset to current value if invalid input
            end
            updateSlider(percent, true)
        end)

        self:Resize()
		return sliderFrame
	end

	function section:addDropdown(title, list, callback)
        local theme = themes
        list = list or {} -- Ensure list is a table
        local dropdownFrame = utility:Create("Frame", {
            Name = "Dropdown_"..title:gsub("%s+", ""), Parent = self.container,
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 0, 30), -- Initial height (closed)
            ClipsDescendants = true,
            LayoutOrder = #self.container:GetChildren()
        })

        -- Top bar with title/current selection and dropdown arrow
        local searchBar = utility:Create("ImageLabel", {
            Name = "SearchBar", Parent = dropdownFrame, BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 0, 30), ZIndex = 3, -- Above list
            Image = "rbxassetid://5028857472", ImageColor3 = theme.DarkContrast,
            ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298)
        }, { utility:Create("UICorner", {CornerRadius = UDim.new(0,3)}) })

        local searchInput = utility:Create("TextBox", {
            Name = "Input", Parent = searchBar, BackgroundTransparency = 1,
            AnchorPoint = Vector2.new(0, 0.5), Position = UDim2.new(0, 10, 0.5, 0),
            Size = UDim2.new(1, -42, 1, -4), ZIndex = 4, Font = Enum.Font.Gotham,
            Text = title, -- Start with title, update with selection
            PlaceholderText = "Search...", PlaceholderColor3 = theme.TextColor:Lerp(theme.Background, 0.6),
            TextColor3 = theme.TextColor, TextSize = 12, TextTransparency = 0.1,
            TextXAlignment = Enum.TextXAlignment.Left, ClearTextOnFocus = false
        })

        local dropdownButton = utility:Create("ImageButton", {
            Name = "DropdownButton", Parent = searchBar, BackgroundTransparency = 1,
            AnchorPoint = Vector2.new(1, 0.5), Position = UDim2.new(1, -10, 0.5, 0),
            Size = UDim2.new(0, 18, 0, 18), ZIndex = 4, Image = "rbxassetid://5012539403", -- Arrow icon
            ImageColor3 = theme.TextColor, Rotation = 0, -- Start closed
            AutoButtonColor = false
        })

        -- List container (ScrollingFrame, initially size 0)
        local listContainer = utility:Create("ImageLabel", {
            Name = "ListContainer", Parent = dropdownFrame, BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 0, 0), -- Start hidden
            Position = UDim2.new(0,0,0,34), -- Position below search bar
            ZIndex = 2, Image = "rbxassetid://5028857472", ImageColor3 = theme.Background,
            ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298),
            ClipsDescendants = true
        }, { utility:Create("UICorner", {CornerRadius = UDim.new(0,3)}) })

        local listScroll = utility:Create("ScrollingFrame", {
            Name = "ListScroll", Parent = listContainer, Active = true, BackgroundTransparency = 1,
            Size = UDim2.new(1, -8, 1, -8), Position = UDim2.new(0,4,0,4), -- Padding
            CanvasSize = UDim2.new(0, 0, 0, 0), AutomaticCanvasSize = Enum.AutomaticSize.Y,
            ScrollBarThickness = 4, ScrollBarImageColor3 = theme.DarkContrast, ZIndex = 2
        }, { utility:Create("UIListLayout", { SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 4) }) })

        -- Dropdown Logic
        local isOpen = false
        local currentSelection = nil -- Store the selected value

        local function filterList(searchText)
             -- Clear existing items
            for _, item in ipairs(listScroll:GetChildren()) do
                 if item:IsA("ImageButton") then item:Destroy() end
            end

            local filtered = utility:Sort(searchText, list)
            local entryCount = 0

            -- Populate with filtered items
            for _, value in ipairs(filtered) do
                 entryCount = entryCount + 1
                 local itemButton = utility:Create("ImageButton", {
                     Name = "Item_"..tostring(value), Parent = listScroll, BackgroundTransparency = 1,
                     Size = UDim2.new(1, 0, 0, 30), ZIndex = 3,
                     Image = "rbxassetid://5028857472", ImageColor3 = theme.DarkContrast,
                     ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298),
                     AutoButtonColor = false, LayoutOrder = entryCount
                 }, {
                     utility:Create("TextLabel", { Name = "Text", BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0.5, 0), Size = UDim2.new(1, -20, 1, 0), AnchorPoint = Vector2.new(0, 0.5), ZIndex = 4, Font = Enum.Font.Gotham, Text = tostring(value), TextColor3 = theme.TextColor, TextSize = 12, TextXAlignment = Enum.TextXAlignment.Left, TextTransparency = 0.1 }),
                     utility:Create("UICorner", {CornerRadius=UDim.new(0,3)})
                 })

                 itemButton.MouseEnter:Connect(function() itemButton.ImageColor3 = theme.LightContrast end)
                 itemButton.MouseLeave:Connect(function() itemButton.ImageColor3 = theme.DarkContrast end)

                 itemButton.MouseButton1Click:Connect(function()
                     currentSelection = value
                     searchInput.Text = tostring(value) -- Update display text
                     if callback then
                          local updateFunc = function(newTitle, newList)
                              if dropdownFrame and dropdownFrame.Parent then
                                   -- Update title/selection display
                                   if newTitle then searchInput.Text = newTitle end
                                   -- Rebuild list if provided
                                   if newList then list = newList; filterList("") end -- Rebuild with full new list
                              end
                          end
                          task.spawn(callback, currentSelection, updateFunc)
                     end
                     toggleDropdown(true) -- Force close after selection
                 end)
            end
            return entryCount
        end

        local function toggleDropdown(forceClose)
            if not dropdownFrame or not dropdownFrame.Parent then return end

            isOpen = (forceClose == true) and false or not isOpen -- Determine new state

            utility:Tween(dropdownButton, {Rotation = isOpen and 180 or 0}, 0.2)

            if isOpen then
                 local entryCount = filterList(searchInput.Text == title and "" or searchInput.Text) -- Filter based on current text (or show all if default title)
                 local listHeight = math.min(entryCount, 3) * 34 + 8 -- Max 3 items visible + padding
                 local targetSize = UDim2.new(1, 0, 0, listHeight)
                 local totalHeight = 30 + listHeight + 4 -- Searchbar + List + Spacing

                 utility:Tween(listContainer, {Size = targetSize}, 0.2)
                 utility:Tween(dropdownFrame, {Size = UDim2.new(1, 0, 0, totalHeight)}, 0.2)
                 -- Update scrollbar visibility after tween
                 task.delay(0.2, function()
                      if listScroll and listScroll.Parent then
                           local contentHeight = listScroll.CanvasSize.Y.Offset
                           local viewHeight = listScroll.AbsoluteSize.Y
                           listScroll.ScrollBarImageTransparency = contentHeight <= viewHeight and 1 or 0
                      end
                 end)
            else -- Close
                 utility:Tween(listContainer, {Size = UDim2.new(1, 0, 0, 0)}, 0.2)
                 utility:Tween(dropdownFrame, {Size = UDim2.new(1, 0, 0, 30)}, 0.2)
            end
            task.delay(0.21, function() self:Resize() end) -- Resize section after animation slightly delayed
        end

        dropdownButton.MouseButton1Click:Connect(toggleDropdown)
        searchInput.Focused:Connect(function()
             if not isOpen then toggleDropdown() end -- Open if not already open
             if searchInput.Text == title then searchInput.Text = "" end -- Clear default title on focus
        end)
        searchInput.FocusLost:Connect(function()
             task.wait() -- Allow click event to process first if clicking item/button
             if not isOpen and searchInput.Text == "" then
                 searchInput.Text = currentSelection and tostring(currentSelection) or title -- Restore selection or title
             end
             -- Consider closing if focus is lost and nothing was selected? Maybe not.
        end)
        searchInput:GetPropertyChangedSignal("Text"):Connect(function()
             if isOpen and searchInput.IsFocused then
                 local entryCount = filterList(searchInput.Text)
                 -- Resize while open based on filtered results (optional, can be jumpy)
                 local listHeight = math.min(entryCount, 3) * 34 + 8
                 local targetSize = UDim2.new(1, 0, 0, listHeight)
                 local totalHeight = 30 + listHeight + 4
                 utility:Tween(listContainer, {Size = targetSize}, 0.1) -- Faster tween while typing
                 utility:Tween(dropdownFrame, {Size = UDim2.new(1, 0, 0, totalHeight)}, 0.1)
             end
        end)

        self:Resize()
		return dropdownFrame
	end


	-- Update Functions for Added Modules --

	function section:updateTextbox(textbox, title, value)
		textbox = self:getModule(textbox) -- Find the textbox base frame
        if not textbox or not textbox.Parent then return end

        local titleLabel = textbox:FindFirstChild("Title")
        local input = textbox:FindFirstChild("Input", true) -- Recursive search for input

        if titleLabel and title then titleLabel.Text = title end
		if input and value ~= nil then input.Text = tostring(value) end -- Use tostring
	end

	function section:updateKeybind(keybind, title, key)
		keybind = self:getModule(keybind) -- Find the keybind base frame
        if not keybind or not keybind.Parent then return end

        local titleLabel = keybind:FindFirstChild("Title")
        local keyText = keybind:FindFirstChild("KeyText", true)

		if titleLabel and title then titleLabel.Text = title end

        -- Need to find the updateBind function associated with this instance
        -- This is tricky without storing it. A better approach might be needed,
        -- maybe returning an object from addKeybind with an update method.
        -- For now, just update the text label if possible.
		if keyText then
			keyText.Text = (key and key.Name) or "None"
            warn("[SCUI Warning] updateKeybind currently only updates text display, not the actual bind logic.")
            -- To update the actual bind, you'd need to call the internal 'updateBind' function
            -- which requires referencing it, possibly by storing it on the keybindFrame instance itself.
		end
	end

	function section:updateColorPicker(colorpicker, title, color, alphaValue)
		colorpicker = self:getModule(colorpicker) -- Find the colorpicker base frame
        if not colorpicker or not colorpicker.Parent then return end

        local titleLabel = colorpicker:FindFirstChild("Title")
        local colorButton = colorpicker:FindFirstChild("ColorButton")
        -- Also need access to the popup and its internal update function

		if titleLabel and title then titleLabel.Text = title end
        if colorButton and color then colorButton.ImageColor3 = color end

        warn("[SCUI Warning] updateColorPicker currently only updates preview button/title, not the popup state.")
        -- Similar to keybind, updating the popup requires access to its internal state/functions.
        -- Need a more robust way to link the update function to the instance, perhaps return controls.
	end

	function section:updateSlider(slider, title, value, min, max)
		slider = self:getModule(slider) -- Find slider base frame
        if not slider or not slider.Parent then return end

        local titleLabel = slider:FindFirstChild("Title", true)
        local valueInput = slider:FindFirstChild("ValueInput", true)
        local fillBar = slider:FindFirstChild("Fill", true)

        if titleLabel and title then titleLabel.Text = title end

        -- Need access to internal min/max and update function
        warn("[SCUI Warning] updateSlider currently only updates title/input text, not position/limits.")
        if valueInput and value ~= nil then valueInput.Text = tostring(value) end
        -- To update position and handle new min/max, need reference to the internal updateSlider function.
	end

	function section:updateDropdown(dropdown, title, list)
		dropdown = self:getModule(dropdown) -- Find dropdown base frame
        if not dropdown or not dropdown.Parent then return end

        local searchInput = dropdown:FindFirstChild("Input", true)

        if searchInput and title then searchInput.Text = title end

        warn("[SCUI Warning] updateDropdown currently only updates display text, not the list content.")
        -- Updating the list requires access to the internal 'list' variable and 'filterList' function.
	end

end -- End of Class implementations block

return library
