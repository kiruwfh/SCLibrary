--[[
  Refactored UI Library Source Code
  Original Author: Batus (juywvm) / Ars.red / Ligma UI
  Refactored by: Gemini

  Goal: Remove Synapse X specific functions (syn.*, getsynasset, filesystem)
        to improve compatibility with other environments (e.g., Solara V3, Standard Lua where possible).

  IMPORTANT NOTES:
  1.  ASSETS: The original asset loading used syn.crypt.base64.decode and file caching.
      This has been removed. You MUST upload the images (decoded from the original base64)
      to Roblox and replace the placeholder "rbxassetid://YOUR_ASSET_ID_HERE" strings
      in the `assets` table below with the correct Asset IDs.
  2.  SAVING/LOADING: Filesystem functions (writefile, readfile, isfolder, makefolder)
      are environment-specific and have been commented out in the `apply_settings` function.
      You need to implement saving/loading using the API provided by your target
      environment (e.g., Solara V3's file functions) or use alternatives like DataStoreService.
  3.  CLIPBOARD: The `setclipboard` function used in `apply_settings` has been commented out
      as it's environment-specific. Implement using your target environment's API if needed.
  4.  GUI PROTECTION: `syn.protect_gui` has been removed.
]]

local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")
local CoreGui = game:GetService("CoreGui")
local GuiService = game:GetService("GuiService") -- Added for GuiInset calculation

local generate_guid
generate_guid = function()
  -- Standard Roblox function, should work in most environments supporting HttpService
  pcall(function() return HttpService:GenerateGUID(false) end)
  -- Fallback if HttpService is unavailable or restricted
  math.randomseed(os.time() + tick())
  local template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
  return string.gsub(template, '[xy]', function (c)
    local v = (c == 'x') and math.random(0, 0xf) or math.random(8, 0xb)
    return string.format('%x', v)
  end)
end

--[[
  ASSET DEFINITIONS
  IMPORTANT: Replace "rbxassetid://YOUR_ASSET_ID_HERE" with the actual Roblox Asset IDs
             for the images corresponding to the original base64 data.
             You need to decode the original base64 strings (e.g., using base64.guru)
             and upload the resulting PNG images to Roblox.
]]
local assets = {
  square = "rbxassetid://YOUR_SQUARE_ASSET_ID_HERE", -- Placeholder for a simple square image (used for scrollbars)
  checkmark = "rbxassetid://YOUR_CHECKMARK_ASSET_ID_HERE", -- Placeholder for checkmark image
  triangle = "rbxassetid://YOUR_TRIANGLE_ASSET_ID_HERE", -- Placeholder for dropdown arrow image
  colorpicker = "rbxassetid://YOUR_COLORPICKER_GRADIENT_ASSET_ID_HERE", -- Placeholder for colorpicker gradient overlay
  colorpicker_location = "rbxassetid://YOUR_COLORPICKER_SELECTOR_ASSET_ID_HERE", -- Placeholder for colorpicker selector/cursor
  slider_location = "rbxassetid://YOUR_SLIDER_SELECTOR_ASSET_ID_HERE", -- Placeholder for hue/opacity slider selector
  transparent_pattern = "rbxassetid://YOUR_TRANSPARENT_PATTERN_ASSET_ID_HERE" -- Placeholder for transparency background pattern
}

-- Removed the original asset decoding and file caching loop

local library
do
  local _class_0
  local window -- Forward declaration
  local _base_0 = {
    new_window = function(self, title, position, size)
      title = title or "ars.red" -- Default title
      position = position or UDim2.new(0.5, -250, 0.5, -300) -- Default position
      size = size or UDim2.new(0, 500, 0, 600) -- Default size

      -- Destroy existing window if present
      if getgenv().window and getgenv().window.destroy then
         pcall(getgenv().window.destroy, getgenv().window)
      end

      getgenv().window = window(title, position, size) -- Create and store the new window
      return getgenv().window
    end,

    apply_settings = function(self, tab)
      -- Creates standard menu settings (Menu Key, Config Save/Load, Unload) in the provided tab

      local menu_group = tab:new_group("Menu", false)
      local config_group = tab:new_group("Config", true)

      -- Menu Keybind
      menu_group:new_label({
        text = "Menu Key"
      }):add_keybind("menu_key", {
        default = Enum.KeyCode.End, -- Default key
        mode = "Toggle",
        state = true, -- Default state (visible)
        ignore = true, -- Ignore this flag during config save/load
        callback = function(state)
          -- Toggle window visibility
          if getgenv().window and getgenv().window.window then
             getgenv().window.window.Enabled = state
          end
        end
      })

      -- Copy JobId Button
      menu_group:new_button({
        text = "Copy JobId",
        callback = function()
          local success = false
          local jobIdStr = ""
          if game and game.PlaceId and game.JobId then
             jobIdStr = "Roblox.GameLauncher.joinGameInstance(" .. tostring(game.PlaceId) .. ", \"" .. tostring(game.JobId) .. "\")"
          else
             print("Error: Could not get PlaceId or JobId.")
             return
          end
          --[[
             CLIPBOARD ACCESS: setclipboard is environment-specific.
             You need to replace this with the clipboard API of your target environment (e.g., Solara V3)
             or remove this feature if clipboard access is not available.
             Example placeholder:
             if solara_api and solara_api.set_clipboard then
                 success = pcall(solara_api.set_clipboard, jobIdStr)
             else
                 print("Clipboard API not available in this environment.")
             end
          ]]
          -- success = pcall(setclipboard, jobIdStr) -- Original Synapse call commented out
          print("Clipboard functionality requires environment-specific implementation.")

          if success then
             print("JobId copied to clipboard.")
          else
             print("Failed to copy JobId to clipboard.")
          end
        end
      })

      -- Unload Button
      menu_group:new_button({
        text = "Unload",
        callback = function()
          if getgenv().window and getgenv().window.destroy then
             pcall(getgenv().window.destroy, getgenv().window)
          end
          -- Clear global references
          getgenv().library = nil
          getgenv().window = nil
          print("UI Unloaded.")
        end
      })

      -- Config Name Textbox
      config_group:new_textbox("config_name", {
        text = "Config Name",
        default = "default_config", -- Provide a default name
        ignore = true -- Ignore this flag during config save/load
      })

      -- Save Button
      config_group:new_button({
        text = "Save",
        callback = function()
          --[[
            FILESYSTEM ACCESS: Saving configurations requires environment-specific filesystem functions
            (e.g., writefile, isfolder, makefolder). The original Synapse code is commented out below.
            You need to implement this using your target environment's API (e.g., Solara V3's file functions)
            or use alternatives like DataStoreService for online games.

            local config_name = "ars/" .. tostring(getgenv().window.flags["config_name"]) .. ".json"
            if not isfolder("ars") then
              makefolder("ars")
            end

            local fixed_config = {}
            for key, value in pairs(getgenv().window.flags) do
              if not getgenv().window.ignore[key] then
                local fixed_value = value
                -- Handle Color3 saving
                if type(value) == "table" and value.color and typeof(value.color) == "Color3" then
                  fixed_value = {
                    color = value.color:ToHex(),
                    transparency = value.transparency
                  }
                -- Handle Keybind saving (ensure keycode is string)
                elseif type(value) == "table" and value.keycode and typeof(value.keycode) == "EnumItem" then
                   fixed_value = {
                       state = value.state,
                       keycode = value.keycode.Name, -- Save Enum name as string
                       mode = value.mode
                   }
                elseif typeof(value) == "EnumItem" then -- Handle standalone EnumItems if any
                   fixed_value = value.Name
                end
                fixed_config[key] = fixed_value
              end
            end

            local json_data, err = pcall(HttpService.JSONEncode, HttpService, fixed_config)
            if json_data then
               local success, write_err = pcall(writefile, config_name, json_data)
               if success then
                  print("Config saved:", config_name)
               else
                  print("Error writing config file:", write_err)
               end
            else
               print("Error encoding config to JSON:", err)
            end
          ]]
          print("Config saving requires environment-specific implementation.")
        end
      })

      -- Load Button
      return config_group:new_button({
        text = "Load",
        callback = function()
          --[[
            FILESYSTEM ACCESS: Loading configurations requires environment-specific filesystem functions
            (e.g., readfile, isfolder, isfile). The original Synapse code is commented out below.
            You need to implement this using your target environment's API (e.g., Solara V3's file functions)
            or use alternatives like DataStoreService for online games.

            local config_name = "ars/" .. tostring(getgenv().window.flags["config_name"]) .. ".json"
            if not isfolder("ars") then
              makefolder("ars")
            end

            if isfile(config_name) then
              local json_data, read_err = pcall(readfile, config_name)
              if json_data then
                 local config_data, decode_err = pcall(HttpService.JSONDecode, HttpService, json_data)
                 if config_data then
                    for flag, value in pairs(config_data) do
                       if getgenv().window.options[flag] and not getgenv().window.ignore[flag] then
                          local fixed_value = value
                          -- Handle Color3 loading
                          if type(value) == "table" and value.color and type(value.color) == "string" then
                             local success, color = pcall(Color3.fromHex, value.color)
                             if success then
                                fixed_value = {
                                   color = color,
                                   transparency = value.transparency or 0
                                }
                             else
                                print("Error converting hex to Color3 for flag:", flag)
                                fixed_value = nil -- Skip if invalid
                             end
                          -- Handle Keybind loading (convert string back to Enum if possible)
                          elseif type(value) == "table" and value.keycode and type(value.keycode) == "string" then
                             local keyEnum = Enum.KeyCode[value.keycode]
                             if keyEnum then
                                fixed_value = {
                                   state = value.state,
                                   keycode = keyEnum, -- Convert back to EnumItem
                                   mode = value.mode
                                }
                             else
                                print("Warning: Could not find Enum.KeyCode for", value.keycode)
                                fixed_value = { -- Load with nil keycode
                                   state = value.state,
                                   keycode = nil,
                                   mode = value.mode
                                }
                             end
                          -- Handle standalone EnumItems if any (Example: Enum.Font)
                          elseif type(value) == "string" then
                             -- Attempt to find a matching Enum based on option type (this is complex/fragile)
                             -- For simplicity, this part is often handled manually or skipped in basic ports.
                             -- Example for a hypothetical font option:
                             -- if getgenv().window.options[flag].__name == "font_selector" then
                             --    fixed_value = Enum.Font[value] or Enum.Font.SourceSans -- Default fallback
                             -- end
                          end

                          if fixed_value ~= nil and getgenv().window.options[flag].set_value then
                             pcall(getgenv().window.options[flag].set_value, getgenv().window.options[flag], fixed_value)
                          end
                       end
                    end
                    print("Config loaded:", config_name)
                 else
                    print("Error decoding config JSON:", decode_err)
                 end
              else
                 print("Error reading config file:", read_err)
              end
            else
               print("Config file not found:", config_name)
            end
          ]]
          print("Config loading requires environment-specific implementation.")
        end
      })
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function() end,
    __base = _base_0,
    __name = "library"
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  local self = _class_0 -- Alias for the library class itself

  -- Window Class Definition
  do
    local _class_1
    local _base_1 = {
      update = function(self)
        -- Updates position/size of background elements when window is dragged
        if not self.background_objects or not self.background_objects[1] then return end -- Guard against destroyed objects
        pcall(function()
            self.background_objects[1].Size = self.size
            self.background_objects[1].Position = self.position
            self.background_objects[2].Size = self.size - UDim2.new(0, 2, 0, 2)
            self.background_objects[2].Position = self.position + UDim2.new(0, 1, 0, 1)
            self.background_objects[3].Size = self.size - UDim2.new(0, 4, 0, 4)
            self.background_objects[3].Position = self.position + UDim2.new(0, 2, 0, 2)
        end)
      end,

      new_tab = function(self, name)
        name = name or ""
        if self.tabs[name] then return self.tabs[name] end -- Return existing tab if found

        if not self.active_tab then
          self.active_tab = #self.tab_objects + 1 -- Set first tab as active if none is set
        end

        local current_tab_index = #self.tab_objects + 1

        local tab_button = self:add_object("TextButton", {
          Name = generate_guid(),
          BackgroundTransparency = 1,
          TextColor3 = Color3.fromRGB(255, 255, 255),
          TextSize = 12,
          Text = name,
          Font = Enum.Font.GothamSemibold,
          Size = UDim2.new(0, 100, 0, 18), -- Initial size, will be recalculated
          Parent = self.tab_bar_objects[2], -- Parent to inner tab bar frame
          ZIndex = 8
        })
        self.tab_objects[current_tab_index] = tab_button

        local mouse_button_click
        mouse_button_click = function()
          self:set_active_tab(current_tab_index)
        end
        self.connections[#self.connections + 1] = tab_button.MouseButton1Click:Connect(mouse_button_click)

        -- Create the main frame for this tab's content
        local tab_content_frame = self:add_object("Frame", {
          Name = generate_guid(),
          BackgroundColor3 = Color3.fromRGB(12, 12, 12),
          BorderSizePixel = 0,
          Size = UDim2.new(1, 0, 1, 0), -- Fill the group container
          Position = UDim2.new(0, 0, 0, 0),
          Parent = self.group_objects[1], -- Parent to main group container
          Visible = (self.active_tab == current_tab_index), -- Only active tab is visible
          ZIndex = 9
        })
        self.tab_groups[current_tab_index] = tab_content_frame

        -- Recalculate tab button positions and sizes
        local total_tabs = #self.tab_objects
        local distance_per_column = 0
        if self.tab_bar_objects[2].AbsoluteSize.X > 0 and total_tabs > 0 then
           distance_per_column = self.tab_bar_objects[2].AbsoluteSize.X / total_tabs
        end

        for idx, tab_btn in ipairs(self.tab_objects) do
          local column_start = distance_per_column * (idx - 1)
          tab_btn.Position = UDim2.new(0, column_start, 0, 0)
          tab_btn.Size = UDim2.new(0, distance_per_column, 1, 0) -- Use full height
          if idx == self.active_tab then
            tab_btn.TextColor3 = Color3.fromRGB(255, 0, 0) -- Active tab color
          else
            tab_btn.TextColor3 = Color3.fromRGB(255, 255, 255) -- Inactive tab color
          end
        end

        -- Tab Class Definition (Inner class for managing groups within a tab)
        local tab
        do
          local _class_2
          local _base_2 = {
            new_group = function(self, name, right)
              right = right or false -- Default to left group
              local target_scrolling_frame = right and self.right_group or self.left_group
              local target_group_objects_table = right and self.right_group_objects or self.left_group_objects

              local group_frame = self.parent:add_object("Frame", {
                Name = generate_guid(),
                BackgroundColor3 = Color3.fromRGB(20, 20, 20),
                BorderSizePixel = 1,
                BorderColor3 = Color3.fromRGB(30, 30, 30),
                Size = UDim2.new(1, 0, 0, 0), -- Width 100%, Height automatic
                Position = UDim2.new(0, 0, 0, 0),
                Parent = target_scrolling_frame,
                AutomaticSize = Enum.AutomaticSize.Y, -- Automatically adjust height based on content
                ClipsDescendants = true,
                ZIndex = 11,
                LayoutOrder = #target_group_objects_table + 1 -- Ensure groups appear in order
              })
              table.insert(target_group_objects_table, group_frame) -- Track the group frame

              -- Group Title Label
              self.parent:add_object("TextLabel", {
                Name = generate_guid(),
                BackgroundColor3 = Color3.fromRGB(20, 20, 20),
                BackgroundTransparency = 1,
                Size = UDim2.new(1, 0, 0, 18), -- Full width, fixed height
                Position = UDim2.new(0, 0, 0, 0),
                TextColor3 = Color3.fromRGB(255, 255, 255),
                TextSize = 12,
                Text = name,
                Font = Enum.Font.GothamSemibold,
                Parent = group_frame,
                TextXAlignment = Enum.TextXAlignment.Left, -- Align text left
                TextYAlignment = Enum.TextYAlignment.Center,
                ZIndex = 12
              })

              -- Container for group items (options like checkboxes, sliders, etc.)
              local items_container = self.parent:add_object("Frame", {
                Name = generate_guid(),
                BackgroundColor3 = Color3.fromRGB(20, 20, 20),
                BorderSizePixel = 0,
                Size = UDim2.new(1, 0, 0, 0), -- Full width, height automatic
                Position = UDim2.new(0, 0, 0, 18), -- Position below the title
                Parent = group_frame,
                AutomaticSize = Enum.AutomaticSize.Y, -- Adjust height based on items
                ClipsDescendants = true,
                ZIndex = 12
              })

              -- Layout for items within the container
              self.parent:add_object("UIListLayout", {
                Name = generate_guid(),
                FillDirection = Enum.FillDirection.Vertical,
                HorizontalAlignment = Enum.HorizontalAlignment.Left,
                SortOrder = Enum.SortOrder.LayoutOrder,
                VerticalAlignment = Enum.VerticalAlignment.Top,
                Padding = UDim.new(0, 4), -- Padding between items
                Parent = items_container
              })
               self.parent:add_object("UIPadding", { -- Padding inside the items container
                 Name = generate_guid(),
                 PaddingBottom = UDim.new(0, 4),
                 PaddingLeft = UDim.new(0, 4),
                 PaddingRight = UDim.new(0, 4),
                 PaddingTop = UDim.new(0, 4),
                 Parent = items_container
               })


              -- Group Class Definition (Inner class for managing items within a group)
              local group
              do
                local _class_3
                local item -- Forward declaration for base item class
                local _base_3 = {
                  -- Checkbox Method
                  new_checkbox = function(self, flag, options)
                    options = options or {}
                    local checkbox
                    do
                      local _class_4
                      local _parent_0 = item -- Inherits from base item class
                      local _base_4 = {
                        set_value = function(self, value)
                          value = value or false
                          if self.window.flags[self.flag] ~= value then -- Only update if value changed
                             self.window.flags[self.flag] = value
                             self.check.Visible = value
                             pcall(options.callback, value) -- Safely call callback
                          end
                        end
                      }
                      _base_4.__index = _base_4
                      setmetatable(_base_4, _parent_0 and _parent_0.__base or nil)
                      _class_4 = setmetatable({
                        __init = function(self, parent_group_obj, flag, options)
                           self.parent_group_obj = parent_group_obj -- Reference to the group object
                           self.window = self.parent_group_obj.parent.parent -- Access window object
                           self.item_objects = {} -- Store GUI instances for this item
                           self.flag = flag
                           options.callback = options.callback or function() end
                           self.window.flags[flag] = options.default or false
                           self.window.options[flag] = self -- Store reference for config loading

                           -- Main frame for the checkbox item
                           local item_frame = self.window:add_object("Frame", {
                             Name = generate_guid(),
                             BackgroundColor3 = Color3.fromRGB(20, 20, 20),
                             BackgroundTransparency = 1, -- Transparent background
                             BorderSizePixel = 0,
                             Size = UDim2.new(1, 0, 0, 18), -- Full width, fixed height
                             Position = UDim2.new(0, 0, 0, 0),
                             Parent = items_container, -- Parent is the items container of the group
                             -- AutomaticSize = Enum.AutomaticSize.Y, -- Let height adjust if needed (though fixed here)
                             ClipsDescendants = true,
                             ZIndex = 13,
                             LayoutOrder = #items_container:GetChildren() -- Maintain order
                           })
                           self.item_objects[#self.item_objects+1] = item_frame

                           -- Checkbox Button (clickable area)
                           local button = self.window:add_object("TextButton", {
                             Name = generate_guid(),
                             BackgroundColor3 = Color3.fromRGB(12, 12, 12),
                             BorderSizePixel = 1,
                             BorderColor3 = Color3.fromRGB(30, 30, 30),
                             Size = UDim2.new(0, 14, 0, 14), -- Small square
                             Position = UDim2.new(0, 3, 0.5, -7), -- Centered vertically
                             Text = "",
                             Parent = item_frame,
                             AutoButtonColor = false,
                             ZIndex = 14
                           })
                           self.item_objects[#self.item_objects+1] = button

                           -- Checkmark Image
                           self.check = self.window:add_object("ImageLabel", {
                             Name = generate_guid(),
                             BackgroundColor3 = Color3.fromRGB(20, 20, 20),
                             BackgroundTransparency = 1,
                             Size = UDim2.new(1, 0, 1, 0), -- Fill the button
                             Position = UDim2.new(0, 0, 0, 0),
                             Image = assets.checkmark, -- Use asset ID placeholder
                             ImageColor3 = Color3.fromRGB(255, 0, 0), -- Red checkmark
                             ScaleType = Enum.ScaleType.Fit,
                             Visible = self.window.flags[flag], -- Initial visibility based on default
                             Parent = button,
                             ZIndex = 15
                           })
                           self.item_objects[#self.item_objects+1] = self.check

                           -- Label Text
                           local label = self.window:add_object("TextLabel", {
                             Name = generate_guid(),
                             BackgroundTransparency = 1,
                             Size = UDim2.new(1, -25, 1, 0), -- Adjust width based on checkbox size and padding
                             Position = UDim2.new(0, 25, 0, 0), -- Positioned to the right of the checkbox
                             TextColor3 = options.unsafe and Color3.fromRGB(182, 182, 101) or Color3.fromRGB(255, 255, 255),
                             TextSize = 12,
                             Text = options.text or flag,
                             Font = Enum.Font.Gotham,
                             Parent = item_frame,
                             TextXAlignment = Enum.TextXAlignment.Left,
                             TextYAlignment = Enum.TextYAlignment.Center,
                             ZIndex = 14
                           })
                           self.item_objects[#self.item_objects+1] = label

                           -- Click connection
                           local mouse_button_click = function()
                             self:set_value(not self.window.flags[flag])
                           end
                           self.window.connections[#self.window.connections + 1] = button.MouseButton1Click:Connect(mouse_button_click)

                           -- Store ignore flag for config saving
                           if options.ignore then
                              self.window.ignore[flag] = true
                           end
                        end,
                        __base = _base_4,
                        __name = "checkbox",
                        __parent = _parent_0
                      }, {
                        __index = function(cls, name)
                           local val = rawget(_base_4, name)
                           if val == nil then
                              local parent = rawget(cls, "__parent")
                              if parent then return parent[name] end
                           else
                              return val
                           end
                        end,
                        __call = function(cls, ...)
                           local _self_0 = setmetatable({}, _base_4)
                           cls.__init(_self_0, ...)
                           return _self_0
                        end
                      })
                      _base_4.__class = _class_4
                      if _parent_0 and _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_4) end
                      checkbox = _class_4
                    end
                    return checkbox(self, flag, options) -- Instantiate and return the checkbox object
                  end,

                  -- List (Dropdown) Method
                  new_list = function(self, flag, options)
                    -- Implementation requires careful handling of dropdown visibility,
                    -- positioning, and interaction. Similar structure to checkbox but more complex.
                    -- Placeholder implementation:
                    options = options or {}
                    options.values = options.values or {}
                    options.callback = options.callback or function() end
                    self.window.flags[flag] = options.default or (options.multi and {} or (options.values[1] or nil)) -- Default value
                    self.window.options[flag] = self -- Store reference

                    local item_frame = self.window:add_object("Frame", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(1,0,0,39), Parent=items_container, ZIndex=13, LayoutOrder = #items_container:GetChildren() })
                    self.window:add_object("TextLabel", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(1, -20, 0, 16), Position=UDim2.new(0,2,0,0), TextColor3=Color3.new(1,1,1), TextSize=12, Text=options.text or flag, Font=Enum.Font.Gotham, Parent=item_frame, TextXAlignment=Enum.TextXAlignment.Left, ZIndex=14 })
                    local button = self.window:add_object("TextButton", { Name=generate_guid(), BackgroundColor3=Color3.new(0.05,0.05,0.05), BorderSizePixel=1, BorderColor3=Color3.new(0.1,0.1,0.1), Size=UDim2.new(1, -20, 0, 20), Position=UDim2.new(0, 3, 0, 16), Text="Select...", Font=Enum.Font.Gotham, TextSize=12, TextColor3=Color3.new(1,1,1), Parent=item_frame, AutoButtonColor=false, TextXAlignment = Enum.TextXAlignment.Left, ZIndex=14 })
                    local arrow = self.window:add_object("ImageLabel", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(0,10,0,10), Position=UDim2.new(1,-13,0.5,-5), Image=assets.triangle, ImageColor3=Color3.new(1,1,1), Parent=button, Rotation=-90, ZIndex=15 })

                    -- Simplified representation of value
                    local function update_button_text()
                       local current_value = self.window.flags[flag]
                       if options.multi then
                          button.Text = table.concat(current_value, ", ")
                          if #button.Text == 0 then button.Text = "None" end
                       else
                          button.Text = tostring(current_value or "None")
                       end
                    end
                    update_button_text() -- Initial text

                    -- Dropdown logic (simplified - actual implementation needs more work)
                    button.MouseButton1Click:Connect(function()
                       print("Dropdown for '"..flag.."' clicked. Needs full implementation.")
                       -- Toggle visibility of self.window.drop_container
                       -- Populate self.window.drop_container with options.values
                       -- Handle selection logic to update self.window.flags[flag] and call options.callback
                       -- Update button.Text
                       -- Handle closing dropdown on outside click
                    end)

                    -- Add set_value function for config loading
                    self.set_value = function(self_ref, value) -- Use self_ref to avoid capturing self incorrectly
                        self_ref.window.flags[flag] = value
                        update_button_text()
                        pcall(options.callback, value)
                    end
                    self.set_values = function(self_ref, new_values) -- Function to update the available options
                        options.values = new_values or {}
                        -- Potentially update dropdown if open, or reset selection if current value is no longer valid
                        print("Dropdown values updated for '"..flag.."' (needs full implementation).")
                    end


                    if options.ignore then self.window.ignore[flag] = true end
                    return self -- Return the list object itself (or a wrapper)
                  end,

                  -- Button Method
                  new_button = function(self, options)
                     options = options or {}
                     options.callback = options.callback or function() end

                     local item_frame = self.window:add_object("Frame", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(1,0,0,20), Parent=items_container, ZIndex=13, LayoutOrder = #items_container:GetChildren() })
                     local button = self.window:add_object("TextButton", {
                       Name = generate_guid(),
                       BackgroundColor3 = Color3.fromRGB(12, 12, 12),
                       BorderSizePixel = 1,
                       BorderColor3 = Color3.fromRGB(30, 30, 30),
                       Size = UDim2.new(1, -6, 1, -2), -- Adjust padding slightly
                       Position = UDim2.new(0, 3, 0, 1),
                       Text = options.text or "Button",
                       TextColor3 = options.unsafe and Color3.fromRGB(182, 182, 101) or Color3.fromRGB(255, 255, 255),
                       Font = Enum.Font.Gotham,
                       TextSize = 12,
                       Parent = item_frame,
                       AutoButtonColor = false,
                       ZIndex = 14
                     })

                     self.window.connections[#self.window.connections + 1] = button.MouseButton1Click:Connect(function() pcall(options.callback) end)
                     return self -- Return group object for chaining (though button doesn't usually chain)
                  end,

                  -- Slider Method
                  new_slider = function(self, flag, options)
                    -- Implementation requires handling mouse dragging on the slider bar.
                    -- Placeholder implementation:
                    options = options or {}
                    options.min = options.min or 0
                    options.max = options.max or 100
                    options.default = options.default or options.min
                    options.decimals = options.decimals or 0
                    options.callback = options.callback or function() end
                    self.window.flags[flag] = options.default
                    self.window.options[flag] = self -- Store reference

                    local item_frame = self.window:add_object("Frame", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(1,0,0,34), Parent=items_container, ZIndex=13, LayoutOrder = #items_container:GetChildren() })
                    local name_label = self.window:add_object("TextLabel", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(0.5, 0, 0, 20), Position=UDim2.new(0,2,0,0), TextColor3=Color3.new(1,1,1), TextSize=12, Text=(options.text or flag)..": ", Font=Enum.Font.Gotham, Parent=item_frame, TextXAlignment=Enum.TextXAlignment.Left, ZIndex=14 })
                    local value_entry = self.window:add_object("TextBox", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(0.5, -2, 0, 20), Position=UDim2.new(0.5, 0, 0, 0), TextColor3=Color3.new(1,1,1), TextSize=12, Text=tostring(options.default)..(options.suffix or ""), Font=Enum.Font.Gotham, Parent=item_frame, TextXAlignment=Enum.TextXAlignment.Right, ClearTextOnFocus=false, ZIndex=14 })
                    local slider_bg = self.window:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.05,0.05,0.05), BorderSizePixel=1, BorderColor3=Color3.new(0.1,0.1,0.1), Size=UDim2.new(1, -6, 0, 12), Position=UDim2.new(0, 3, 0, 20), Parent=item_frame, ZIndex=14, ClipsDescendants=true })
                    local slider_button = self.window:add_object("TextButton", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(1,0,1,0), Parent=slider_bg, Text="", AutoButtonColor=false, ZIndex=15 })
                    local slider_value_bar = self.window:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(1,0,0), BorderSizePixel=0, Size=UDim2.new(0,0,1,0), Parent=slider_button, ZIndex=16 }) -- Initial size 0

                    local function update_slider(value, from_input)
                       value = math.clamp(value, options.min, options.max)
                       local power = 10^options.decimals
                       value = math.floor(value * power + 0.5) / power -- Round to decimals

                       if self.window.flags[flag] ~= value then
                          self.window.flags[flag] = value
                          if not from_input then -- Update textbox only if not triggered by textbox input
                             value_entry.Text = tostring(value) .. (options.suffix or "")
                          end
                          local percentage = (value - options.min) / (options.max - options.min)
                          slider_value_bar.Size = UDim2.new(percentage, 0, 1, 0)
                          pcall(options.callback, value)
                       end
                    end

                    update_slider(options.default) -- Set initial state

                    -- Slider drag logic (simplified - needs mouse tracking)
                    slider_button.MouseButton1Down:Connect(function(x, y)
                       print("Slider drag started for '"..flag.."' (needs full implementation).")
                       -- Set flag indicating drag started
                       -- Connect to MouseMoved globally or InputChanged on the button
                    end)
                    -- MouseButton1Up / MouseLeave to stop dragging

                    -- Textbox input handling
                    value_entry.FocusLost:Connect(function(enterPressed)
                       if enterPressed then
                          local num = tonumber(value_entry.Text)
                          if num then
                             update_slider(num, true)
                          else
                             value_entry.Text = tostring(self.window.flags[flag]) .. (options.suffix or "") -- Reset if invalid input
                          end
                       else
                           value_entry.Text = tostring(self.window.flags[flag]) .. (options.suffix or "") -- Reset if focus lost without enter
                       end
                    end)

                     -- Add set_value function for config loading
                    self.set_value = function(self_ref, value) -- Use self_ref to avoid capturing self incorrectly
                        update_slider(tonumber(value) or options.default)
                    end

                    if options.ignore then self.window.ignore[flag] = true end
                    return self -- Return the slider object itself
                  end,

                  -- Textbox Method
                  new_textbox = function(self, flag, options)
                     options = options or {}
                     options.callback = options.callback or function() end
                     self.window.flags[flag] = options.default or ""
                     self.window.options[flag] = self -- Store reference

                     local item_frame = self.window:add_object("Frame", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(1,0,0,30), Parent=items_container, ZIndex=13, LayoutOrder = #items_container:GetChildren() })
                     self.window:add_object("TextLabel", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(1, -6, 0, 10), Position=UDim2.new(0,2,0,1), TextColor3=Color3.new(1,1,1), TextSize=12, Text=options.text or flag, Font=Enum.Font.Gotham, Parent=item_frame, TextXAlignment=Enum.TextXAlignment.Left, ZIndex=14 })
                     local entry = self.window:add_object("TextBox", {
                       Name = generate_guid(),
                       BackgroundColor3 = Color3.fromRGB(12, 12, 12),
                       BorderSizePixel = 1,
                       BorderColor3 = Color3.fromRGB(30, 30, 30),
                       Size = UDim2.new(1, -6, 0, 14),
                       Position = UDim2.new(0, 3, 0, 13),
                       Text = self.window.flags[flag],
                       TextColor3 = Color3.fromRGB(255, 255, 255),
                       TextSize = 12,
                       Font = Enum.Font.Gotham,
                       TextXAlignment = Enum.TextXAlignment.Left,
                       Parent = item_frame,
                       ClipsDescendants = true,
                       ClearTextOnFocus = false,
                       ZIndex = 14
                     })

                     local last_value = self.window.flags[flag]
                     entry.FocusLost:Connect(function(enterPressed)
                       if enterPressed then
                          if self.window.flags[flag] ~= entry.Text then
                             self.window.flags[flag] = entry.Text
                             last_value = entry.Text
                             pcall(options.callback, entry.Text)
                          end
                       else
                          entry.Text = last_value -- Revert if focus lost without Enter
                       end
                     end)

                     -- Add set_value function for config loading
                     self.set_value = function(self_ref, value) -- Use self_ref to avoid capturing self incorrectly
                         self_ref.window.flags[flag] = tostring(value)
                         entry.Text = tostring(value)
                         last_value = tostring(value)
                         pcall(options.callback, value)
                     end

                     if options.ignore then self.window.ignore[flag] = true end
                     return self -- Return the textbox object itself
                  end,

                  -- Label Method
                  new_label = function(self, options)
                     options = options or {}
                     local item_frame = self.window:add_object("Frame", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(1,0,0,10), Parent=items_container, ZIndex=13, LayoutOrder = #items_container:GetChildren() })
                     local label = self.window:add_object("TextLabel", {
                       Name = generate_guid(),
                       BackgroundTransparency = 1,
                       BorderSizePixel = 0,
                       Size = UDim2.new(1, -6, 1, 0), -- Full width, full height of item_frame
                       Position = UDim2.new(0, 2, 0, 0), -- Position within item_frame
                       Text = options.text or "Label",
                       TextColor3 = options.unsafe and Color3.fromRGB(182, 182, 101) or Color3.fromRGB(255, 255, 255),
                       TextSize = 12,
                       Font = Enum.Font.Gotham,
                       TextXAlignment = Enum.TextXAlignment.Left,
                       TextYAlignment = Enum.TextYAlignment.Center,
                       Parent = item_frame,
                       ZIndex = 14
                     })
                      -- Add add_keybind and add_colorpicker methods to the label object itself
                      self.add_keybind = function(...) return item.add_keybind(self, ...) end
                      self.add_colorpicker = function(...) return item.add_colorpicker(self, ...) end
                      return self -- Return the label object itself, now with chainable methods
                  end
                }
                _base_3.__index = _base_3

                -- Base Item Class (for inheritance)
                do
                  local _class_4
                  local _base_4 = {
                      -- Common method placeholders or base implementations for items
                      add_keybind = function(self, flag, options)
                          -- Keybind implementation (needs careful handling of input capture and state)
                          -- Placeholder implementation:
                          options = options or {}
                          options.callback = options.callback or function() end
                          self.window.flags[flag] = { state=options.state or false, keycode=options.default, mode=options.mode or "Toggle" }
                          self.window.options[flag] = self -- Store reference

                          local keybind_button = self.window:add_object("TextButton", {
                              Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(0,60,1,0), Position=UDim2.new(1,-62,0,0),
                              TextColor3=Color3.new(0.6,0.6,0.6), TextSize=12, Text="[None]", Font=Enum.Font.GothamSemibold,
                              Parent=self.item_objects[1], -- Assume item_frame is the first object
                              ZIndex=13
                          })

                          local function update_keybind_text()
                              local kb_data = self.window.flags[flag]
                              local key_name = "[None]"
                              if kb_data and kb_data.keycode then
                                  if typeof(kb_data.keycode) == "EnumItem" then
                                      key_name = "["..kb_data.keycode.Name.."]"
                                  elseif type(kb_data.keycode) == "string" then -- Handle mouse buttons etc.
                                      if kb_data.keycode == "MouseButton1" then key_name = "[MB1]"
                                      elseif kb_data.keycode == "MouseButton2" then key_name = "[MB2]"
                                      else key_name = "["..kb_data.keycode.."]" -- Fallback for other strings
                                      end
                                  end
                              end
                              keybind_button.Text = key_name
                          end
                          update_keybind_text() -- Initial text

                          keybind_button.MouseButton1Click:Connect(function()
                              print("Setting keybind for '"..flag.."' (needs full implementation).")
                              keybind_button.Text = "[...]"
                              -- Set state to awaiting input
                              -- Listen for next key/mouse input via UserInputService
                              -- Update self.window.flags[flag].keycode
                              -- Update keybind_button.Text
                              -- Handle Escape/Backspace to clear
                          end)
                          keybind_button.MouseButton2Click:Connect(function()
                              print("Keybind mode selection for '"..flag.."' (needs full implementation).")
                              -- Show mode selection dropdown (Toggle/Hold)
                              -- Update self.window.flags[flag].mode
                          end)

                           -- Add set_value function for config loading
                           self.set_value = function(self_ref, value) -- Use self_ref to avoid capturing self incorrectly
                               if type(value) == "table" then
                                   self_ref.window.flags[flag] = value -- Assume value = {keycode=Enum|string, mode=string, state=bool}
                                   update_keybind_text()
                                   pcall(options.callback, value.state)
                               end
                           end

                          if options.ignore then self.window.ignore[flag] = true end
                          return self -- Return the original item (checkbox, label, etc.) for chaining
                      end,
                      add_colorpicker = function(self, flag, options)
                          -- Colorpicker implementation
                          -- Placeholder implementation:
                          options = options or {}
                          options.default = options.default or {}
                          self.window.flags[flag] = { color = options.default.color or Color3.new(1,1,1), transparency = options.default.transparency or 0 }
                          self.window.options[flag] = self -- Store reference

                          local color_button = self.window:add_object("TextButton", {
                              Name=generate_guid(), Size=UDim2.new(0,35,0,10), Position=UDim2.new(1,-48,0.5,-6),
                              BackgroundColor3=self.window.flags[flag].color, BorderSizePixel=1, BorderColor3=Color3.new(0.3,0.3,0.3),
                              Text="", AutoButtonColor=false, Parent=self.item_objects[1], ZIndex=14
                          })

                          color_button.MouseButton1Click:Connect(function()
                              print("Color picker for '"..flag.."' clicked (needs full implementation).")
                              -- Show self.window.colorpicker_objects[1]
                              -- Position it relative to color_button
                              -- Set current colorpicker state (self.window.current_colorpicker, etc.)
                              -- Update picker visuals based on current color/transparency
                          end)

                           -- Add set_value function for config loading
                           self.set_value = function(self_ref, value) -- Use self_ref to avoid capturing self incorrectly
                               if type(value) == "table" then
                                   self_ref.window.flags[flag] = value -- Assume value = {color=Color3, transparency=number}
                                   color_button.BackgroundColor3 = value.color or Color3.new(1,1,1)
                                   -- Callback might not be needed here unless color change itself triggers something
                               end
                           end

                          if options.ignore then self.window.ignore[flag] = true end
                          return self -- Return the original item for chaining
                      end
                  }
                  _base_4.__index = _base_4
                  _class_4 = setmetatable({
                      __init = function() end, -- Base class doesn't need init
                      __base = _base_4,
                      __name = "item"
                  }, { __index = _base_4 })
                  _base_4.__class = _class_4
                  item = _class_4 -- Assign to forward-declared variable
                end

                _class_3 = setmetatable({
                  __init = function(self, parent_tab_obj)
                    self.parent = parent_tab_obj -- Reference to the tab object
                    self.group_objects = {} -- Store GUI instances specific to this group instance if needed
                  end,
                  __base = _base_3,
                  __name = "group"
                }, {
                  __index = _base_3,
                  __call = function(cls, ...)
                    local _self_0 = setmetatable({}, _base_3)
                    cls.__init(_self_0, ...)
                    return _self_0
                  end
                })
                _base_3.__class = _class_3
                group = _class_3
              end
              return group(self) -- Instantiate and return the group object
            end
          }
          _base_2.__index = _base_2
          _class_2 = setmetatable({
            __init = function(self, parent_window_obj)
              self.parent = parent_window_obj -- Reference to the main window object
              -- Setup left/right scrolling frames and layouts for this tab's content frame
              self.left_group = self.parent:add_object("ScrollingFrame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.05,0.05,0.05), BorderSizePixel=0, Size=UDim2.new(0.5,-1,1,0), Position=UDim2.new(0,0,0,0), Parent=tab_content_frame, ClipsDescendants=true, AutomaticCanvasSize=Enum.AutomaticSize.Y, ScrollBarThickness=3, ScrollBarImageColor3=Color3.new(1,0,0), VerticalScrollBarInset=Enum.ScrollBarInset.ScrollBar, CanvasSize=UDim2.new(), BottomImage="", TopImage="", MidImage=assets.square, ZIndex=10 })
              self.right_group = self.parent:add_object("ScrollingFrame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.05,0.05,0.05), BorderSizePixel=0, Size=UDim2.new(0.5,-1,1,0), Position=UDim2.new(0.5,1,0,0), Parent=tab_content_frame, ClipsDescendants=true, AutomaticCanvasSize=Enum.AutomaticSize.Y, ScrollBarThickness=3, ScrollBarImageColor3=Color3.new(1,0,0), VerticalScrollBarInset=Enum.ScrollBarInset.ScrollBar, CanvasSize=UDim2.new(), BottomImage="", TopImage="", MidImage=assets.square, ZIndex=10 })
              self.left_group_objects = { self.parent:add_object("UIListLayout", { Name=generate_guid(), FillDirection=Enum.FillDirection.Vertical, Padding=UDim.new(0,4), Parent=self.left_group, SortOrder=Enum.SortOrder.LayoutOrder }), self.parent:add_object("UIPadding", { Name=generate_guid(), PaddingBottom=UDim.new(0,1), PaddingLeft=UDim.new(0,1), PaddingRight=UDim.new(0,2), PaddingTop=UDim.new(0,1), Parent=self.left_group }) }
              self.right_group_objects = { self.parent:add_object("UIListLayout", { Name=generate_guid(), FillDirection=Enum.FillDirection.Vertical, Padding=UDim.new(0,4), Parent=self.right_group, SortOrder=Enum.SortOrder.LayoutOrder }), self.parent:add_object("UIPadding", { Name=generate_guid(), PaddingBottom=UDim.new(0,1), PaddingLeft=UDim.new(0,2), PaddingRight=UDim.new(0,1), PaddingTop=UDim.new(0,1), Parent=self.right_group }) }
              -- Horizontal layout for the left/right group frames
              self.parent:add_object("UIListLayout", { Name=generate_guid(), FillDirection=Enum.FillDirection.Horizontal, Parent=tab_content_frame, SortOrder=Enum.SortOrder.LayoutOrder })
            end,
            __base = _base_2,
            __name = "tab"
          }, {
            __index = _base_2,
            __call = function(cls, ...)
              local _self_0 = setmetatable({}, _base_2)
              cls.__init(_self_0, ...)
              return _self_0
            end
          })
          _base_2.__class = _class_2
          tab = _class_2
        end
        self.tabs[name] = tab(self) -- Store the tab object instance
        return self.tabs[name]
      end,

      set_active_tab = function(self, idx)
        idx = idx or 1
        if self.active_tab == idx then return end -- No change needed

        self.active_tab = idx
        -- Update tab button appearance
        for i, tab_btn in ipairs(self.tab_objects) do
           if tab_btn and tab_btn.Parent then -- Check if object exists
              tab_btn.TextColor3 = (i == self.active_tab) and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 255)
           end
        end
        -- Update tab content visibility
        for i, group_frame in ipairs(self.tab_groups) do
           if group_frame and group_frame.Parent then -- Check if object exists
              group_frame.Visible = (i == self.active_tab)
           end
        end
      end,

      add_object = function(self, type, info)
        -- Utility function to create instances and track them for later destruction
        type = type or ""
        info = info or {}
        local instance = Instance.new(type)
        for key, value in pairs(info) do
           pcall(function() instance[key] = value end) -- Set properties safely
        end
        table.insert(self.objects, instance) -- Track the object
        return instance
      end,

      destroy = function(self)
        -- Disconnect all signals
        for _, connection in ipairs(self.connections) do
          pcall(connection.Disconnect, connection)
        end
        self.connections = {} -- Clear connections table

        -- Destroy all created GUI objects
        for _, object in ipairs(self.objects) do
          pcall(object.Destroy, object)
        end
        self.objects = {} -- Clear objects table

        -- Clear other state tables
        self.tabs = {}
        self.tab_objects = {}
        self.tab_groups = {}
        self.flags = {}
        self.options = {}
        self.ignore = {}
        self.keybind_objects = {}
        self.colorpicker_objects = {}
        self.background_objects = {}
        self.group_objects = {}
        self.title_objects = {}
        self.tab_bar_objects = {}

        -- Clear global references if this instance was stored there
        if getgenv().window == self then
           getgenv().window = nil
        end
        if getgenv().flags == self.flags then
           getgenv().flags = nil
        end
         if getgenv().options == self.options then
           getgenv().options = nil
        end
      end
    }
    _base_1.__index = _base_1
    _class_1 = setmetatable({
      __init = function(self, title, position, size)
        self.objects = {} -- Stores all created GUI instances for easy cleanup
        self.connections = {} -- Stores all signal connections
        self.dragging = false
        self.mouse_inside = false
        self.window_id = generate_guid()
        self.position = position
        self.size = size
        self.title = title

        -- State storage
        self.flags = {} -- Stores the current value of options (flags["mycheckbox"] = true)
        self.options = {} -- Stores the option objects themselves (options["mycheckbox"] = checkbox_obj)
        self.ignore = {} -- Flags to ignore during config save/load

        -- References for global access if needed (use with caution)
        getgenv().flags = self.flags
        getgenv().options = self.options

        -- Create main ScreenGui
        self.window = self:add_object("ScreenGui", {
          Name = self.window_id,
          ResetOnSpawn = false,
          DisplayOrder = 999, -- High display order
          Parent = CoreGui,
          Enabled = true -- Start enabled
        })
        -- syn.protect_gui(self.window) -- Removed Synapse-specific protection

        -- Create background frames (for border effect)
        self.background_objects = {
          self:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.05,0.05,0.05), BorderSizePixel=0, Size=self.size, Position=self.position, Parent=self.window, ZIndex=0 }),
          self:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.1,0.1,0.1), BorderSizePixel=0, Size=self.size-UDim2.new(0,2,0,2), Position=self.position+UDim2.new(0,1,0,1), Parent=self.window, ZIndex=1 }),
          self:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.05,0.05,0.05), BorderSizePixel=0, Size=self.size-UDim2.new(0,4,0,4), Position=self.position+UDim2.new(0,2,0,2), Parent=self.window, ClipsDescendants=true, ZIndex=2 })
        }

        -- Title Bar elements
        self.title_objects = {
          self:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.08,0.08,0.08), BorderSizePixel=0, Size=UDim2.new(1,0,0,20), Position=UDim2.new(0,0,0,0), Parent=self.background_objects[3], ZIndex=3 }),
          self:add_object("TextLabel", { Name=generate_guid(), BackgroundTransparency=1, TextColor3=Color3.new(1,1,1), TextSize=12, Text=self.title, Font=Enum.Font.Gotham, Size=UDim2.new(1,-2,1,0), Position=UDim2.new(0,1,0,0), Parent=self.title_objects[1], TextXAlignment=Enum.TextXAlignment.Center, TextYAlignment = Enum.TextYAlignment.Center, ZIndex=4 }),
          self:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(1,0,0), BorderSizePixel=0, Size=UDim2.new(1,0,0,1), Position=UDim2.new(0,0,0,19), Parent=self.title_objects[1], ZIndex=5 }) -- Red underline
        }
        -- Add gradient to underline (optional visual flair)
        self:add_object("UIGradient", { Name=generate_guid(), Color=ColorSequence.new(Color3.new(1,0,0)), Rotation=0, Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1), NumberSequenceKeypoint.new(0.5,0), NumberSequenceKeypoint.new(1,1)}), Parent=self.title_objects[3] })

        -- Tab Bar elements
        self.tab_bar_objects = {
          self:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.1,0.1,0.1), BorderSizePixel=0, Size=UDim2.new(1,0,0,20), Position=UDim2.new(0,0,0,20), Parent=self.background_objects[3], ZIndex=6 }),
          self:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.08,0.08,0.08), BorderSizePixel=0, Size=UDim2.new(1,-2,1,-2), Position=UDim2.new(0,1,0,1), Parent=self.tab_bar_objects[1], ZIndex=7, ClipsDescendants=true })
        }

        -- Main container for tab content groups
        self.group_objects = {
          self:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.05,0.05,0.05), BorderSizePixel=0, Size=UDim2.new(1,0,1,-40), Position=UDim2.new(0,0,0,40), Parent=self.background_objects[3], ClipsDescendants=true, ZIndex=3 })
        }

        -- Initialize tab management tables
        self.tabs = {}
        self.tab_objects = {}
        self.tab_groups = {}
        self.active_tab = nil -- Will be set by the first call to new_tab

        -- Dragging logic for the window title bar
        local drag_start_pos
        local drag_start_offset
        local mouse_button_down = function(input)
           if input.UserInputType == Enum.UserInputType.MouseButton1 then
              -- Check if click is within the title bar area
              local title_bar = self.title_objects[1]
              if input.Position.X >= title_bar.AbsolutePosition.X and input.Position.X <= title_bar.AbsolutePosition.X + title_bar.AbsoluteSize.X and
                 input.Position.Y >= title_bar.AbsolutePosition.Y and input.Position.Y <= title_bar.AbsolutePosition.Y + title_bar.AbsoluteSize.Y then
                 self.dragging = true
                 drag_start_pos = input.Position
                 drag_start_offset = self.position
              end
           end
        end
        local mouse_button_up = function(input)
           if input.UserInputType == Enum.UserInputType.MouseButton1 then
              self.dragging = false
           end
        end
        local mouse_moved = function(input)
           if self.dragging then
              local delta = input.Position - drag_start_pos
              self.position = drag_start_offset + UDim2.new(0, delta.X, 0, delta.Y)
              self:update() -- Update background positions
           end
        end

        -- Connect dragging signals to the main ScreenGui to capture input anywhere
        table.insert(self.connections, self.window.InputBegan:Connect(mouse_button_down))
        table.insert(self.connections, self.window.InputEnded:Connect(mouse_button_up))
        table.insert(self.connections, self.window.InputChanged:Connect(mouse_moved))

        -- Initialize Dropdown Container (used by new_list)
        self.drop_container = self:add_object("ScrollingFrame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.08,0.08,0.08), BorderSizePixel=1, BorderColor3=Color3.new(0.1,0.1,0.1), Size=UDim2.new(0,179,0,100), Position=UDim2.new(), Parent=self.window, ClipsDescendants=true, Visible=false, ZIndex=9999, CanvasSize=UDim2.new(), ScrollBarThickness=3, ScrollBarImageColor3=Color3.new(1,0,0), AutomaticCanvasSize=Enum.AutomaticSize.Y, TopImage="", BottomImage="", MidImage=assets.square, VerticalScrollBarInset=Enum.ScrollBarInset.ScrollBar })
        self:add_object("UIPadding", { Name=generate_guid(), PaddingTop=UDim.new(0,2), PaddingBottom=UDim.new(0,2), PaddingLeft=UDim.new(0,2), PaddingRight=UDim.new(0,3), Parent=self.drop_container })
        self:add_object("UIListLayout", { Name=generate_guid(), Padding=UDim.new(0,3), Parent=self.drop_container, SortOrder=Enum.SortOrder.LayoutOrder })
        self.drop_flag = nil -- Tracks which list dropdown is currently open

        -- Initialize Keybind Mode Selector Container
        self.keybind_objects = { self:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.08,0.08,0.08), BorderSizePixel=1, BorderColor3=Color3.new(0.1,0.1,0.1), Size=UDim2.new(0,50,0,40), Position=UDim2.new(), Parent=self.window, Visible=false, ZIndex=9999 }) }
        self:add_object("UIListLayout", { Name=generate_guid(), FillDirection=Enum.FillDirection.Vertical, Parent=self.keybind_objects[1], SortOrder=Enum.SortOrder.LayoutOrder })
        local toggle_button = self:add_object("TextButton", { Name=generate_guid(), Text="Toggle", TextColor3=Color3.new(1,1,1), Font=Enum.Font.Gotham, TextSize=12, BackgroundTransparency=1, Size=UDim2.new(1,0,0.5,0), Parent=self.keybind_objects[1], ZIndex=10000 })
        local hold_button = self:add_object("TextButton", { Name=generate_guid(), Text="Hold", TextColor3=Color3.new(1,1,1), Font=Enum.Font.Gotham, TextSize=12, BackgroundTransparency=1, Size=UDim2.new(1,0,0.5,0), Parent=self.keybind_objects[1], ZIndex=10000 })
        self.current_keybind = nil -- Tracks which keybind mode selector is open
        table.insert(self.connections, toggle_button.MouseButton1Click:Connect(function() if self.current_keybind and self.flags[self.current_keybind] then self.flags[self.current_keybind].mode = "Toggle"; self.keybind_objects[1].Visible = false end end))
        table.insert(self.connections, hold_button.MouseButton1Click:Connect(function() if self.current_keybind and self.flags[self.current_keybind] then self.flags[self.current_keybind].mode = "Hold"; self.keybind_objects[1].Visible = false end end))

        -- Initialize Color Picker Container and elements (simplified - needs interaction logic)
        self.colorpicker_objects = { self:add_object("Frame", { Name=generate_guid(), BackgroundColor3=Color3.new(0.08,0.08,0.08), BorderSizePixel=1, BorderColor3=Color3.new(0.1,0.1,0.1), Size=UDim2.new(0,214,0,182), Position=UDim2.new(), Parent=self.window, Visible=false, ZIndex=9999 }) }
        self.colorpicker = self:add_object("TextButton", { Name=generate_guid(), BackgroundColor3=Color3.new(1,0,0), BorderSizePixel=0, Size=UDim2.new(0,180,0,180), Position=UDim2.new(0,1,0,1), Parent=self.colorpicker_objects[1], Text="", AutoButtonColor=false, ZIndex=10000 })
        self:add_object("ImageLabel", { Name=generate_guid(), BackgroundTransparency=1, Image=assets.colorpicker, Size=UDim2.new(1,0,1,0), Parent=self.colorpicker, ZIndex=10001 })
        self.location = self:add_object("Frame", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(0,10,0,10), Position=UDim2.new(1,-10,0,0), Parent=self.colorpicker, ZIndex=10002 })
        self:add_object("ImageLabel", { Name=generate_guid(), BackgroundTransparency=1, Image=assets.colorpicker_location, Size=UDim2.new(1,0,1,0), Parent=self.location, ZIndex=10003 })
        local slider_group = self:add_object("Frame", { Name=generate_guid(), BackgroundTransparency=1, Size=UDim2.new(0,32,0,181), Position=UDim2.new(0,181,0,0), Parent=self.colorpicker_objects[1], ZIndex=10000 })
        self.hue_slider = self:add_object("TextButton", { Name=generate_guid(), BackgroundColor3=Color3.new(1,1,1), BorderSizePixel=0, Size=UDim2.new(0,15,0.994,0), Position=UDim2.new(0,1,0,1), Parent=slider_group, AutoButtonColor=false, Text="", ZIndex=10001 })
        self:add_object("UIGradient", { Name=generate_guid(), Color=ColorSequence.new({unpack((function() local t={} for i=0,360,36 do table.insert(t,ColorSequenceKeypoint.new(i/360,Color3.fromHSV(i/360,1,1))) end return t end)())}), Rotation=90, Parent=self.hue_slider })
        self.hue_slider_location = self:add_object("ImageLabel", { Name=generate_guid(), BackgroundTransparency=1, Image=assets.slider_location, Size=UDim2.new(0,15,0,5), Parent=self.hue_slider, ZIndex=10002 })
        self.opacity_slider = self:add_object("TextButton", { Name=generate_guid(), BackgroundColor3=Color3.new(1,0,0), BorderSizePixel=0, Size=UDim2.new(0,15,0.994,0), Position=UDim2.new(0,17,0,1), Parent=slider_group, AutoButtonColor=false, Text="", ZIndex=10002 })
        self:add_object("ImageLabel", { Name=generate_guid(), BackgroundTransparency=1, Image=assets.transparent_pattern, Size=UDim2.new(1,0,1,0), Parent=self.opacity_slider, ScaleType=Enum.ScaleType.Tile, TileSize=UDim2.new(0,15,0,18), ZIndex=10001 }) -- Transparency pattern below gradient
        self:add_object("UIGradient", { Name=generate_guid(), Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,1)}), Rotation=90, Parent=self.opacity_slider })
        self.opacity_slider_location = self:add_object("ImageLabel", { Name=generate_guid(), BackgroundTransparency=1, Image=assets.slider_location, Size=UDim2.new(0,15,0,5), Parent=self.opacity_slider, ZIndex=10003 })
        self.current_colorpicker = nil -- Tracks which color flag is being edited
        self.current_colorbox = nil -- Tracks the button associated with the current colorpicker

        -- Simplified color picker interaction logic (needs full implementation)
        local function update_colorpicker_logic() print("Color picker interaction needs full implementation.") end
        table.insert(self.connections, self.colorpicker.MouseButton1Down:Connect(update_colorpicker_logic))
        table.insert(self.connections, self.hue_slider.MouseButton1Down:Connect(update_colorpicker_logic))
        table.insert(self.connections, self.opacity_slider.MouseButton1Down:Connect(update_colorpicker_logic))
        -- Need MouseButton1Up, MouseMoved, MouseLeave connections as well

      end,
      __base = _base_1,
      __name = "window"
    }, {
      __index = _base_1,
      __call = function(cls, ...)
        local _self_0 = setmetatable({}, _base_1)
        cls.__init(_self_0, ...)
        return _self_0
      end
    })
    _base_1.__class = _class_1
    window = _class_1 -- Assign class to forward-declared variable
  end
  library = _class_0 -- Assign the main library class
end

local current_library = library() -- Instantiate the library controller
return current_library -- Return the library controller instance
