--[[
  UI lib made by SupremeCreativity (formerly bungie#0001)
  Revised and Enhanced Version

  - Please do not use this without permission. Significant effort has gone into this UI.
    If you wish to use it, please contact the owner.
]]

-- / Locals
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()

-- / Services
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CoreGuiService = game:GetService("CoreGui")
local ContentService = game:GetService("ContentProvider")
local TeleportService = game:GetService("TeleportService")
local HttpService -- Lazily loaded if needed for Discord webhook

-- / SC Library Core Table
local library = {
    version = "3.0.0-SC",
    title = "SC UI " .. tostring(math.random(1, 1000)), -- Default title
    fps = 0,
    rank = "private",
    KeyAccepted = false, -- Flag for key system
    CorrectKey = "hh.hg**@@", -- The key needed to use the UI
    owner = "SupremeCreativity",
    UI_Initialized = false, -- Flag to check if main UI is up
    startTime = 0,
    totalElapsedTime = 0,
    trackingEnabled = false,
    lastSaveTime = 0,
    saveInterval = 60 -- Save usage time every 60 seconds
}

-- / Synapse-Specific Functions Check
local hasSynapse = (syn and syn.request and syn.writefile and syn.readfile and isfile and writefile and readfile)

-- / Usage Time Tracking Functions
local usageTimeSaveFile = "SC_UsageTime_" .. (Player and Player.UserId or "UnknownUser") .. ".dat"
local discordWebhookUrl = "https://discord.com/api/webhooks/1353802030740803684/sjogfRtn6rXRF83IY-Y2b8fULjbQSZY29eXaApOEKBSq8RdqH8P6qy-tdQASb1glu4mm" -- <<< IMPORTANT: REPLACE THIS!

function library:FormatTime(totalSeconds)
    if not totalSeconds or totalSeconds < 0 then return "00:00:00" end
    local hours = math.floor(totalSeconds / 3600)
    local minutes = math.floor((totalSeconds % 3600) / 60)
    local seconds = math.floor(totalSeconds % 60)
    return string.format("%02d:%02d:%02d", hours, minutes, seconds)
end

function library:LoadUsageTime()
    if hasSynapse then
        if isfile(usageTimeSaveFile) then
            local success, data = pcall(readfile, usageTimeSaveFile)
            if success and data then
                library.totalElapsedTime = tonumber(data) or 0
            else
                library.totalElapsedTime = 0
                print("SC Lib: Failed to read usage time file or file is corrupted.")
            end
        else
            library.totalElapsedTime = 0
            print("SC Lib: No previous usage time file found.")
        end
    else
        library.totalElapsedTime = 0 -- Reset if Synapse isn't available for persistence
        print("SC Lib: Synapse file functions not found. Usage time will not persist.")
    end
    library.startTime = os.time()
    library.trackingEnabled = true
    library.lastSaveTime = os.time()
    print("SC Lib: Usage time tracking started. Previous total:", library:FormatTime(library.totalElapsedTime))
end

function library:SaveUsageTime()
    if not library.trackingEnabled then return end

    if hasSynapse then
        local currentTime = os.time()
        local sessionTime = currentTime - library.startTime
        local finalTotal = library.totalElapsedTime + sessionTime
        local success, err = pcall(writefile, usageTimeSaveFile, tostring(finalTotal))
        if not success then
            warn("SC Lib: Failed to save usage time -", err)
        else
            -- Optionally print save confirmation, can be spammy
            -- print("SC Lib: Usage time saved:", library:FormatTime(finalTotal))
        end
    end
    -- No else needed, as non-Synapse time isn't persistent anyway
end

function library:SendTimeToDiscord(totalSeconds)
    if not hasSynapse or discordWebhookUrl == "YOUR_DISCORD_WEBHOOK_URL" then
        -- Silently fail or print a warning if not configured/supported
        -- print("SC Lib: Discord webhook not configured or Synapse HTTP not available.")
        return
    end

    if not HttpService then HttpService = game:GetService("HttpService") end -- Load service if needed

    local data = {
        content = nil,
        embeds = {{
            title = "SC UI Usage Update",
            description = string.format("User **%s** (ID: %d) has used the UI for a total of **%s**.",
                                      Player.Name, Player.UserId, library:FormatTime(totalSeconds)),
            color = 10433279, -- A purple-ish color
            timestamp = os.date("!%Y-%m-%dT%H:%M:%S.000Z"), -- ISO 8601 format
            footer = { text = "SC Library v" .. library.version }
        }},
        username = "SC Usage Tracker",
        avatar_url = "http://www.roblox.com/asset/?id=9365069861" -- Using the old hash logo URL as an example avatar
    }

    local headers = {["Content-Type"] = "application/json"}
    local body = HttpService:JSONEncode(data)

    local success, response = pcall(syn.request, {
        Url = discordWebhookUrl,
        Method = "POST",
        Headers = headers,
        Body = body
    })

    if not success then
        warn("SC Lib: Failed to send usage time to Discord -", response)
    -- else -- Optional: Log successful Discord post
       -- print("SC Lib: Successfully sent usage time to Discord.")
    end
end


-- / FPS Counter Coroutine
coroutine.wrap(function()
    while RunService.RenderStepped:Wait() do
        local dt = RunService.RenderStepped:Wait() -- Get delta time more accurately
        library.fps = math.round(1 / dt)

        -- Periodic Usage Time Saving & Discord Update
        if library.trackingEnabled and os.time() - library.lastSaveTime >= library.saveInterval then
             library:SaveUsageTime()
             -- Send update to discord periodically
             local currentTime = os.time()
             local sessionTime = currentTime - library.startTime
             local currentTotalTime = library.totalElapsedTime + sessionTime
            -- library:SendTimeToDiscord(currentTotalTime) -- Uncomment if Discord webhook is set up
             library.lastSaveTime = os.time() -- Update last save time *after* saving
        end
    end
end)()


-- / Tween table & function
local TweenTable = {
    Default = TweenInfo.new(0.17, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0)
}
local CreateTween = function(name, speed, style, direction, loop, reverse, delay)
    -- Simplified: Ensure name is treated as a string key
    local tweenName = tostring(name)
    speed = speed or 0.17
    style = style or Enum.EasingStyle.Sine
    direction = direction or Enum.EasingDirection.InOut
    loop = loop or 0
    reverse = reverse or false
    delay = delay or 0

    TweenTable[tweenName] = TweenInfo.new(speed, style, direction, loop, reverse, delay)
end

-- Pre-create common tweens
CreateTween("Fast", 0.1)
CreateTween("Slow", 0.5)
CreateTween("Medium", 0.25)
CreateTween("VerySlow", 1.0)
CreateTween("ElasticOut", 0.6, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out)
CreateTween("BounceOut", 0.6, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out)
CreateTween("Smooth", 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)


-- / Dragging (Improved slightly for robustness)
local drag = function(obj, latency)
    obj = obj
    latency = latency or 0.05 -- Slightly faster default latency

    local dragging = false
    local inputObject = nil
    local dragStart = nil
    local startPos = nil
    local dragTween = nil

    local function updateInput(input)
        if not startPos or not dragStart then return end -- Guard clause
        local delta = input.Position - dragStart
        local newPosition = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)

        -- Cancel existing tween if any
        if dragTween and dragTween.PlaybackState == Enum.PlaybackState.Playing then
            dragTween:Cancel()
        end

        -- Create and play new tween
        dragTween = TweenService:Create(obj, TweenInfo.new(latency, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Position = newPosition})
        dragTween:Play()
    end

    obj.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = inp.Position
            startPos = obj.Position
            inputObject = inp -- Store the specific input object

            -- Disconnect previous Changed connection if it exists to avoid multiple listeners
            local changedConnection
            changedConnection = inp.Changed:Connect(function()
                if inp.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    inputObject = nil -- Clear the input object
                    if changedConnection then changedConnection:Disconnect() end -- Disconnect self
                end
            end)
        end
    end)

    -- Use UserInputService.InputChanged for more reliable tracking
    UserInputService.InputChanged:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch then
            if dragging and inputObject then -- Check if we are dragging with a valid start input
                updateInput(inp)
            end
        end
    end)

     obj.InputEnded:Connect(function(inp)
         if inp == inputObject then -- Check if the input ending is the one that started the drag
             dragging = false
             inputObject = nil
         end
     end)
end


-- / Library Utility Functions
function library:RoundNumber(int, float)
    return tonumber(string.format("%." .. (int or 0) .. "f", float))
end

function library:GetUsername()
    return Player.Name
end

function library:CheckIfLoaded()
    return game:IsLoaded()
end

function library:GetUserId()
    return Player.UserId
end

function library:GetPlaceId()
    return game.PlaceId
end

function library:GetJobId()
    return game.JobId
end

function library:Rejoin()
    local placeId = library:GetPlaceId()
    local jobId = library:GetJobId()
    local userId = library:GetUserId()
    if placeId and jobId and userId then
         local success, err = pcall(TeleportService.TeleportToPlaceInstance, TeleportService, placeId, jobId, Player)
         if not success then
             warn("SC Lib Rejoin Failed:", err)
             -- Fallback or notify user?
         end
    else
         warn("SC Lib Rejoin Failed: Could not get PlaceID, JobID, or UserID.")
    end
end

function library:Copy(input) -- only works with synapse
    if hasSynapse then
        local success, err = pcall(syn.write_clipboard, input)
        if not success then warn("SC Lib Copy Failed:", err) end
    else
        warn("SC Lib Copy Failed: Synapse not detected.")
    end
end

-- Date/Time functions remain largely the same, good use of os.date
function library:GetDay(type)
    type = tostring(type):lower()
    if type == "word" then return os.date("%A")
    elseif type == "short" then return os.date("%a")
    elseif type == "month" then return os.date("%d")
    elseif type == "year" then return os.date("%j")
    else return os.date("%A") -- Default to full word
    end
end

function library:GetTime(type)
     type = tostring(type):lower()
     if type == "24h" then return os.date("%H")
     elseif type == "12h" then return os.date("%I")
     elseif type == "minute" then return os.date("%M")
     elseif type == "half" then return os.date("%p")
     elseif type == "second" then return os.date("%S")
     elseif type == "full" then return os.date("%X")
     elseif type == "iso" then return os.date("%z") -- ISO / UTC offset
     elseif type == "zone" then return os.date("%Z")
     else return os.date("%X") -- Default to full time
     end
end

function library:GetMonth(type)
    type = tostring(type):lower()
    if type == "word" then return os.date("%B")
    elseif type == "short" then return os.date("%b")
    elseif type == "digit" then return os.date("%m")
    else return os.date("%B") -- Default to full word
    end
end

function library:GetWeek(type)
     type = tostring(type):lower()
     if type == "year_s" then return os.date("%U") -- Week of year (Sunday start)
     elseif type == "day" then return os.date("%w") -- Day of week (0=Sunday)
     elseif type == "year_m" then return os.date("%W") -- Week of year (Monday start)
     else return os.date("%U") -- Default to Sunday start
     end
end

function library:GetYear(type)
    type = tostring(type):lower()
    if type == "digits" then return os.date("%y") -- Last two digits
    elseif type == "full" then return os.date("%Y") -- Full year
    else return os.date("%Y") -- Default to full year
    end
end

function library:UnlockFps(new) -- syn only
    if hasSynapse then
        local success, err = pcall(setfpscap, new)
        if not success then warn("SC Lib UnlockFps Failed:", err) end
    else
        warn("SC Lib UnlockFps Failed: Synapse not detected.")
    end
end

-- / Watermark Function (Updated text and potentially time display)
function library:Watermark(text)
    -- Cleanup existing watermark
    for _,v in pairs(CoreGuiService:GetChildren()) do
        if v.Name == "SC_Watermark" then
            v:Destroy()
        end
    end

    local baseText = text or ("SC v" .. library.version) -- Use library version

    -- Create UI Elements
    local watermark = Instance.new("ScreenGui")
    watermark.Name = "SC_Watermark"
    watermark.Parent = CoreGuiService
    watermark.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    watermark.DisplayOrder = 999 -- Ensure it's on top

    local watermarkLayout = Instance.new("UIListLayout")
    watermarkLayout.Parent = watermark
    watermarkLayout.FillDirection = Enum.FillDirection.Horizontal
    watermarkLayout.SortOrder = Enum.SortOrder.LayoutOrder
    watermarkLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
    watermarkLayout.Padding = UDim.new(0, 5) -- Slightly more padding

    local watermarkPadding = Instance.new("UIPadding")
    watermarkPadding.Parent = watermark
    watermarkPadding.PaddingBottom = UDim.new(0, 8)
    watermarkPadding.PaddingLeft = UDim.new(0, 8)

    -- Main Watermark Element Function
    local function CreateWatermarkElement(elementText, isTimeElement)
        local edge = Instance.new("Frame")
        edge.Name = "edge"
        edge.Parent = watermark
        edge.BackgroundColor3 = Color3.fromRGB(55, 55, 55) -- Slightly darker edge
        edge.BorderSizePixel = 0
        edge.Size = UDim2.new(0, 0, 0, 26) -- Start small
        edge.BackgroundTransparency = 1 -- Start transparent

        local edgeCorner = Instance.new("UICorner")
        edgeCorner.CornerRadius = UDim.new(0, 3) -- Slightly rounder
        edgeCorner.Parent = edge

        local background = Instance.new("Frame")
        background.Name = "background"
        background.Parent = edge
        background.AnchorPoint = Vector2.new(0.5, 0.5)
        background.BackgroundColor3 = Color3.fromRGB(28, 28, 28) -- Base dark color
        background.BackgroundTransparency = 1 -- Start transparent
        background.ClipsDescendants = true
        background.Position = UDim2.new(0.5, 0, 0.5, 0)
        background.Size = UDim2.new(0, 0, 0, 24) -- Start small
        background.BorderSizePixel = 0

        local backgroundGradient = Instance.new("UIGradient")
        backgroundGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0.00, Color3.fromRGB(40, 40, 40)),
            ColorSequenceKeypoint.new(1.00, Color3.fromRGB(30, 30, 30)) -- Subtle gradient
        }
        backgroundGradient.Rotation = 90
        backgroundGradient.Parent = background

        local backgroundCorner = Instance.new("UICorner")
        backgroundCorner.CornerRadius = UDim.new(0, 2)
        backgroundCorner.Parent = background

        -- Top Accent Bar
        local bar = Instance.new("Frame")
        bar.Name = "bar"
        bar.Parent = background
        bar.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple
        bar.BackgroundTransparency = 1 -- Start transparent
        bar.Size = UDim2.new(0, 0, 0, 2) -- Thicker bar
        bar.Position = UDim2.new(0,0,0,0) -- Position at top
        bar.ZIndex = 2
        bar.BorderSizePixel = 0

        local barCorner = Instance.new("UICorner")
        barCorner.CornerRadius = UDim.new(0, 2)
        barCorner.Parent = bar

        -- Text Label
        local waterText = Instance.new("TextLabel")
        waterText.Name = "waterText"
        waterText.Parent = background
        waterText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        waterText.BackgroundTransparency = 1.000
        waterText.Size = UDim2.new(1, -8, 1, -8) -- Use relative size minus padding
        waterText.Position = UDim2.new(0, 4, 0, 4)
        waterText.Font = Enum.Font.Code
        waterText.Text = elementText
        waterText.TextColor3 = Color3.fromRGB(200, 200, 200) -- Brighter text
        waterText.TextTransparency = 1 -- Start transparent
        waterText.TextSize = 14.000
        waterText.TextXAlignment = Enum.TextXAlignment.Center
        waterText.TextYAlignment = Enum.TextYAlignment.Center
        waterText.RichText = true
        waterText.ZIndex = 3

        -- Calculate size and animate
        local NewSize = TextService:GetTextSize(waterText.Text, waterText.TextSize, waterText.Font, Vector2.new(math.huge, math.huge))
        local targetWidth = NewSize.X + 16 -- More padding

        CreateTween("wm_appear", 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        CreateTween("wm_bar", 0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1)
        CreateTween("wm_text", 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.2)

        coroutine.wrap(function()
            TweenService:Create(edge, TweenTable["wm_appear"], {Size = UDim2.new(0, targetWidth, 0, 26), BackgroundTransparency = 0}):Play()
            TweenService:Create(background, TweenTable["wm_appear"], {Size = UDim2.new(0, targetWidth - 2, 0, 24), BackgroundTransparency = 0.1}):Play() -- Slight transparency
            wait(0.1)
            TweenService:Create(bar, TweenTable["wm_bar"], {Size = UDim2.new(1, 0, 0, 2), BackgroundTransparency = 0.1}):Play() -- Animate bar width too
            wait(0.1)
            TweenService:Create(waterText, TweenTable["wm_text"], {TextTransparency = 0}):Play()
        end)()

        -- Updater function for this specific element
        local function UpdateText(newText)
            local currentText = waterText.Text
            if newText == currentText then return end -- No change needed

            local oldSize = TextService:GetTextSize(currentText, waterText.TextSize, waterText.Font, Vector2.new(math.huge, math.huge))
            local newSize = TextService:GetTextSize(newText, waterText.TextSize, waterText.Font, Vector2.new(math.huge, math.huge))
            local newTargetWidth = newSize.X + 16

            CreateTween("wm_resize", 0.15)
            -- Only resize if needed significantly (optional optimization)
             -- if math.abs((newSize.X + 16) - edge.AbsoluteSize.X) > 2 then
                 TweenService:Create(edge, TweenTable["wm_resize"], {Size = UDim2.new(0, newTargetWidth, 0, 26)}):Play()
                 TweenService:Create(background, TweenTable["wm_resize"], {Size = UDim2.new(0, newTargetWidth - 2, 0, 24)}):Play()
                 -- Bar size is relative (UDim2.new(1,0,...)), so it resizes automatically with parent
             -- end

            -- Update text content
            waterText.Text = newText
        end

        -- If it's the time element, start the updater loop
        if isTimeElement then
            coroutine.wrap(function()
                while edge and edge.Parent do -- Keep updating as long as the element exists
                     if library.trackingEnabled then
                         local currentTime = os.time()
                         local sessionTime = currentTime - library.startTime
                         local displayTime = library.totalElapsedTime + sessionTime
                         UpdateText(library:FormatTime(displayTime))
                     else
                         UpdateText("00:00:00") -- Show zero if not tracking yet
                     end
                    wait(1) -- Update every second
                end
            end)()
        end

        return edge, UpdateText -- Return the main frame and its update function
    end

    -- Create the main watermark text element
    local mainElement, mainUpdater = CreateWatermarkElement(baseText, false)

    -- Create the time tracking element
    local timeElement, timeUpdater = CreateWatermarkElement("00:00:00", true) -- isTimeElement = true

     -- Create the FPS element (optional, can be added to main text too)
    local fpsElement, fpsUpdater
    coroutine.wrap(function()
        wait(0.5) -- Stagger appearance slightly
        fpsElement, fpsUpdater = CreateWatermarkElement("FPS: 0", false)
        while fpsElement and fpsElement.Parent do
            fpsUpdater("FPS: " .. library.fps)
            wait(0.5) -- Update FPS twice per second
        end
    end)()


    -- Watermark Functions Table (Controls the entire watermark group)
    local WatermarkFunctions = {}

    function WatermarkFunctions:AddWatermark(newText)
        -- This function now adds *another* independent element, like the time/FPS ones
        local newElement, newUpdater = CreateWatermarkElement(newText or "New Element", false)

        -- Return controls for the *newly added* element
        local NewWatermarkElementFunctions = {}
        function NewWatermarkElementFunctions:Hide() newElement.Visible = false return NewWatermarkElementFunctions end
        function NewWatermarkElementFunctions:Show() newElement.Visible = true return NewWatermarkElementFunctions end
        function NewWatermarkElementFunctions:Text(txt) newUpdater(txt or "...") return NewWatermarkElementFunctions end
        function NewWatermarkElementFunctions:Remove() newElement:Destroy() return NewWatermarkElementFunctions end
        return NewWatermarkElementFunctions
    end

    function WatermarkFunctions:Hide()
        watermark.Enabled = false
        return WatermarkFunctions
    end

    function WatermarkFunctions:Show()
        watermark.Enabled = true
        return WatermarkFunctions
    end

    function WatermarkFunctions:Text(new) -- Updates the *main* text element
        mainUpdater(new or baseText)
        return WatermarkFunctions
    end

    function WatermarkFunctions:Remove()
        watermark:Destroy()
        -- Optionally clear related update loops if needed (though checking element.Parent should handle it)
        return nil -- Indicate removal
    end

    return WatermarkFunctions
end


-- / Notification System (InitNotifications and Notify)
function library:InitNotifications()
    -- Clean up existing notifications GUI
    for _,v in next, CoreGuiService:GetChildren() do
        if v.Name == "SC_Notifications" then
            v:Destroy()
        end
    end

    local Notifications = Instance.new("ScreenGui")
    Notifications.Name = "SC_Notifications"
    Notifications.Parent = CoreGuiService
    Notifications.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Notifications.DisplayOrder = 998 -- Below watermark but high

    local notificationsLayout = Instance.new("UIListLayout")
    notificationsLayout.Name = "notificationsLayout"
    notificationsLayout.Parent = Notifications
    notificationsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    notificationsLayout.Padding = UDim.new(0, 6) -- Increased padding
    notificationsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    notificationsLayout.VerticalAlignment = Enum.VerticalAlignment.Top -- Top-left corner

    local notificationsPadding = Instance.new("UIPadding")
    notificationsPadding.Name = "notificationsPadding"
    notificationsPadding.Parent = Notifications
    notificationsPadding.PaddingLeft = UDim.new(0, 10)
    notificationsPadding.PaddingTop = UDim.new(0, 10) -- Push down from the very top

    -- Pre-create notification tweens
    CreateTween("notification_slide_in", 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    CreateTween("notification_fade_out", 0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
    CreateTween("notification_bar_fill", 5, Enum.EasingStyle.Linear) -- Default duration 5s
    CreateTween("notification_resize", 0.2)

    -- Notification Object Creator
    local Notification = {}
    function Notification:Notify(text, duration, type, callback)

        text = text or "Notification."
        duration = duration or 5
        type = tostring(type):lower() or "notification"
        callback = callback or function() end

        -- Notification Elements
        local edge = Instance.new("Frame")
        local edgeCorner = Instance.new("UICorner")
        local background = Instance.new("Frame")
        local bar = Instance.new("Frame") -- Progress/timer bar
        local barCorner = Instance.new("UICorner")
        local backgroundGradient = Instance.new("UIGradient")
        local backgroundCorner = Instance.new("UICorner")
        local notifText = Instance.new("TextLabel")
        local notifPadding = Instance.new("UIPadding")
        local backgroundLayout = Instance.new("UIListLayout") -- Use layout for text vs bar

        edge.Name = "edge"
        edge.Parent = Notifications -- Add to the main container
        edge.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        edge.BackgroundTransparency = 1.000 -- Start hidden
        edge.Size = UDim2.new(0, 0, 0, 30) -- Slightly taller
        edge.BorderSizePixel = 0
        edge.ClipsDescendants = true -- Clip contents

        edgeCorner.CornerRadius = UDim.new(0, 3)
        edgeCorner.Parent = edge

        background.Name = "background"
        background.Parent = edge
        background.AnchorPoint = Vector2.new(0.5, 0.5)
        background.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        background.BackgroundTransparency = 1.000 -- Start hidden
        background.Position = UDim2.new(0.5, 0, 0.5, 0)
        background.Size = UDim2.new(1, -2, 1, -2) -- Fill edge minus border
        background.BorderSizePixel = 0
        background.ClipsDescendants = true

        backgroundGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0.00, Color3.fromRGB(45, 45, 45)),
            ColorSequenceKeypoint.new(1.00, Color3.fromRGB(35, 35, 35))
        }
        backgroundGradient.Rotation = 90
        backgroundGradient.Parent = background

        backgroundCorner.CornerRadius = UDim.new(0, 2)
        backgroundCorner.Parent = background

        -- Configure the layout inside the background
        backgroundLayout.Parent = background
        backgroundLayout.SortOrder = Enum.SortOrder.LayoutOrder
        backgroundLayout.Padding = UDim.new(0, 0) -- No padding between elements
        backgroundLayout.FillDirection = Enum.FillDirection.Vertical

        -- Configure Text Label
        notifText.Name = "notifText"
        notifText.Parent = background -- Add to layout parent
        notifText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        notifText.BackgroundTransparency = 1.000
        notifText.Size = UDim2.new(1, 0, 1, -3) -- Fill width, height minus bar space
        notifText.Font = Enum.Font.Code
        notifText.Text = text
        notifText.TextColor3 = Color3.fromRGB(210, 210, 210)
        notifText.TextSize = 14.000
        notifText.TextTransparency = 1.000 -- Start hidden
        notifText.TextWrapped = true
        notifText.RichText = true
        notifText.TextXAlignment = Enum.TextXAlignment.Left
        notifText.TextYAlignment = Enum.TextYAlignment.Center

        notifPadding.Parent = notifText
        notifPadding.PaddingLeft = UDim.new(0, 6)
        notifPadding.PaddingRight = UDim.new(0, 6)

        -- Configure Progress Bar
        bar.Name = "bar"
        bar.Parent = background -- Add to layout parent
        bar.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- Default SC Purple
        bar.BackgroundTransparency = 0.300 -- Make it semi-transparent
        bar.Size = UDim2.new(0, 0, 0, 3) -- Start width 0, height 3 pixels
        bar.BorderSizePixel = 0

        -- Set bar color based on type
        if type == "alert" then bar.BackgroundColor3 = Color3.fromRGB(255, 200, 50) -- Yellow/Orange
        elseif type == "error" then bar.BackgroundColor3 = Color3.fromRGB(255, 70, 70) -- Red
        elseif type == "success" then bar.BackgroundColor3 = Color3.fromRGB(70, 255, 100) -- Green
        elseif type == "information" then bar.BackgroundColor3 = Color3.fromRGB(70, 150, 255) -- Blue
        end

        barCorner.CornerRadius = UDim.new(0, 2)
        barCorner.Parent = bar

        -- Calculate initial size
        local textSize = TextService:GetTextSize(notifText.Text, notifText.TextSize, notifText.Font, Vector2.new(280, math.huge)) -- Max width 280
        local targetWidth = math.max(150, textSize.X + 14) -- Minimum width 150, plus padding
        local targetHeight = math.max(30, textSize.Y + 12 + 3) -- Min height 30, plus padding and bar height

        -- Animation Coroutine
        local barTween -- Store the bar tween to potentially cancel/modify
        local isRunning = true
        local fadeOutTween = nil

        coroutine.wrap(function()
            -- Animate In
            TweenService:Create(edge, TweenTable["notification_slide_in"], {
                Size = UDim2.new(0, targetWidth, 0, targetHeight),
                BackgroundTransparency = 0
            }):Play()
            TweenService:Create(background, TweenTable["notification_slide_in"], { BackgroundTransparency = 0.1 }):Play()

            local textTween = TweenService:Create(notifText, TweenTable["notification_slide_in"], { TextTransparency = 0 })
            textTween:Play()
            textTween.Completed:Wait() -- Wait for text to be visible before starting timer

            -- Animate Bar Fill
             if duration > 0 then
                 TweenTable["notification_bar_fill"] = TweenInfo.new(duration, Enum.EasingStyle.Linear) -- Update tween info duration
                 barTween = TweenService:Create(bar, TweenTable["notification_bar_fill"], {Size = UDim2.new(1, 0, 0, 3)})
                 barTween:Play()
                 barTween.Completed:Wait()
             else -- If duration is 0 or less, fill instantly and don't auto-fade
                 bar.Size = UDim2.new(1, 0, 0, 3)
                 isRunning = false -- Prevent auto-fade if duration <= 0
                 return -- End coroutine here for infinite notifications
             end

            if not isRunning then return end -- Check if cancelled before fading

            -- Animate Out
            fadeOutTween = TweenService:Create(edge, TweenTable["notification_fade_out"], { BackgroundTransparency = 1 })
            TweenService:Create(background, TweenTable["notification_fade_out"], { BackgroundTransparency = 1 }):Play()
            TweenService:Create(notifText, TweenTable["notification_fade_out"], { TextTransparency = 1 }):Play()
            TweenService:Create(bar, TweenTable["notification_fade_out"], { BackgroundTransparency = 1 }):Play() -- Fade bar too
            fadeOutTween:Play()
            fadeOutTween.Completed:Wait()

            isRunning = false
            pcall(callback) -- Call callback after fade out
            edge:Destroy() -- Clean up
        end)()

        -- Functions returned to control this specific notification
        local NotificationFunctions = {}
        function NotificationFunctions:Text(new)
            if not isRunning then return NotificationFunctions end -- Don't update if fading out
            new = new or text
            notifText.Text = new

            -- Recalculate size and resize smoothly
            local newTextSize = TextService:GetTextSize(notifText.Text, notifText.TextSize, notifText.Font, Vector2.new(280, math.huge))
            local newTargetWidth = math.max(150, newTextSize.X + 14)
            local newTargetHeight = math.max(30, newTextSize.Y + 12 + 3)

            TweenService:Create(edge, TweenTable["notification_resize"], { Size = UDim2.new(0, newTargetWidth, 0, newTargetHeight) }):Play()
            -- Background and text size use relative UDim2 (1, -offset), so they adjust automatically.

            return NotificationFunctions
        end

        function NotificationFunctions:Remove()
             if isRunning then
                 isRunning = false
                 if barTween and barTween.PlaybackState == Enum.PlaybackState.Playing then
                     barTween:Cancel()
                 end
                 if fadeOutTween and fadeOutTween.PlaybackState == Enum.PlaybackState.Playing then
                      fadeOutTween:Cancel() -- Stop fade out if already happening
                 end
                 -- Force fade out immediately
                 TweenService:Create(edge, TweenTable["Fast"], { BackgroundTransparency = 1 }):Play()
                 TweenService:Create(background, TweenTable["Fast"], { BackgroundTransparency = 1 }):Play()
                 TweenService:Create(notifText, TweenTable["Fast"], { TextTransparency = 1 }):Play()
                 TweenService:Create(bar, TweenTable["Fast"], { BackgroundTransparency = 1 }):Play()
                 task.wait(0.15) -- Allow fade tween to finish
                 edge:Destroy()
             elseif edge and edge.Parent then -- If already faded but not destroyed yet
                 edge:Destroy()
             end
             return nil
        end

        return NotificationFunctions
    end
    return Notification -- Return the creator function
end

-- / Enhanced Greeting Animation
function library:ShowGreeting()
    -- Clean up previous greetings if any
    for _,v in pairs(CoreGuiService:GetChildren()) do
        if v.Name == "SC_GreetingScreen" then
            v:Destroy()
        end
    end

    local greetingScreen = Instance.new("ScreenGui")
    greetingScreen.Name = "SC_GreetingScreen"
    greetingScreen.Parent = CoreGuiService
    greetingScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    greetingScreen.DisplayOrder = 1001 -- Highest priority

    -- Full screen semi-transparent background
    local overlay = Instance.new("Frame")
    overlay.Name = "Overlay"
    overlay.Parent = greetingScreen
    overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    overlay.BackgroundTransparency = 1.0 -- Start fully transparent
    overlay.Size = UDim2.new(1, 0, 1, 0)
    overlay.BorderSizePixel = 0

    -- Main Content Frame (Centered)
    local contentFrame = Instance.new("Frame")
    contentFrame.Name = "ContentFrame"
    contentFrame.Parent = overlay
    contentFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    contentFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    contentFrame.Size = UDim2.new(0, 400, 0, 250) -- Size of the greeting box
    contentFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    contentFrame.BackgroundTransparency = 1.0 -- Start transparent
    contentFrame.BorderSizePixel = 1
    contentFrame.BorderColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple Border
    contentFrame.ClipsDescendants = true

    local frameCorner = Instance.new("UICorner")
    frameCorner.CornerRadius = UDim.new(0, 5)
    frameCorner.Parent = contentFrame

    local frameGradient = Instance.new("UIGradient")
    frameGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.00, Color3.fromRGB(45, 45, 45)),
        ColorSequenceKeypoint.new(1.00, Color3.fromRGB(25, 25, 25))
    }
    frameGradient.Rotation = 45 -- Diagonal gradient
    frameGradient.Parent = contentFrame

    -- Logo (using the hash logo provided earlier)
    local logo = Instance.new("ImageLabel")
    logo.Name = "Logo"
    logo.Parent = contentFrame
    logo.AnchorPoint = Vector2.new(0.5, 0.5)
    logo.Size = UDim2.new(0, 100, 0, 100)
    logo.Position = UDim2.new(0.5, 0, 0.4, 0) -- Positioned slightly above center
    logo.Image = "http://www.roblox.com/asset/?id=9365069861"
    logo.ImageColor3 = Color3.fromRGB(159, 115, 255)
    logo.BackgroundTransparency = 1.0
    logo.ImageTransparency = 1.0 -- Start hidden
    logo.Rotation = -180 -- Start rotated

    -- Welcome Text
    local welcomeText = Instance.new("TextLabel")
    welcomeText.Name = "WelcomeText"
    welcomeText.Parent = contentFrame
    welcomeText.AnchorPoint = Vector2.new(0.5, 0.5)
    welcomeText.Size = UDim2.new(0.9, 0, 0, 30)
    welcomeText.Position = UDim2.new(0.5, 0, 0.75, 0) -- Positioned below logo
    welcomeText.Font = Enum.Font.GothamBold -- Use a bolder font
    welcomeText.Text = "Welcome, " .. library:GetUsername()
    welcomeText.TextColor3 = Color3.fromRGB(220, 220, 220)
    welcomeText.TextSize = 20
    welcomeText.BackgroundTransparency = 1.0
    welcomeText.TextTransparency = 1.0 -- Start hidden

    -- Loading/Status Bar
    local loadingBarBg = Instance.new("Frame")
    loadingBarBg.Name = "LoadingBarBg"
    loadingBarBg.Parent = contentFrame
    loadingBarBg.AnchorPoint = Vector2.new(0.5, 1)
    loadingBarBg.Size = UDim2.new(0.8, 0, 0, 6) -- Thin bar at the bottom
    loadingBarBg.Position = UDim2.new(0.5, 0, 0.95, 0)
    loadingBarBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    loadingBarBg.BackgroundTransparency = 1.0 -- Start hidden
    loadingBarBg.BorderSizePixel = 0

    local barBgCorner = Instance.new("UICorner")
    barBgCorner.CornerRadius = UDim.new(0, 3)
    barBgCorner.Parent = loadingBarBg

    local loadingBarFill = Instance.new("Frame")
    loadingBarFill.Name = "LoadingBarFill"
    loadingBarFill.Parent = loadingBarBg
    loadingBarFill.Size = UDim2.new(0, 0, 1, 0) -- Start at 0 width
    loadingBarFill.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple
    loadingBarFill.BorderSizePixel = 0

    local barFillCorner = Instance.new("UICorner")
    barFillCorner.CornerRadius = UDim.new(0, 3)
    barFillCorner.Parent = loadingBarFill

    -- Animation Sequence
    CreateTween("greet_fade_in", 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    CreateTween("greet_logo_spin", 0.7, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, 0.2)
    CreateTween("greet_text_fade", 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.5)
    CreateTween("greet_bar_appear", 0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.7)
    CreateTween("greet_bar_fill", 1.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0.9) -- Loading simulation
    CreateTween("greet_fade_out_all", 0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0.3) -- Fade out delay

    local animCoroutine = coroutine.wrap(function()
        -- Fade in overlay and content frame background
        TweenService:Create(overlay, TweenTable["greet_fade_in"], {BackgroundTransparency = 0.5}):Play()
        local contentTween = TweenService:Create(contentFrame, TweenTable["greet_fade_in"], {BackgroundTransparency = 0})
        contentTween:Play()
        contentTween.Completed:Wait()

        -- Animate Logo
        TweenService:Create(logo, TweenTable["greet_logo_spin"], {ImageTransparency = 0, Rotation = 0}):Play()

        -- Animate Text
        TweenService:Create(welcomeText, TweenTable["greet_text_fade"], {TextTransparency = 0}):Play()

        -- Animate Loading Bar Background
        local barBgTween = TweenService:Create(loadingBarBg, TweenTable["greet_bar_appear"], {BackgroundTransparency = 0.5})
        barBgTween:Play()
        barBgTween.Completed:Wait()

        -- Animate Loading Bar Fill
        local barFillTween = TweenService:Create(loadingBarFill, TweenTable["greet_bar_fill"], {Size = UDim2.new(1, 0, 1, 0)})
        barFillTween:Play()
        barFillTween.Completed:Wait()

        -- Fade Out Everything
        local fadeOutGroup = {overlay, contentFrame, logo, welcomeText, loadingBarBg}
        for _, element in ipairs(fadeOutGroup) do
            if element:IsA("GuiObject") then -- Check if it's a GUI object
                 local targetTransparency = (element.Name == "Overlay") and 1.0 or 1.0 -- Target full transparency for all
                 TweenService:Create(element, TweenTable["greet_fade_out_all"], {BackgroundTransparency = targetTransparency}):Play()
                 if element:FindFirstChildWhichIsA("TextLabel") or element:IsA("TextLabel") then
                     TweenService:Create(element, TweenTable["greet_fade_out_all"], {TextTransparency = 1.0}):Play()
                 end
                 if element:FindFirstChildWhichIsA("ImageLabel") or element:IsA("ImageLabel") then
                     TweenService:Create(element, TweenTable["greet_fade_out_all"], {ImageTransparency = 1.0}):Play()
                 end
            end
        end

        wait(0.7) -- Wait for fade out animation to complete

        -- Initialization finished, can now show the main UI
        library:Init() -- Call the main UI initializer
        greetingScreen:Destroy() -- Clean up the greeting screen

    end)

    animCoroutine()
end

-- / Key System Prompt
function library:RequestKey()
    -- Clean up previous prompts
    for _,v in pairs(CoreGuiService:GetChildren()) do
        if v.Name == "SC_KeyPrompt" then
            v:Destroy()
        end
    end

    -- Create Prompt UI
    local keyPromptScreen = Instance.new("ScreenGui")
    keyPromptScreen.Name = "SC_KeyPrompt"
    keyPromptScreen.Parent = CoreGuiService
    keyPromptScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    keyPromptScreen.DisplayOrder = 1002 -- Absolutely highest

    -- Darkening Overlay
    local overlay = Instance.new("Frame")
    overlay.Name = "Overlay"
    overlay.Parent = keyPromptScreen
    overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    overlay.BackgroundTransparency = 0.3 -- Semi-transparent dark
    overlay.Size = UDim2.new(1, 0, 1, 0)
    overlay.Active = true -- Block clicks behind

    -- Prompt Box
    local promptBox = Instance.new("Frame")
    promptBox.Name = "PromptBox"
    promptBox.Parent = overlay
    promptBox.AnchorPoint = Vector2.new(0.5, 0.5)
    promptBox.Position = UDim2.new(0.5, 0, 0.5, 0)
    promptBox.Size = UDim2.new(0, 350, 0, 180)
    promptBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    promptBox.BorderSizePixel = 1
    promptBox.BorderColor3 = Color3.fromRGB(80, 80, 80)

    local boxCorner = Instance.new("UICorner")
    boxCorner.CornerRadius = UDim.new(0, 4)
    boxCorner.Parent = promptBox

    -- Title
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Parent = promptBox
    titleLabel.Size = UDim2.new(1, 0, 0, 40)
    titleLabel.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
    titleLabel.Font = Enum.Font.GothamSemibold
    titleLabel.Text = "SC UI - Authentication Required"
    titleLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    titleLabel.TextSize = 18

    local titleCorner = Instance.new("UICorner", titleLabel)
    titleCorner.CornerRadius = UDim.new(0,4)
    local titlePadding = Instance.new("UIPadding", titleLabel)
    titlePadding.PaddingLeft = UDim.new(0, 10)

    -- Info/Error Label
    local infoLabel = Instance.new("TextLabel")
    infoLabel.Name = "InfoLabel"
    infoLabel.Parent = promptBox
    infoLabel.AnchorPoint = Vector2.new(0.5, 0)
    infoLabel.Position = UDim2.new(0.5, 0, 0, 50)
    infoLabel.Size = UDim2.new(0.9, 0, 0, 20)
    infoLabel.Font = Enum.Font.Code
    infoLabel.Text = "Please enter the access key:"
    infoLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
    infoLabel.TextSize = 14
    infoLabel.BackgroundTransparency = 1.0

    -- Key Input Textbox
    local keyInput = Instance.new("TextBox")
    keyInput.Name = "KeyInput"
    keyInput.Parent = promptBox
    keyInput.AnchorPoint = Vector2.new(0.5, 0)
    keyInput.Position = UDim2.new(0.5, 0, 0, 80)
    keyInput.Size = UDim2.new(0.8, 0, 0, 35)
    keyInput.Font = Enum.Font.Code
    keyInput.Text = ""
    keyInput.PlaceholderText = "Enter Key..."
    keyInput.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
    keyInput.TextColor3 = Color3.fromRGB(210, 210, 210)
    keyInput.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    keyInput.BorderSizePixel = 1
    keyInput.BorderColor3 = Color3.fromRGB(60, 60, 60)
    keyInput.ClearTextOnFocus = false
    keyInput.TextXAlignment = Enum.TextXAlignment.Center

    local inputCorner = Instance.new("UICorner", keyInput)
    inputCorner.CornerRadius = UDim.new(0, 3)

    -- Submit Button
    local submitButton = Instance.new("TextButton")
    submitButton.Name = "SubmitButton"
    submitButton.Parent = promptBox
    submitButton.AnchorPoint = Vector2.new(0.5, 0)
    submitButton.Position = UDim2.new(0.5, 0, 0, 125)
    submitButton.Size = UDim2.new(0.5, 0, 0, 35)
    submitButton.Font = Enum.Font.GothamSemibold
    submitButton.Text = "Submit"
    submitButton.TextColor3 = Color3.fromRGB(220, 220, 220)
    submitButton.TextSize = 16
    submitButton.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple
    submitButton.AutoButtonColor = false

    local submitCorner = Instance.new("UICorner", submitButton)
    submitCorner.CornerRadius = UDim.new(0, 3)

    -- Button Hover/Click Effects
    CreateTween("btn_hover", 0.1)
    submitButton.MouseEnter:Connect(function()
        TweenService:Create(submitButton, TweenTable["btn_hover"], {BackgroundColor3 = Color3.fromRGB(179, 135, 255)}):Play()
    end)
    submitButton.MouseLeave:Connect(function()
         TweenService:Create(submitButton, TweenTable["btn_hover"], {BackgroundColor3 = Color3.fromRGB(159, 115, 255)}):Play()
    end)
    submitButton.MouseButton1Down:Connect(function()
        TweenService:Create(submitButton, TweenTable["btn_hover"], {BackgroundColor3 = Color3.fromRGB(139, 95, 235)}):Play()
    end)
     submitButton.MouseButton1Up:Connect(function()
         TweenService:Create(submitButton, TweenTable["btn_hover"], {BackgroundColor3 = Color3.fromRGB(179, 135, 255)}):Play()
     end)

    -- Submit Logic
    local function checkKey()
        if keyInput.Text == library.CorrectKey then
            library.KeyAccepted = true
            infoLabel.TextColor3 = Color3.fromRGB(70, 255, 100) -- Green
            infoLabel.Text = "Access Granted. Initializing..."
            submitButton.Active = false -- Disable button after success
            --keyInput.Editable = false
             -- Start Usage Time Tracking
            library:LoadUsageTime()
            task.wait(0.5)
            keyPromptScreen:Destroy() -- Destroy prompt
            library:ShowGreeting() -- Show the fancy greeting
        else
            library.KeyAccepted = false
            infoLabel.TextColor3 = Color3.fromRGB(255, 70, 70) -- Red
            infoLabel.Text = "Incorrect Key. Please try again."
            keyInput.Text = "" -- Clear input on failure

            -- Shake Animation for promptBox on error
            CreateTween("shake", 0.08, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 4, true)
            local startPos = promptBox.Position
            local shakeTween = TweenService:Create(promptBox, TweenTable["shake"], {Position = startPos + UDim2.new(0, 5, 0, 0)})
            shakeTween:Play()
            shakeTween.Completed:Connect(function()
                promptBox.Position = startPos -- Reset position after shake
            end)
        end
    end

    submitButton.MouseButton1Click:Connect(checkKey)
    keyInput.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            checkKey()
        end
    end)

    -- Initial Animation (Fade in prompt)
    overlay.BackgroundTransparency = 1.0
    promptBox.Position = UDim2.new(0.5, 0, 0.45, 0) -- Start slightly up
    promptBox.BackgroundTransparency = 1.0
    titleLabel.BackgroundTransparency = 1.0
    titleLabel.TextTransparency = 1.0
    infoLabel.TextTransparency = 1.0
    keyInput.BackgroundTransparency = 1.0
    keyInput.TextTransparency = 1.0
    keyInput.PlaceholderColor3 = Color3.fromRGB(120, 120, 120) -- Ensure placeholder is visible
    submitButton.BackgroundTransparency = 1.0
    submitButton.TextTransparency = 1.0

    CreateTween("prompt_fade_in", 0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    CreateTween("prompt_elements_fade", 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

    coroutine.wrap(function()
        TweenService:Create(overlay, TweenTable["prompt_fade_in"], {BackgroundTransparency = 0.3}):Play()
        TweenService:Create(promptBox, TweenTable["prompt_fade_in"], {Position = UDim2.new(0.5, 0, 0.5, 0), BackgroundTransparency = 0}):Play()
        wait(0.2)
        TweenService:Create(titleLabel, TweenTable["prompt_elements_fade"], {BackgroundTransparency = 0, TextTransparency = 0}):Play()
        TweenService:Create(infoLabel, TweenTable["prompt_elements_fade"], {TextTransparency = 0}):Play()
        TweenService:Create(keyInput, TweenTable["prompt_elements_fade"], {BackgroundTransparency = 0, TextTransparency = 0}):Play()
        TweenService:Create(submitButton, TweenTable["prompt_elements_fade"], {BackgroundTransparency = 0, TextTransparency = 0}):Play()
    end)()

end


-- / Main UI Initialization Function (library:Init)
function library:Init(keybind)
    -- IMPORTANT: Check if the key was accepted BEFORE initializing the main UI
    if not library.KeyAccepted then
        warn("SC Lib: Cannot initialize UI - Key not accepted.")
        -- Optionally call RequestKey again or just fail silently
        -- library:RequestKey()
        return nil -- Stop initialization
    end

    -- Check if already initialized
    if library.UI_Initialized then
        -- Maybe just toggle visibility? Or warn?
        local existingScreen = CoreGuiService:FindFirstChild("SC_MainScreen")
        if existingScreen then
             existingScreen.Enabled = not existingScreen.Enabled
        end
        -- warn("SC Lib: UI already initialized.")
        return nil -- Prevent re-initialization of elements
    end

    -- Cleanup any old UI with the new name
    for _,v in next, CoreGuiService:GetChildren() do
        if v.Name == "SC_MainScreen" then
            v:Destroy()
        end
    end

    library.title = library.title or "SC UI" -- Use the set title or default
    local toggleKey = keybind or Enum.KeyCode.RightAlt

    -- Create Main ScreenGui
    local screen = Instance.new("ScreenGui")
    screen.Name = "SC_MainScreen"
    screen.Parent = CoreGuiService
    screen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screen.DisplayOrder = 990 -- Below notifications/watermark

    -- Main Window Frame (Edge/Border)
    local edge = Instance.new("Frame")
    edge.Name = "edge"
    edge.Parent = screen
    edge.AnchorPoint = Vector2.new(0.5, 0.5)
    edge.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Darker edge
    edge.Position = UDim2.new(0.5, 0, 0.5, 0)
    edge.Size = UDim2.new(0, 620, 0, 420) -- Slightly larger default size
    edge.BorderSizePixel = 0 -- Use background as border instead

    drag(edge, 0.04) -- Use the improved drag function
    local CanChangeVisibility = true
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and CanChangeVisibility and input.KeyCode == toggleKey then
            screen.Enabled = not screen.Enabled -- Toggle ScreenGui enabled state
        end
    end)

    local edgeCorner = Instance.new("UICorner")
    edgeCorner.CornerRadius = UDim.new(0, 4) -- Slightly more rounded
    edgeCorner.Parent = edge

    -- Main Background Frame
    local background = Instance.new("Frame")
    background.Name = "background"
    background.Parent = edge
    background.AnchorPoint = Vector2.new(0.5, 0.5)
    background.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark main background
    background.Position = UDim2.new(0.5, 0, 0.5, 0)
    background.Size = UDim2.new(1, -2, 1, -2) -- Fill edge minus 1px border on each side
    background.ClipsDescendants = true
    background.BorderSizePixel = 0

    local backgroundCorner = Instance.new("UICorner")
    backgroundCorner.CornerRadius = UDim.new(0, 3) -- Inner frame slightly less rounded
    backgroundCorner.Parent = background

    local backgroundGradient = Instance.new("UIGradient")
    backgroundGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.00, Color3.fromRGB(42, 42, 42)), -- Slightly lighter top
        ColorSequenceKeypoint.new(1.00, Color3.fromRGB(30, 30, 30)) -- Darker bottom
    }
    backgroundGradient.Rotation = 90
    backgroundGradient.Parent = background

    -- Header Area
    local headerFrame = Instance.new("Frame")
    headerFrame.Name = "HeaderFrame"
    headerFrame.Parent = background
    headerFrame.Size = UDim2.new(1, 0, 0, 38)
    headerFrame.BackgroundTransparency = 1.0 -- Header part of main background

    -- Header Title Label
    local headerLabel = Instance.new("TextLabel")
    headerLabel.Name = "headerLabel"
    headerLabel.Parent = headerFrame
    headerLabel.BackgroundTransparency = 1.000
    headerLabel.Size = UDim2.new(1, -12, 1, -12) -- Padding via size
    headerLabel.Position = UDim2.new(0, 6, 0, 6)
    headerLabel.Font = Enum.Font.GothamSemibold -- Nicer font
    headerLabel.Text = library.title
    headerLabel.TextColor3 = Color3.fromRGB(210, 210, 210) -- Brighter title
    headerLabel.TextSize = 18.000
    headerLabel.TextXAlignment = Enum.TextXAlignment.Left
    headerLabel.TextYAlignment = Enum.TextYAlignment.Center
    headerLabel.RichText = true

    -- Header Separator Bar
    local bar = Instance.new("Frame")
    bar.Name = "bar"
    bar.Parent = headerFrame -- Place inside header
    bar.AnchorPoint = Vector2.new(0.5, 1)
    bar.Position = UDim2.new(0.5, 0, 1, 0) -- Position at the bottom of header
    bar.Size = UDim2.new(1, 0, 0, 2) -- Thicker bar
    bar.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple
    bar.BackgroundTransparency = 0.200
    bar.BorderSizePixel = 0

    local barCorner = Instance.new("UICorner")
    barCorner.CornerRadius = UDim.new(0, 1) -- Slight rounding on bar
    barCorner.Parent = bar

    -- Main Content Area (Below Header)
    local contentArea = Instance.new("Frame")
    contentArea.Name = "ContentArea"
    contentArea.Parent = background
    contentArea.AnchorPoint = Vector2.new(0, 1)
    contentArea.Size = UDim2.new(1, 0, 1, -38) -- Fill remaining space below header
    contentArea.Position = UDim2.new(0, 0, 1, 0)
    contentArea.BackgroundTransparency = 1.0

    -- Tab Buttons Area (Left Side)
    local tabButtonsEdge = Instance.new("Frame")
    tabButtonsEdge.Name = "tabButtonsEdge"
    tabButtonsEdge.Parent = contentArea
    tabButtonsEdge.BackgroundColor3 = Color3.fromRGB(45, 45, 45) -- Slightly lighter edge for contrast
    tabButtonsEdge.Position = UDim2.new(0, 8, 0, 8) -- Padding from edge
    tabButtonsEdge.Size = UDim2.new(0, 160, 1, -16) -- Width 160, fill height with padding
    tabButtonsEdge.BorderSizePixel = 0

    local tabButtonCorner = Instance.new("UICorner")
    tabButtonCorner.CornerRadius = UDim.new(0, 3)
    tabButtonCorner.Parent = tabButtonsEdge

    local tabButtons = Instance.new("ScrollingFrame") -- Use ScrollingFrame for tabs
    tabButtons.Name = "tabButtons"
    tabButtons.Parent = tabButtonsEdge
    tabButtons.AnchorPoint = Vector2.new(0.5, 0.5)
    tabButtons.BackgroundColor3 = Color3.fromRGB(35, 35, 35) -- Match inner background
    tabButtons.ClipsDescendants = true
    tabButtons.Position = UDim2.new(0.5, 0, 0.5, 0)
    tabButtons.Size = UDim2.new(1,-2, 1,-2) -- Fill edge minus border
    tabButtons.BorderSizePixel = 0
    tabButtons.CanvasSize = UDim2.new(0,0,0,0) -- Auto-sized by layout
    tabButtons.ScrollBarThickness = 4
    tabButtons.ScrollBarImageColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple scrollbar

    local tabButtonCorner_2 = Instance.new("UICorner")
    tabButtonCorner_2.CornerRadius = UDim.new(0, 2)
    tabButtonCorner_2.Parent = tabButtons

    local tabButtonLayout = Instance.new("UIListLayout")
    tabButtonLayout.Name = "tabButtonLayout"
    tabButtonLayout.Parent = tabButtons
    tabButtonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    tabButtonLayout.SortOrder = Enum.SortOrder.LayoutOrder
    tabButtonLayout.Padding = UDim.new(0, 3) -- Space between tab buttons

    local tabButtonPadding = Instance.new("UIPadding")
    tabButtonPadding.Name = "tabButtonPadding"
    tabButtonPadding.Parent = tabButtons
    tabButtonPadding.PaddingTop = UDim.new(0, 5)
    tabButtonPadding.PaddingBottom = UDim.new(0, 5)

    -- Container Area (Right Side)
    local containerEdge = Instance.new("Frame")
    containerEdge.Name = "containerEdge"
    containerEdge.Parent = contentArea
    containerEdge.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    containerEdge.Position = UDim2.new(0, 176, 0, 8) -- Position right of tabs + padding
    containerEdge.Size = UDim2.new(1, -184, 1, -16) -- Fill remaining width/height with padding
    containerEdge.BorderSizePixel = 0

    local tabButtonCorner_3 = Instance.new("UICorner")
    tabButtonCorner_3.CornerRadius = UDim.new(0, 3)
    tabButtonCorner_3.Parent = containerEdge

    local container = Instance.new("Frame") -- This holds the actual pages (ScrollingFrames)
    container.Name = "container"
    container.Parent = containerEdge
    container.AnchorPoint = Vector2.new(0.5, 0.5)
    container.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    container.Position = UDim2.new(0.5, 0, 0.5, 0)
    container.Size = UDim2.new(1, -2, 1, -2)
    container.ClipsDescendants = true
    container.BorderSizePixel = 0

    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = UDim.new(0, 2)
    containerCorner.Parent = container

    -- Tab Management Logic
    local TabLibrary = {
        IsFirst = true,
        CurrentTab = nil, -- Store the currently active tab button instance
        CurrentPage = nil -- Store the currently active page frame instance
    }
    CreateTween("tab_text_color", 0.20, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
    CreateTween("tab_bg_color", 0.15)

    function TabLibrary:NewTab(title)
        title = title or "Tab"

        -- Tab Button Creation
        local tabButton = Instance.new("TextButton")
        tabButton.Name = title .. "_TabButton"
        tabButton.Parent = tabButtons -- Add to the scrolling frame for tabs
        tabButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55) -- Default tab color
        tabButton.BackgroundTransparency = 0.0 -- Start visible
        tabButton.Size = UDim2.new(1, -10, 0, 28) -- Fill width (-padding), fixed height
        tabButton.AutoButtonColor = false
        tabButton.Font = Enum.Font.GothamSemibold
        tabButton.Text = title
        tabButton.TextColor3 = Color3.fromRGB(170, 170, 170) -- Default text color (inactive)
        tabButton.TextSize = 15.000
        tabButton.RichText = true
        tabButton.ClipsDescendants = true

        local tabBtnCorner = Instance.new("UICorner", tabButton)
        tabBtnCorner.CornerRadius = UDim.new(0, 3)

        -- Page Creation (ScrollingFrame per Tab)
        local page = Instance.new("ScrollingFrame")
        page.Name = title .. "_Page"
        page.Parent = container -- Add pages to the main container frame
        page.Active = true
        page.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- Fully transparent, inherits container bg
        page.BackgroundTransparency = 1.000
        page.BorderSizePixel = 0
        page.Size = UDim2.new(1, 0, 1, 0) -- Fill the container
        page.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be updated by layout
        page.ScrollBarThickness = 6 -- Thicker scrollbar
        page.ScrollBarImageColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple
        page.Visible = false -- Start hidden

        local pageLayout = Instance.new("UIListLayout")
        pageLayout.Name = "pageLayout"
        pageLayout.Parent = page
        pageLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        pageLayout.SortOrder = Enum.SortOrder.LayoutOrder
        pageLayout.Padding = UDim.new(0, 6) -- Padding between elements in the page

        local pagePadding = Instance.new("UIPadding")
        pagePadding.Name = "pagePadding"
        pagePadding.Parent = page
        pagePadding.PaddingLeft = UDim.new(0, 8)
        pagePadding.PaddingRight = UDim.new(0, 8)
        pagePadding.PaddingTop = UDim.new(0, 8)
        pagePadding.PaddingBottom = UDim.new(0, 8)

        -- Tab Button Click Logic
        tabButton.MouseButton1Click:Connect(function()
            if TabLibrary.CurrentTab == tabButton then return end -- Do nothing if already selected

            -- Deactivate previous tab/page
            if TabLibrary.CurrentTab then
                 TweenService:Create(TabLibrary.CurrentTab, TweenTable["tab_text_color"], {TextColor3 = Color3.fromRGB(170, 170, 170)}):Play()
                 TweenService:Create(TabLibrary.CurrentTab, TweenTable["tab_bg_color"], {BackgroundColor3 = Color3.fromRGB(55, 55, 55)}):Play()
            end
            if TabLibrary.CurrentPage then
                TabLibrary.CurrentPage.Visible = false
            end

            -- Activate new tab/page
            TweenService:Create(tabButton, TweenTable["tab_text_color"], {TextColor3 = Color3.fromRGB(255, 255, 255)}):Play() -- White text for active
            TweenService:Create(tabButton, TweenTable["tab_bg_color"], {BackgroundColor3 = Color3.fromRGB(159, 115, 255)}):Play() -- SC Purple background for active
            page.Visible = true

            -- Update current references
            TabLibrary.CurrentTab = tabButton
            TabLibrary.CurrentPage = page
        end)

        -- Set first tab as active
        if TabLibrary.IsFirst then
             TabLibrary.IsFirst = false
             tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
             tabButton.BackgroundColor3 = Color3.fromRGB(159, 115, 255)
             page.Visible = true
             TabLibrary.CurrentTab = tabButton
             TabLibrary.CurrentPage = page
        end

        -- Page Size Update Logic
        local function UpdatePageSize()
            -- Added debounce to prevent excessive updates
            local lastUpdateTime = 0
            local debounceTime = 0.1
            return function()
                local now = tick()
                if now - lastUpdateTime < debounceTime then return end
                lastUpdateTime = now

                task.wait() -- Wait a frame for layout calculations
                local contentSizeY = pageLayout.AbsoluteContentSize.Y
                page.CanvasSize = UDim2.new(0, 0, 0, contentSizeY + pagePadding.PaddingTop.Offset + pagePadding.PaddingBottom.Offset) -- Add padding to canvas size
            end
        end
        local DebouncedUpdatePageSize = UpdatePageSize() -- Create the debounced function instance

        page.ChildAdded:Connect(DebouncedUpdatePageSize)
        page.ChildRemoved:Connect(DebouncedUpdatePageSize)
        pageLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(DebouncedUpdatePageSize) -- Update on content size change too


        -- Components API (functions for adding elements to this tab's page)
        local Components = {}

        -- / Component: Label
        function Components:NewLabel(text, alignment)
             text = text or "Label Text"
             alignment = tostring(alignment):lower() or "left"

             local label = Instance.new("TextLabel")
             label.Name = "label_" .. text:sub(1,10) -- Give a somewhat unique name
             label.Parent = page -- Add to the page's ScrollingFrame
             label.BackgroundTransparency = 1.000
             label.Size = UDim2.new(1, 0, 0, 20) -- Fill width, auto height based on text? No, use TextWrapped + fixed height usually
             label.Font = Enum.Font.Code
             label.Text = text
             label.TextColor3 = Color3.fromRGB(190, 190, 190)
             label.TextSize = 14.000
             label.TextWrapped = true -- Allow wrapping
             label.RichText = true

             -- Set Alignment
             if alignment:find("le") then label.TextXAlignment = Enum.TextXAlignment.Left
             elseif alignment:find("cent") then label.TextXAlignment = Enum.TextXAlignment.Center
             elseif alignment:find("ri") then label.TextXAlignment = Enum.TextXAlignment.Right
             else label.TextXAlignment = Enum.TextXAlignment.Left -- Default left
             end

             -- Adjust size based on text? Only if TextWrapped is false or for single line
             -- local bounds = TextService:GetTextSize(label.Text, label.TextSize, label.Font, Vector2.new(page.AbsoluteSize.X - pagePadding.PaddingLeft.Offset - pagePadding.PaddingRight.Offset, math.huge))
             -- label.Size = UDim2.new(1, 0, 0, math.max(20, bounds.Y)) -- Adjust height dynamically

             task.wait() -- Allow layout to update before calculating final size needed
             DebouncedUpdatePageSize() -- Trigger page resize

             local LabelFunctions = {}
             function LabelFunctions:Text(newText)
                 label.Text = newText or text
                 -- Optionally resize again if text changes significantly
                 -- local bounds = TextService:GetTextSize(label.Text, label.TextSize, label.Font, Vector2.new(page.AbsoluteSize.X - pagePadding.PaddingLeft.Offset - pagePadding.PaddingRight.Offset, math.huge))
                 -- label.Size = UDim2.new(1, 0, 0, math.max(20, bounds.Y))
                 DebouncedUpdatePageSize()
                 return LabelFunctions
             end
             function LabelFunctions:Remove() label:Destroy() DebouncedUpdatePageSize() return nil end
             function LabelFunctions:Hide() label.Visible = false DebouncedUpdatePageSize() return LabelFunctions end
             function LabelFunctions:Show() label.Visible = true DebouncedUpdatePageSize() return LabelFunctions end
             function LabelFunctions:Align(newAlign)
                  newAlign = tostring(newAlign):lower()
                  if newAlign:find("le") then label.TextXAlignment = Enum.TextXAlignment.Left
                  elseif newAlign:find("cent") then label.TextXAlignment = Enum.TextXAlignment.Center
                  elseif newAlign:find("ri") then label.TextXAlignment = Enum.TextXAlignment.Right end
                  return LabelFunctions
             end
             return LabelFunctions
         end

        -- / Component: Button (Improved Style)
        function Components:NewButton(text, callback)
            text = text or "Button"
            callback = callback or function() print(text .. " clicked") end

            local buttonFrame = Instance.new("Frame") -- Container for potential multiple buttons
            buttonFrame.Name = "buttonFrame_" .. text:sub(1,10)
            buttonFrame.Parent = page
            buttonFrame.BackgroundTransparency = 1.000
            buttonFrame.Size = UDim2.new(1, 0, 0, 30) -- Standard button height

            local buttonLayout = Instance.new("UIListLayout") -- Layout for multiple buttons side-by-side
            buttonLayout.Parent = buttonFrame
            buttonLayout.FillDirection = Enum.FillDirection.Horizontal
            buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            buttonLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            buttonLayout.SortOrder = Enum.SortOrder.LayoutOrder
            buttonLayout.Padding = UDim.new(0, 5) -- Space between buttons if multiple are added

            local function CreateSingleButton(btnText, btnCallback, parentFrame, isFirstButton)
                local button = Instance.new("TextButton")
                button.Name = "button_" .. btnText:sub(1,10)
                button.Parent = parentFrame
                button.BackgroundColor3 = Color3.fromRGB(55, 55, 55) -- Default Button Color
                -- Size will be handled by layout if multiple, or fill if single
                 button.Size = isFirstButton and UDim2.new(1, 0, 1, 0) or UDim2.new(0, 100, 1, 0) -- Placeholder size for layout, real size depends on siblings
                 button.LayoutOrder = parentFrame.ChildAdded:Connect(function() end) -- Use event connection for order
                 if isFirstButton then
                      button.Size = UDim2.new(1, 0, 1, 0) -- First button fills frame initially
                 end

                button.AutoButtonColor = false
                button.Font = Enum.Font.GothamSemibold
                button.Text = btnText
                button.TextColor3 = Color3.fromRGB(200, 200, 200)
                button.TextSize = 14.000
                button.ClipsDescendants = true

                local buttonCorner = Instance.new("UICorner")
                buttonCorner.CornerRadius = UDim.new(0, 3)
                buttonCorner.Parent = button

                -- Hover/Click Effects
                button.MouseEnter:Connect(function()
                    TweenService:Create(button, TweenTable["btn_hover"], {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play()
                end)
                button.MouseLeave:Connect(function()
                    TweenService:Create(button, TweenTable["btn_hover"], {BackgroundColor3 = Color3.fromRGB(55, 55, 55)}):Play()
                end)
                 button.MouseButton1Down:Connect(function()
                     TweenService:Create(button, TweenTable["btn_hover"], {BackgroundColor3 = Color3.fromRGB(159, 115, 255)}):Play() -- Click Flash SC Purple
                 end)
                 button.MouseButton1Up:Connect(function()
                     TweenService:Create(button, TweenTable["btn_hover"], {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play() -- Return to hover color
                 end)

                -- Callback Execution (Wrapped)
                button.MouseButton1Click:Connect(function()
                    local success, err = pcall(btnCallback)
                    if not success then
                        warn("SC Lib Button Error:", err)
                        -- Potentially show a notification here
                         if library.Notify then -- Check if notification system is initialized
                              library.Notify("Button Callback Error: " .. tostring(err), 5, "error")
                         end
                    end
                end)

                local SingleButtonFunctions = {}
                 function SingleButtonFunctions:Text(newText) button.Text = newText or "Button" return SingleButtonFunctions end
                 function SingleButtonFunctions:Remove() button:Destroy(); DebouncedUpdatePageSize(); return nil end
                 function SingleButtonFunctions:Hide() button.Visible = false; DebouncedUpdatePageSize(); return SingleButtonFunctions end
                 function SingleButtonFunctions:Show() button.Visible = true; DebouncedUpdatePageSize(); return SingleButtonFunctions end
                 function SingleButtonFunctions:Fire() pcall(btnCallback) return SingleButtonFunctions end -- Add Fire method
                 function SingleButtonFunctions:SetFunction(newCallback) btnCallback = newCallback or function()end return SingleButtonFunctions end
                 return button, SingleButtonFunctions
            end

            -- Create the first button and its functions
            local firstButton, ButtonFunctions = CreateSingleButton(text, callback, buttonFrame, true)

             -- Function to dynamically resize buttons within the frame
             local function UpdateButtonSizes()
                 task.wait() -- Ensure layout calculation completes
                 local buttons = {}
                 for _, child in ipairs(buttonFrame:GetChildren()) do
                     if child:IsA("TextButton") then
                         table.insert(buttons, child)
                     end
                 end
                 local count = #buttons
                 if count > 0 then
                     local totalPadding = buttonLayout.Padding.Offset * (count - 1)
                     local availableWidth = buttonFrame.AbsoluteSize.X - totalPadding
                     local buttonWidth = availableWidth / count
                     for _, btn in ipairs(buttons) do
                         btn.Size = UDim2.new(0, buttonWidth, 1, 0) -- Set size based on calculation
                     end
                 end
                 DebouncedUpdatePageSize() -- Update the page size after resizing buttons
             end

             -- Connect size updates to child added/removed
             buttonFrame.ChildAdded:Connect(UpdateButtonSizes)
             buttonFrame.ChildRemoved:Connect(UpdateButtonSizes)


            -- AddButton method for the *group*
            function ButtonFunctions:AddButton(addText, addCallback)
                 local buttonsInFrame = 0
                 for _, child in ipairs(buttonFrame:GetChildren()) do
                      if child:IsA("TextButton") then buttonsInFrame = buttonsInFrame + 1 end
                 end

                 if buttonsInFrame >= 4 then
                      warn("SC Lib: Maximum of 4 buttons per row is recommended.")
                      -- return ButtonFunctions -- Optionally prevent adding more
                 end

                 local newButton, NewButtonFunctions = CreateSingleButton(addText or "New Button", addCallback or function() end, buttonFrame, false)

                 -- Trigger resize after adding
                 UpdateButtonSizes()

                 return NewButtonFunctions -- Return functions for the *newly added* button
            end

             task.wait()
             DebouncedUpdatePageSize() -- Initial page size update

            return ButtonFunctions -- Return functions for the *first* button / group controller
        end

        -- / Component: Section Separator
        function Components:NewSection(text)
            text = text or "Section Title"

            local sectionFrame = Instance.new("Frame")
            sectionFrame.Name = "sectionFrame_" .. text:sub(1,10)
            sectionFrame.Parent = page
            sectionFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            sectionFrame.BackgroundTransparency = 1.000
            sectionFrame.Size = UDim2.new(1, 0, 0, 22) -- Height for section

            local sectionLayout = Instance.new("UIListLayout")
            sectionLayout.Parent = sectionFrame
            sectionLayout.FillDirection = Enum.FillDirection.Horizontal
            sectionLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
            sectionLayout.Padding = UDim.new(0, 6) -- Padding between line and text

            -- Left decorative line (optional)
            local leftBar = Instance.new("Frame")
            leftBar.Name = "leftBar"
            leftBar.Parent = sectionFrame
            leftBar.BackgroundColor3 = Color3.fromRGB(70, 70, 70) -- Darker grey line
            leftBar.BorderSizePixel = 0
            leftBar.Size = UDim2.new(0, 30, 0, 1) -- Fixed width line

            -- Section Title Label
            local sectionLabel = Instance.new("TextLabel")
            sectionLabel.Name = "sectionLabel"
            sectionLabel.Parent = sectionFrame
            sectionLabel.BackgroundTransparency = 1.000
            sectionLabel.Size = UDim2.new(0, 0, 1, 0) -- Auto width, fill height
            sectionLabel.Font = Enum.Font.GothamSemibold -- Bolder section title
            sectionLabel.Text = text
            sectionLabel.TextColor3 = Color3.fromRGB(190, 190, 190)
            sectionLabel.TextSize = 14.000
            sectionLabel.TextXAlignment = Enum.TextXAlignment.Left
            sectionLabel.RichText = true
            -- Calculate size needed for the text
            local textSize = TextService:GetTextSize(sectionLabel.Text, sectionLabel.TextSize, sectionLabel.Font, Vector2.new(math.huge, sectionFrame.AbsoluteSize.Y))
            sectionLabel.Size = UDim2.new(0, textSize.X, 1, 0) -- Set width dynamically

            -- Right fill line
            local rightBar = Instance.new("Frame")
            rightBar.Name = "rightBar"
            rightBar.Parent = sectionFrame
            rightBar.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
            rightBar.BorderSizePixel = 0
            rightBar.Size = UDim2.new(1, - (30 + 6 + textSize.X + 6), 0, 1) -- Fill remaining space

            task.wait()
            DebouncedUpdatePageSize()

            local SectionFunctions = {}
            function SectionFunctions:Text(newText)
                 sectionLabel.Text = newText or text
                 -- Recalculate sizes
                 local newTextSize = TextService:GetTextSize(sectionLabel.Text, sectionLabel.TextSize, sectionLabel.Font, Vector2.new(math.huge, sectionFrame.AbsoluteSize.Y))
                 sectionLabel.Size = UDim2.new(0, newTextSize.X, 1, 0)
                 rightBar.Size = UDim2.new(1, - (30 + 6 + newTextSize.X + 6), 0, 1)
                 return SectionFunctions
             end
             function SectionFunctions:Remove() sectionFrame:Destroy(); DebouncedUpdatePageSize(); return nil end
             function SectionFunctions:Hide() sectionFrame.Visible = false; DebouncedUpdatePageSize(); return SectionFunctions end
             function SectionFunctions:Show() sectionFrame.Visible = true; DebouncedUpdatePageSize(); return SectionFunctions end
             return SectionFunctions
        end

        -- / Component: Simple Separator Line
        function Components:NewSeparator()
             local separatorFrame = Instance.new("Frame")
             separatorFrame.Name = "SeparatorLine"
             separatorFrame.Parent = page
             separatorFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 60) -- Separator color
             separatorFrame.BorderSizePixel = 0
             separatorFrame.Size = UDim2.new(1, 0, 0, 1) -- Fill width, 1 pixel high

             task.wait()
             DebouncedUpdatePageSize()

             local SeparatorFunctions = {}
             function SeparatorFunctions:Remove() separatorFrame:Destroy(); DebouncedUpdatePageSize(); return nil end
             function SeparatorFunctions:Hide() separatorFrame.Visible = false; DebouncedUpdatePageSize(); return SeparatorFunctions end
             function SeparatorFunctions:Show() separatorFrame.Visible = true; DebouncedUpdatePageSize(); return SeparatorFunctions end
             return SeparatorFunctions
        end


        -- / Component: Toggle (Checkbox Style)
        function Components:NewToggle(text, default, callback)
             text = text or "Toggle Option"
             default = default or false
             callback = callback or function(state) print(text .. " set to " .. tostring(state)) end

             local toggleFrame = Instance.new("Frame") -- Main container for the toggle row
             toggleFrame.Name = "toggleFrame_" .. text:sub(1,10)
             toggleFrame.Parent = page
             toggleFrame.BackgroundTransparency = 1.0
             toggleFrame.Size = UDim2.new(1, 0, 0, 24) -- Standard height for toggle row

             local toggleLayout = Instance.new("UIListLayout") -- Layout for checkbox and label
             toggleLayout.Parent = toggleFrame
             toggleLayout.FillDirection = Enum.FillDirection.Horizontal
             toggleLayout.VerticalAlignment = Enum.VerticalAlignment.Center
             toggleLayout.SortOrder = Enum.SortOrder.LayoutOrder
             toggleLayout.Padding = UDim.new(0, 8) -- Space between checkbox and label

             -- Checkbox Visual Frame (Button)
             local toggleButton = Instance.new("TextButton") -- Use button for click detection
             toggleButton.Name = "toggleButton"
             toggleButton.Parent = toggleFrame
             toggleButton.Size = UDim2.new(0, 18, 0, 18) -- Checkbox size
             toggleButton.Text = ""
             toggleButton.AutoButtonColor = false
             toggleButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Checkbox border color
             toggleButton.BorderSizePixel = 0

             local btnCorner = Instance.new("UICorner", toggleButton)
             btnCorner.CornerRadius = UDim.new(0, 3)

             -- Inner background of the checkbox
             local toggleBg = Instance.new("Frame")
             toggleBg.Name = "toggleBg"
             toggleBg.Parent = toggleButton
             toggleBg.AnchorPoint = Vector2.new(0.5, 0.5)
             toggleBg.Position = UDim2.new(0.5, 0, 0.5, 0)
             toggleBg.Size = UDim2.new(1, -2, 1, -2) -- Fill minus border
             toggleBg.BackgroundColor3 = Color3.fromRGB(35, 35, 35) -- Checkbox inner color
             toggleBg.BorderSizePixel = 0

             local bgCorner = Instance.new("UICorner", toggleBg)
             bgCorner.CornerRadius = UDim.new(0, 2)

             -- The actual checkmark graphic (Frame)
             local toggleCheck = Instance.new("Frame")
             toggleCheck.Name = "toggleCheck"
             toggleCheck.Parent = toggleBg -- Inside the inner background
             toggleCheck.AnchorPoint = Vector2.new(0.5, 0.5)
             toggleCheck.Position = UDim2.new(0.5, 0, 0.5, 0)
             toggleCheck.Size = UDim2.new(0.7, 0, 0.7, 0) -- Checkmark size relative to inner bg
             toggleCheck.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple Checkmark
             toggleCheck.BackgroundTransparency = 1.0 -- Start hidden (if default is false)
             toggleCheck.BorderSizePixel = 0

             local checkCorner = Instance.new("UICorner", toggleCheck)
             checkCorner.CornerRadius = UDim.new(0, 1)

             -- Label for the Toggle
             local toggleLabel = Instance.new("TextLabel")
             toggleLabel.Name = "toggleLabel"
             toggleLabel.Parent = toggleFrame
             toggleLabel.BackgroundTransparency = 1.0
             toggleLabel.Size = UDim2.new(1, - (18 + 8 + 100), 0, 22) -- Fill remaining width (minus checkbox, padding, and space for keybind potentially)
             toggleLabel.Font = Enum.Font.Code
             toggleLabel.Text = text
             toggleLabel.TextColor3 = Color3.fromRGB(190, 190, 190)
             toggleLabel.TextSize = 14.000
             toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
             toggleLabel.RichText = true

            -- Extras container (for keybinds etc.) aligned to the right
            local Extras = Instance.new("Frame")
            Extras.Name = "Extras"
            Extras.Parent = toggleFrame
            Extras.BackgroundTransparency = 1.0
            Extras.Size = UDim2.new(0, 100, 1, 0) -- Reserve space for extras

            local ExtrasLayout = Instance.new("UIListLayout")
            ExtrasLayout.Parent = Extras
            ExtrasLayout.FillDirection = Enum.FillDirection.Horizontal
            ExtrasLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right -- Align content to the right
            ExtrasLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            ExtrasLayout.SortOrder = Enum.SortOrder.LayoutOrder
            ExtrasLayout.Padding = UDim.new(0, 4)


             -- Toggle Logic
             local On = default
             CreateTween("toggle_check_anim", 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
             local function SetToggleState(state, runCallback)
                 On = state
                 local targetTransparency = On and 0 or 1
                 TweenService:Create(toggleCheck, TweenTable["toggle_check_anim"], {BackgroundTransparency = targetTransparency}):Play()
                 if runCallback then
                     local success, err = pcall(callback, On)
                     if not success then
                          warn("SC Lib Toggle Error:", err)
                          if library.Notify then library.Notify("Toggle Callback Error: " .. tostring(err), 5, "error") end
                     end
                 end
             end

             -- Initial State
             SetToggleState(On, false) -- Set initial state without running callback

             toggleButton.MouseButton1Click:Connect(function()
                 SetToggleState(not On, true) -- Toggle state and run callback
             end)

             -- Label click also toggles
             toggleLabel.InputBegan:Connect(function(input)
                  if input.UserInputType == Enum.UserInputType.MouseButton1 then
                       SetToggleState(not On, true)
                  end
             end)

             task.wait()
             DebouncedUpdatePageSize()

             -- Toggle Functions API
             local ToggleFunctions = {}
             function ToggleFunctions:Text(newText)
                 toggleLabel.Text = newText or text
                 return ToggleFunctions
             end
             function ToggleFunctions:Hide() toggleFrame.Visible = false; DebouncedUpdatePageSize(); return ToggleFunctions end
             function ToggleFunctions:Show() toggleFrame.Visible = true; DebouncedUpdatePageSize(); return ToggleFunctions end
             function ToggleFunctions:Change() SetToggleState(not On, true); return ToggleFunctions end -- Manually trigger change + callback
             function ToggleFunctions:Remove() toggleFrame:Destroy(); DebouncedUpdatePageSize(); return nil end
             function ToggleFunctions:Set(state) SetToggleState(state, true); return ToggleFunctions end -- Set specific state + callback
             function ToggleFunctions:GetState() return On end -- Get current state
             function ToggleFunctions:SetFunction(newCallback)
                 callback = newCallback or function() end
                 return ToggleFunctions
             end

             -- / Sub-Component: AddKeybind for Toggle
             function ToggleFunctions:AddKeybind(defaultKey, keybindCallback)
                 defaultKey = defaultKey or Enum.KeyCode.P -- Default keybind
                 local currentKey = defaultKey
                 local keybindActive = true
                 local listening = false

                 -- Optional separate callback for the keybind itself
                 local kbCallback = keybindCallback or callback -- Use toggle's callback if none specific provided

                 local keybindButton = Instance.new("TextButton")
                 keybindButton.Name = "keybindButton"
                 keybindButton.Parent = Extras -- Add to the Extras frame
                 keybindButton.Size = UDim2.new(0, 60, 0, 20) -- Size for the keybind display
                 keybindButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                 keybindButton.BorderSizePixel = 0
                 keybindButton.AutoButtonColor = false
                 keybindButton.Font = Enum.Font.Code
                 keybindButton.Text = currentKey.Name -- Display initial key name
                 keybindButton.TextColor3 = Color3.fromRGB(160, 160, 160)
                 keybindButton.TextSize = 12

                 local kbCorner = Instance.new("UICorner", keybindButton)
                 kbCorner.CornerRadius = UDim.new(0, 3)

                 -- Resize based on text
                 local function ResizeKeybindButton()
                      local keyTextSize = TextService:GetTextSize(keybindButton.Text, keybindButton.TextSize, keybindButton.Font, Vector2.new(math.huge, keybindButton.AbsoluteSize.Y))
                      local newWidth = math.max(40, keyTextSize.X + 10) -- Minimum width 40
                      keybindButton.Size = UDim2.new(0, newWidth, 0, 20)
                 end
                 ResizeKeybindButton() -- Initial resize

                 -- Keybind Click Logic (To Change Key)
                 keybindButton.MouseButton1Click:Connect(function()
                     if listening then return end -- Prevent multi-clicks while listening
                     listening = true
                     keybindButton.Text = "..."
                     keybindButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- White while listening
                     ResizeKeybindButton()

                     local connection
                     connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                         if not gameProcessed and input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.MouseButton2 and input.KeyCode ~= Enum.KeyCode.Unknown then
                             currentKey = input.KeyCode
                             keybindButton.Text = currentKey.Name
                             listening = false
                             keybindButton.TextColor3 = Color3.fromRGB(160, 160, 160) -- Back to default color
                             ResizeKeybindButton()
                             if connection then connection:Disconnect() end -- Disconnect listener
                         elseif input.KeyCode == Enum.KeyCode.Escape then -- Allow canceling with Escape
                              keybindButton.Text = currentKey.Name -- Revert to old key
                              listening = false
                              keybindButton.TextColor3 = Color3.fromRGB(160, 160, 160)
                              ResizeKeybindButton()
                              if connection then connection:Disconnect() end
                         end
                     end)
                 end)

                 -- Actual Keybind Activation Logic
                 UserInputService.InputBegan:Connect(function(input, gameProcessed)
                      if keybindActive and not gameProcessed and not listening and input.KeyCode == currentKey then
                          -- Check if a TextBox is focused (basic check)
                          local focused = UserInputService:GetFocusedTextBox()
                          if not focused then
                               SetToggleState(not On, true) -- Toggle the main toggle's state and run its callback
                          end
                      end
                 end)

                local KeybindFunctions = {}
                function KeybindFunctions:SetKey(newKeyEnum)
                    if newKeyEnum and typeof(newKeyEnum) == "EnumItem" and newKeyEnum.EnumType == Enum.KeyCode then
                         currentKey = newKeyEnum
                         keybindButton.Text = currentKey.Name
                         ResizeKeybindButton()
                    else
                         warn("SC Lib SetKey: Invalid KeyCode Enum provided.")
                    end
                    return KeybindFunctions -- Return keybind functions for chaining
                end
                 function KeybindFunctions:Hide() keybindButton.Visible = false return KeybindFunctions end
                 function KeybindFunctions:Show() keybindButton.Visible = true return KeybindFunctions end
                 function KeybindFunctions:Remove() keybindButton:Destroy(); return ToggleFunctions end -- Return main toggle funcs after removal
                 function KeybindFunctions:Disable() keybindActive = false; keybindButton.TextColor3 = Color3.fromRGB(100,100,100) return KeybindFunctions end
                 function KeybindFunctions:Enable() keybindActive = true; keybindButton.TextColor3 = Color3.fromRGB(160,160,160) return KeybindFunctions end

                 return KeybindFunctions -- Return functions specific to the keybind
             end -- End of AddKeybind

             return ToggleFunctions -- Return main toggle functions
        end

        -- / Component: Keybind (Standalone)
        function Components:NewKeybind(text, defaultKey, callback)
             text = text or "Keybind Action"
             defaultKey = defaultKey or Enum.KeyCode.P
             callback = callback or function(key) print(text .. " activated with key " .. key.Name) end

             local keybindFrame = Instance.new("Frame") -- Main container row
             keybindFrame.Name = "keybindFrame_" .. text:sub(1,10)
             keybindFrame.Parent = page
             keybindFrame.BackgroundTransparency = 1.0
             keybindFrame.Size = UDim2.new(1, 0, 0, 24) -- Standard height

             local keybindLayout = Instance.new("UIListLayout") -- Layout for label and button
             keybindLayout.Parent = keybindFrame
             keybindLayout.FillDirection = Enum.FillDirection.Horizontal
             keybindLayout.VerticalAlignment = Enum.VerticalAlignment.Center
             keybindLayout.SortOrder = Enum.SortOrder.LayoutOrder
             keybindLayout.Padding = UDim.new(0, 8)

             -- Keybind Label
             local keybindLabel = Instance.new("TextLabel")
             keybindLabel.Name = "keybindLabel"
             keybindLabel.Parent = keybindFrame
             keybindLabel.BackgroundTransparency = 1.0
             keybindLabel.Size = UDim2.new(1, -78, 1, 0) -- Fill width minus button space and padding
             keybindLabel.Font = Enum.Font.Code
             keybindLabel.Text = text
             keybindLabel.TextColor3 = Color3.fromRGB(190, 190, 190)
             keybindLabel.TextSize = 14.000
             keybindLabel.TextXAlignment = Enum.TextXAlignment.Left
             keybindLabel.RichText = true

             -- Keybind Button (Shows current key, allows changing)
             local currentKey = defaultKey
             local listening = false
             local keybindActive = true -- Allows disabling the keybind trigger

             local keybindButton = Instance.new("TextButton")
             keybindButton.Name = "keybindButtonDisplay"
             keybindButton.Parent = keybindFrame
             keybindButton.Size = UDim2.new(0, 70, 0, 20) -- Initial size, will resize
             keybindButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
             keybindButton.BorderSizePixel = 0
             keybindButton.AutoButtonColor = false
             keybindButton.Font = Enum.Font.Code
             keybindButton.Text = currentKey.Name
             keybindButton.TextColor3 = Color3.fromRGB(160, 160, 160)
             keybindButton.TextSize = 12

             local kbCorner = Instance.new("UICorner", keybindButton)
             kbCorner.CornerRadius = UDim.new(0, 3)

             -- Resize function (same as toggle's keybind)
             local function ResizeKeybindButton()
                  local keyTextSize = TextService:GetTextSize(keybindButton.Text, keybindButton.TextSize, keybindButton.Font, Vector2.new(math.huge, keybindButton.AbsoluteSize.Y))
                  local newWidth = math.max(40, keyTextSize.X + 10)
                  keybindButton.Size = UDim2.new(0, newWidth, 0, 20)
                  -- Adjust label size based on button width
                  keybindLabel.Size = UDim2.new(1, -(newWidth + keybindLayout.Padding.Offset), 1, 0)
             end
             ResizeKeybindButton()

             -- Click to change key (same logic as toggle's keybind)
             keybindButton.MouseButton1Click:Connect(function()
                  if listening then return end
                  listening = true
                  keybindButton.Text = "..."
                  keybindButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                  ResizeKeybindButton()

                  local connection
                  connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                      if not gameProcessed and input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.MouseButton2 and input.KeyCode ~= Enum.KeyCode.Unknown then
                           currentKey = input.KeyCode
                           keybindButton.Text = currentKey.Name
                           listening = false
                           keybindButton.TextColor3 = Color3.fromRGB(160, 160, 160)
                           ResizeKeybindButton()
                           if connection then connection:Disconnect() end
                      elseif input.KeyCode == Enum.KeyCode.Escape then
                           keybindButton.Text = currentKey.Name
                           listening = false
                           keybindButton.TextColor3 = Color3.fromRGB(160, 160, 160)
                           ResizeKeybindButton()
                           if connection then connection:Disconnect() end
                      end
                  end)
             end)

             -- Keybind Activation Logic
             UserInputService.InputBegan:Connect(function(input, gameProcessed)
                  if keybindActive and not gameProcessed and not listening and input.KeyCode == currentKey then
                       local focused = UserInputService:GetFocusedTextBox()
                       if not focused then
                           local success, err = pcall(callback, currentKey) -- Pass the key pressed to the callback
                            if not success then
                                 warn("SC Lib Keybind Error:", err)
                                 if library.Notify then library.Notify("Keybind Callback Error: " .. tostring(err), 5, "error") end
                            end
                       end
                  end
             end)

             task.wait()
             DebouncedUpdatePageSize()

             -- Keybind Functions API
             local KeybindFunctions = {}
             function KeybindFunctions:Text(newText) keybindLabel.Text = newText or text; ResizeKeybindButton(); return KeybindFunctions end
             function KeybindFunctions:Hide() keybindFrame.Visible = false; DebouncedUpdatePageSize(); return KeybindFunctions end
             function KeybindFunctions:Show() keybindFrame.Visible = true; DebouncedUpdatePageSize(); return KeybindFunctions end
             function KeybindFunctions:Remove() keybindFrame:Destroy(); DebouncedUpdatePageSize(); return nil end
             function KeybindFunctions:SetKey(newKeyEnum)
                 if newKeyEnum and typeof(newKeyEnum) == "EnumItem" and newKeyEnum.EnumType == Enum.KeyCode then
                      currentKey = newKeyEnum
                      keybindButton.Text = currentKey.Name
                      ResizeKeybindButton()
                 else warn("SC Lib SetKey: Invalid KeyCode Enum provided.") end
                 return KeybindFunctions
             end
             function KeybindFunctions:GetKey() return currentKey end
             function KeybindFunctions:SetFunction(newCallback) callback = newCallback or function() end; return KeybindFunctions end
             function KeybindFunctions:Disable() keybindActive = false; keybindButton.TextColor3 = Color3.fromRGB(100,100,100); return KeybindFunctions end
             function KeybindFunctions:Enable() keybindActive = true; keybindButton.TextColor3 = Color3.fromRGB(160,160,160); return KeybindFunctions end
             function KeybindFunctions:Fire() pcall(callback, currentKey) return KeybindFunctions end -- Add Fire method

             return KeybindFunctions
        end

        -- / Component: Textbox (Multiple Sizes)
        function Components:NewTextbox(text, options)
            text = text or "Textbox Input"
            options = options or {}
            local default = options.default or ""
            local placeholder = options.placeholder or "Enter text..."
            local format = tostring(options.format or "all"):lower() -- all, numbers, lower, upper, none
            local sizeType = tostring(options.size or "small"):lower() -- small, medium, large
            local multiLine = sizeType == "large" -- large implies multi-line
            local autoExecute = options.autoExecute -- Execute callback on FocusLost (true by default if not specified?) -> Let's make it true default
             if autoExecute == nil then autoExecute = true end
            local clearOnFocus = options.clearOnFocus or false
            local callback = options.callback or function(value) print(text .. " value: " .. value) end

            local textboxFrame = Instance.new("Frame")
            textboxFrame.Name = "textboxFrame_" .. text:sub(1,10)
            textboxFrame.Parent = page
            textboxFrame.BackgroundTransparency = 1.0

            local frameLayout = Instance.new("UIListLayout")
            frameLayout.Parent = textboxFrame
            frameLayout.SortOrder = Enum.SortOrder.LayoutOrder
            frameLayout.Padding = UDim.new(0, 4) -- Space between label and input box

            -- Label (Optional, based on sizeType?) - Let's always include it for consistency
            local textboxLabel = Instance.new("TextLabel")
            textboxLabel.Name = "textboxLabel"
            textboxLabel.Parent = textboxFrame
            textboxLabel.BackgroundTransparency = 1.0
            textboxLabel.Size = UDim2.new(1, 0, 0, 18) -- Label height
            textboxLabel.Font = Enum.Font.Code
            textboxLabel.Text = text
            textboxLabel.TextColor3 = Color3.fromRGB(190, 190, 190)
            textboxLabel.TextSize = 14.000
            textboxLabel.TextXAlignment = Enum.TextXAlignment.Left
            textboxLabel.RichText = true

            -- Input Box Container (for border effect)
            local inputContainer = Instance.new("Frame")
            inputContainer.Name = "inputContainer"
            inputContainer.Parent = textboxFrame
            inputContainer.BackgroundColor3 = Color3.fromRGB(60, 60, 60) -- Border color
            inputContainer.BorderSizePixel = 0

            local containerCorner = Instance.new("UICorner", inputContainer)
            containerCorner.CornerRadius = UDim.new(0, 3)

            -- Actual TextBox Element
            local textBox = Instance.new("TextBox")
            textBox.Name = "textBoxInput"
            textBox.Parent = inputContainer
            textBox.AnchorPoint = Vector2.new(0.5, 0.5)
            textBox.Position = UDim2.new(0.5, 0, 0.5, 0)
            textBox.Size = UDim2.new(1, -2, 1, -2) -- Fill container minus border
            textBox.Font = Enum.Font.Code
            textBox.Text = default
            textBox.PlaceholderText = placeholder
            textBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
            textBox.TextColor3 = Color3.fromRGB(210, 210, 210)
            textBox.TextSize = 14.000
            textBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Input background color
            textBox.BorderSizePixel = 0
            textBox.ClearTextOnFocus = clearOnFocus
            textBox.MultiLine = multiLine
            textBox.TextWrapped = multiLine -- Only wrap if multiline
            textBox.TextXAlignment = Enum.TextXAlignment.Left
            textBox.TextYAlignment = multiLine and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center

            local textCorner = Instance.new("UICorner", textBox)
            textCorner.CornerRadius = UDim.new(0, 2) -- Inner rounding

            -- Set Heights based on sizeType
            local inputHeight = 28 -- Default small
            if sizeType == "medium" then
                inputHeight = 34
            elseif sizeType == "large" then
                inputHeight = 90 -- Larger for multiline
            end
            inputContainer.Size = UDim2.new(1, 0, 0, inputHeight)
            textboxFrame.Size = UDim2.new(1, 0, 0, inputHeight + 18 + frameLayout.Padding.Offset) -- Total height

            -- Input Formatting and Callback Logic
            local function HandleInput()
                local currentText = textBox.Text
                local originalText = currentText -- Store original for comparison

                if format == "numbers" then
                     currentText = currentText:gsub("[^%d%.%-]", "") -- Allow digits, period, hyphen
                     -- Optional: More complex number validation if needed
                elseif format == "lower" then
                     currentText = currentText:lower()
                elseif format == "upper" then
                     currentText = currentText:upper()
                -- else 'all' or 'none' requires no change
                end

                 if currentText ~= originalText then
                     textBox.Text = currentText -- Update text only if formatting changed it
                     -- Moving cursor might be tricky here, often better to just let it reset
                 end
            end

            textBox:GetPropertyChangedSignal("Text"):Connect(HandleInput)

            -- Focus Lost Logic (Callback Execution)
            textBox.FocusLost:Connect(function(enterPressed)
                 HandleInput() -- Ensure formatting is applied before callback
                 if autoExecute then
                      local success, err = pcall(callback, textBox.Text)
                       if not success then
                            warn("SC Lib Textbox Error:", err)
                            if library.Notify then library.Notify("Textbox Callback Error: " .. tostring(err), 5, "error") end
                       end
                 elseif enterPressed then -- Execute only if Enter was pressed and autoExecute is off
                      local success, err = pcall(callback, textBox.Text)
                       if not success then
                            warn("SC Lib Textbox Error:", err)
                            if library.Notify then library.Notify("Textbox Callback Error: " .. tostring(err), 5, "error") end
                       end
                 end

                 -- Visual cue for focus lost
                 TweenService:Create(inputContainer, TweenTable["Fast"], {BackgroundColor3 = Color3.fromRGB(60, 60, 60)}):Play()
            end)

            -- Focus Gained Visual Cue
            textBox.Focused:Connect(function()
                 TweenService:Create(inputContainer, TweenTable["Fast"], {BackgroundColor3 = Color3.fromRGB(159, 115, 255)}):Play() -- Highlight border on focus
            end)

            task.wait()
            DebouncedUpdatePageSize()

            -- Textbox Functions API
            local TextboxFunctions = {}
            function TextboxFunctions:Input(newValue) -- Renamed from :Value to :Input
                 textBox.Text = newValue or ""
                 HandleInput() -- Apply formatting
                 return TextboxFunctions
            end
            function TextboxFunctions:Fire() -- Manually trigger callback
                 HandleInput()
                 pcall(callback, textBox.Text)
                 return TextboxFunctions
            end
            function TextboxFunctions:SetFunction(newCallback) callback = newCallback or function() end; return TextboxFunctions end
            function TextboxFunctions:Text(newLabelText) textboxLabel.Text = newLabelText or text; return TextboxFunctions end
            function TextboxFunctions:Hide() textboxFrame.Visible = false; DebouncedUpdatePageSize(); return TextboxFunctions end
            function TextboxFunctions:Show() textboxFrame.Visible = true; DebouncedUpdatePageSize(); return TextboxFunctions end
            function TextboxFunctions:Remove() textboxFrame:Destroy(); DebouncedUpdatePageSize(); return nil end
            function TextboxFunctions:Place(newPlaceholder) textBox.PlaceholderText = newPlaceholder or ""; return TextboxFunctions end
            function TextboxFunctions:Clear() textBox.Text = ""; return TextboxFunctions end
             function TextboxFunctions:GetValue() return textBox.Text end -- Add GetValue method

            return TextboxFunctions
        end


        -- / Component: Dropdown/Selector (Improved Style & Functionality)
        function Components:NewSelector(text, list, default, callback)
            text = text or "Select Option"
            list = list or {"Option 1", "Option 2", "Option 3"}
            default = default or list[1] -- Default to first item if not specified
            callback = callback or function(selected) print(text .. " selected: " .. selected) end

            local isOpen = false
            local currentSelection = default

            local selectorFrame = Instance.new("Frame") -- Main container row
            selectorFrame.Name = "selectorFrame_" .. text:sub(1,10)
            selectorFrame.Parent = page
            selectorFrame.BackgroundTransparency = 1.0
            selectorFrame.Size = UDim2.new(1, 0, 0, 52) -- Label + Dropdown height + padding
            selectorFrame.ClipsDescendants = false -- Allow dropdown list to overflow
            selectorFrame.ZIndex = 1 -- Base ZIndex

            local frameLayout = Instance.new("UIListLayout")
            frameLayout.Parent = selectorFrame
            frameLayout.SortOrder = Enum.SortOrder.LayoutOrder
            frameLayout.Padding = UDim.new(0, 4)

            -- Selector Label
            local selectorLabel = Instance.new("TextLabel")
            selectorLabel.Name = "selectorLabel"
            selectorLabel.Parent = selectorFrame
            selectorLabel.BackgroundTransparency = 1.0
            selectorLabel.Size = UDim2.new(1, 0, 0, 18) -- Label height
            selectorLabel.Font = Enum.Font.Code
            selectorLabel.Text = text
            selectorLabel.TextColor3 = Color3.fromRGB(190, 190, 190)
            selectorLabel.TextSize = 14.000
            selectorLabel.TextXAlignment = Enum.TextXAlignment.Left
            selectorLabel.RichText = true

            -- Dropdown Display Button (shows current selection)
            local displayButton = Instance.new("TextButton")
            displayButton.Name = "displayButton"
            displayButton.Parent = selectorFrame
            displayButton.Size = UDim2.new(1, 0, 0, 28) -- Height of the closed dropdown
            displayButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55) -- Closed dropdown bg
            displayButton.BorderSizePixel = 1
            displayButton.BorderColor3 = Color3.fromRGB(70, 70, 70)
            displayButton.AutoButtonColor = false
            displayButton.Font = Enum.Font.Code
            displayButton.Text = tostring(currentSelection) -- Show default initially
            displayButton.TextColor3 = Color3.fromRGB(200, 200, 200)
            displayButton.TextSize = 14.000
            displayButton.TextXAlignment = Enum.TextXAlignment.Left
            displayButton.ZIndex = 2 -- Above base frame

            local displayCorner = Instance.new("UICorner", displayButton)
            displayCorner.CornerRadius = UDim.new(0, 3)
            local displayPadding = Instance.new("UIPadding", displayButton)
            displayPadding.PaddingLeft = UDim.new(0, 8)
            displayPadding.PaddingRight = UDim.new(0, 25) -- Space for the dropdown arrow

            -- Dropdown Arrow Indicator
            local arrow = Instance.new("ImageLabel")
            arrow.Name = "Arrow"
            arrow.Parent = displayButton
            arrow.AnchorPoint = Vector2.new(1, 0.5)
            arrow.Position = UDim2.new(1, -8, 0.5, 0)
            arrow.Size = UDim2.new(0, 12, 0, 12)
            arrow.Image = "rbxassetid://3926305904" -- Chevron down icon
            arrow.ImageColor3 = Color3.fromRGB(160, 160, 160)
            arrow.BackgroundTransparency = 1.0
            arrow.Rotation = 0 -- Points down when closed
            arrow.ZIndex = 3

            -- Dropdown List Container (ScrollingFrame)
            local listContainer = Instance.new("ScrollingFrame")
            listContainer.Name = "listContainer"
            listContainer.Parent = selectorFrame -- Parent to main frame to allow overflow
            listContainer.Position = UDim2.new(0, 0, 1, 0) -- Position below the display button
            listContainer.Size = UDim2.new(1, 0, 0, 0) -- Start height 0, expands when open
            listContainer.BackgroundColor3 = Color3.fromRGB(55, 55, 55) -- List bg color
            listContainer.BorderSizePixel = 1
            listContainer.BorderColor3 = Color3.fromRGB(70, 70, 70)
            listContainer.ClipsDescendants = true
            listContainer.Visible = false -- Start hidden
            listContainer.CanvasSize = UDim2.new(0,0,0,0)
            listContainer.ScrollBarThickness = 4
            listContainer.ScrollBarImageColor3 = Color3.fromRGB(159, 115, 255)
            listContainer.ZIndex = 10 -- High ZIndex to appear over other elements when open

            local listCorner = Instance.new("UICorner", listContainer)
            listCorner.CornerRadius = UDim.new(0, 3)

            local listLayout = Instance.new("UIListLayout")
            listLayout.Parent = listContainer
            listLayout.SortOrder = Enum.SortOrder.LayoutOrder
            listLayout.Padding = UDim.new(0, 1) -- Small gap between options

            -- Animation Tweens
            CreateTween("dropdown_toggle", 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            CreateTween("arrow_rotate", 0.2)
            CreateTween("option_hover", 0.1)

            -- Populate List Function
            local optionButtons = {} -- Store references to option buttons
            local function PopulateList()
                -- Clear existing options first
                 for _, btn in ipairs(optionButtons) do if btn and btn.Parent then btn:Destroy() end end
                 table.clear(optionButtons)

                 local totalHeight = 0
                 for i, optionText in ipairs(list) do
                     local optionButton = Instance.new("TextButton")
                     optionButton.Name = "option_" .. tostring(optionText):sub(1,10)
                     optionButton.Parent = listContainer
                     optionButton.Size = UDim2.new(1, 0, 0, 24) -- Height of each option
                     optionButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55) -- Default option bg
                     optionButton.AutoButtonColor = false
                     optionButton.Font = Enum.Font.Code
                     optionButton.Text = tostring(optionText)
                     optionButton.TextColor3 = Color3.fromRGB(180, 180, 180) -- Default option text color
                     optionButton.TextSize = 14.000
                     optionButton.TextXAlignment = Enum.TextXAlignment.Left

                     local optPadding = Instance.new("UIPadding", optionButton)
                     optPadding.PaddingLeft = UDim.new(0, 8)

                      -- Highlight the currently selected option
                      if tostring(optionText) == tostring(currentSelection) then
                           optionButton.BackgroundColor3 = Color3.fromRGB(75, 75, 75) -- Highlight selected
                           optionButton.TextColor3 = Color3.fromRGB(220, 220, 220)
                      end

                      table.insert(optionButtons, optionButton)
                      totalHeight = totalHeight + optionButton.AbsoluteSize.Y + listLayout.Padding.Offset

                      -- Option Hover Effect
                      optionButton.MouseEnter:Connect(function()
                           if tostring(optionButton.Text) ~= tostring(currentSelection) then
                                TweenService:Create(optionButton, TweenTable["option_hover"], {BackgroundColor3 = Color3.fromRGB(70, 70, 70)}):Play()
                           end
                      end)
                      optionButton.MouseLeave:Connect(function()
                           if tostring(optionButton.Text) ~= tostring(currentSelection) then
                                TweenService:Create(optionButton, TweenTable["option_hover"], {BackgroundColor3 = Color3.fromRGB(55, 55, 55)}):Play()
                           end
                      end)

                      -- Option Click Logic
                      optionButton.MouseButton1Click:Connect(function()
                           if tostring(currentSelection) == tostring(optionText) then -- Clicked selected item again
                                isOpen = false -- Just close the dropdown
                                listContainer.Visible = false
                                listContainer.Size = UDim2.new(1, 0, 0, 0)
                                TweenService:Create(arrow, TweenTable["arrow_rotate"], {Rotation = 0}):Play()
                                selectorFrame.ZIndex = 1 -- Reset ZIndex
                                return
                           end

                           currentSelection = optionText
                           displayButton.Text = tostring(currentSelection)
                           isOpen = false -- Close dropdown after selection
                           listContainer.Visible = false
                           listContainer.Size = UDim2.new(1, 0, 0, 0)
                           TweenService:Create(arrow, TweenTable["arrow_rotate"], {Rotation = 0}):Play()
                           selectorFrame.ZIndex = 1 -- Reset ZIndex

                           -- Update highlights in the list
                           PopulateList() -- Repopulate to update highlights correctly

                           -- Run Callback
                           local success, err = pcall(callback, currentSelection)
                            if not success then
                                 warn("SC Lib Selector Error:", err)
                                 if library.Notify then library.Notify("Selector Callback Error: " .. tostring(err), 5, "error") end
                            end
                      end)
                 end
                 -- Update CanvasSize based on calculated total height
                 listContainer.CanvasSize = UDim2.new(0, 0, 0, totalHeight - listLayout.Padding.Offset) -- Subtract last padding
             end

             -- Toggle Dropdown Logic
             displayButton.MouseButton1Click:Connect(function()
                 isOpen = not isOpen
                 if isOpen then
                      PopulateList() -- Ensure list is up-to-date before opening
                      local listHeight = math.min(150, listContainer.CanvasSize.Y.Offset + 4) -- Max height 150px, + border
                      listContainer.Visible = true
                      selectorFrame.ZIndex = 10 -- Bring whole control to front
                      TweenService:Create(listContainer, TweenTable["dropdown_toggle"], {Size = UDim2.new(1, 0, 0, listHeight)}):Play()
                      TweenService:Create(arrow, TweenTable["arrow_rotate"], {Rotation = 180}):Play() -- Point arrow up
                 else
                      TweenService:Create(listContainer, TweenTable["dropdown_toggle"], {Size = UDim2.new(1, 0, 0, 0)}):Play()
                      TweenService:Create(arrow, TweenTable["arrow_rotate"], {Rotation = 0}):Play() -- Point arrow down
                      task.delay(0.2, function() -- Hide after animation finishes
                           if not isOpen then -- Check again in case it was reopened quickly
                                listContainer.Visible = false
                                selectorFrame.ZIndex = 1 -- Reset ZIndex
                           end
                      end)
                 end
             end)

            -- Close dropdown if clicking outside (basic implementation)
            local function CloseIfClickedOutside(input)
                 if not isOpen then return end
                 local guiObject = input.UserInputType == Enum.UserInputType.MouseButton1 and input.Position or nil
                 if guiObject then
                      local objects = Players.LocalPlayer:GetGuiObjectsAtPosition(guiObject.X, guiObject.Y)
                      local clickedInside = false
                      for _, obj in ipairs(objects) do
                           if obj:IsDescendantOf(selectorFrame) then
                                clickedInside = true
                                break
                           end
                      end
                      if not clickedInside then
                           isOpen = false
                           TweenService:Create(listContainer, TweenTable["dropdown_toggle"], {Size = UDim2.new(1, 0, 0, 0)}):Play()
                           TweenService:Create(arrow, TweenTable["arrow_rotate"], {Rotation = 0}):Play()
                           task.delay(0.2, function() listContainer.Visible = false; selectorFrame.ZIndex = 1 end)
                      end
                 end
            end
            UserInputService.InputBegan:Connect(CloseIfClickedOutside)


             task.wait()
             DebouncedUpdatePageSize()

             -- Selector Functions API
             local SelectorFunctions = {}
             function SelectorFunctions:AddOption(option)
                 if not table.find(list, option) then
                     table.insert(list, option)
                     if isOpen then PopulateList() end -- Update list if open
                 end
                 return SelectorFunctions
             end
             function SelectorFunctions:RemoveOption(option)
                 local index = table.find(list, tostring(option))
                 if index then
                     table.remove(list, index)
                     if tostring(currentSelection) == tostring(option) then
                          -- If removed option was selected, select the first available or none
                          currentSelection = list[1] or "..." -- Select first or placeholder
                          displayButton.Text = tostring(currentSelection)
                          pcall(callback, currentSelection) -- Run callback for the new selection
                     end
                     if isOpen then PopulateList() end -- Update list if open
                 end
                 return SelectorFunctions
             end
             function SelectorFunctions:ClearOptions()
                 list = {}
                 currentSelection = "..."
                 displayButton.Text = currentSelection
                 if isOpen then PopulateList() end
                 pcall(callback, nil) -- Indicate nothing is selected
                 return SelectorFunctions
             end
             function SelectorFunctions:SetOptions(newList)
                  if type(newList) == "table" then
                      list = newList
                      -- Check if current selection is still valid
                      if not table.find(list, currentSelection) then
                           currentSelection = list[1] or "..."
                           displayButton.Text = tostring(currentSelection)
                           pcall(callback, currentSelection)
                      end
                      if isOpen then PopulateList() end
                  else
                      warn("SC Lib SetOptions: Input must be a table.")
                  end
                  return SelectorFunctions
             end
             function SelectorFunctions:Select(optionToSelect)
                  local found = false
                  for _, opt in ipairs(list) do
                       if tostring(opt) == tostring(optionToSelect) then
                            currentSelection = opt
                            displayButton.Text = tostring(currentSelection)
                            if isOpen then PopulateList() end -- Update highlight if open
                            pcall(callback, currentSelection) -- Run callback
                            found = true
                            break
                       end
                  end
                  if not found then warn("SC Lib Select: Option not found in list - ", tostring(optionToSelect)) end
                  return SelectorFunctions
             end
             function SelectorFunctions:GetSelected() return currentSelection end
             function SelectorFunctions:GetOptions() return list end
             function SelectorFunctions:SetFunction(newCallback) callback = newCallback or function() end; return SelectorFunctions end
             function SelectorFunctions:Text(newLabelText) selectorLabel.Text = newLabelText or text; return SelectorFunctions end
             function SelectorFunctions:Hide() selectorFrame.Visible = false; DebouncedUpdatePageSize(); return SelectorFunctions end
             function SelectorFunctions:Show() selectorFrame.Visible = true; DebouncedUpdatePageSize(); return SelectorFunctions end
             function SelectorFunctions:Remove() selectorFrame:Destroy(); DebouncedUpdatePageSize(); return nil end

             return SelectorFunctions
        end


        -- / Component: Slider (Improved Visuals)
        function Components:NewSlider(text, options)
            text = text or "Slider Control"
            options = options or {}
            local minVal = options.min or 0
            local maxVal = options.max or 100
            local defaultVal = options.default or minVal
            local increment = options.increment or 1 -- Step value
            local suffix = options.suffix or ""
            local showValue = options.showValue -- Show current value next to label (true by default)
             if showValue == nil then showValue = true end
            local callback = options.callback or function(value) print(text .. " set to " .. value) end

            local currentValue = defaultVal
            local isDragging = false

            local sliderFrame = Instance.new("Frame") -- Main container row
            sliderFrame.Name = "sliderFrame_" .. text:sub(1,10)
            sliderFrame.Parent = page
            sliderFrame.BackgroundTransparency = 1.0
            sliderFrame.Size = UDim2.new(1, 0, 0, 42) -- Label + Slider height + padding

            local frameLayout = Instance.new("UIListLayout")
            frameLayout.Parent = sliderFrame
            frameLayout.SortOrder = Enum.SortOrder.LayoutOrder
            frameLayout.Padding = UDim.new(0, 4)

            -- Top Row (Label + Value Display)
            local topRowFrame = Instance.new("Frame")
            topRowFrame.Name = "TopRow"
            topRowFrame.Parent = sliderFrame
            topRowFrame.BackgroundTransparency = 1.0
            topRowFrame.Size = UDim2.new(1, 0, 0, 18)

            local topRowLayout = Instance.new("UIListLayout")
            topRowLayout.Parent = topRowFrame
            topRowLayout.FillDirection = Enum.FillDirection.Horizontal
            topRowLayout.VerticalAlignment = Enum.VerticalAlignment.Center

            -- Slider Label
            local sliderLabel = Instance.new("TextLabel")
            sliderLabel.Name = "sliderLabel"
            sliderLabel.Parent = topRowFrame
            sliderLabel.BackgroundTransparency = 1.0
            sliderLabel.Size = UDim2.new(0, 100, 1, 0) -- Dynamic width later
            sliderLabel.Font = Enum.Font.Code
            sliderLabel.Text = text
            sliderLabel.TextColor3 = Color3.fromRGB(190, 190, 190)
            sliderLabel.TextSize = 14.000
            sliderLabel.TextXAlignment = Enum.TextXAlignment.Left
            sliderLabel.RichText = true

            -- Slider Value Display
            local valueLabel = Instance.new("TextLabel")
            valueLabel.Name = "valueLabel"
            valueLabel.Parent = topRowFrame
            valueLabel.BackgroundTransparency = 1.0
            valueLabel.Size = UDim2.new(1, -100, 1, 0) -- Fill remaining space
            valueLabel.Font = Enum.Font.Code
            valueLabel.Text = tostring(currentValue) .. suffix
            valueLabel.TextColor3 = Color3.fromRGB(160, 160, 160) -- Dimmer value text
            valueLabel.TextSize = 14.000
            valueLabel.TextXAlignment = Enum.TextXAlignment.Right
            valueLabel.Visible = showValue -- Hide if option is false

            -- Calculate initial label sizes
            local labelWidth = TextService:GetTextSize(sliderLabel.Text, sliderLabel.TextSize, sliderLabel.Font, Vector2.new(math.huge, 18)).X
            local valueWidth = TextService:GetTextSize(valueLabel.Text, valueLabel.TextSize, valueLabel.Font, Vector2.new(math.huge, 18)).X
            sliderLabel.Size = UDim2.new(0, labelWidth, 1, 0)
            valueLabel.Size = UDim2.new(1, -(labelWidth + 10), 1, 0) -- Fill space minus label and padding


            -- Slider Track Area (Button for click/drag detection)
            local trackButton = Instance.new("TextButton")
            trackButton.Name = "TrackButton"
            trackButton.Parent = sliderFrame
            trackButton.Size = UDim2.new(1, 0, 0, 18) -- Height of the track area
            trackButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60) -- Track background border
            trackButton.BorderSizePixel = 0
            trackButton.AutoButtonColor = false
            trackButton.Text = ""

            local trackCorner = Instance.new("UICorner", trackButton)
            trackCorner.CornerRadius = UDim.new(1, 0) -- Fully rounded track ends

            -- Inner Track Background
            local trackInnerBg = Instance.new("Frame")
            trackInnerBg.Name = "TrackInnerBg"
            trackInnerBg.Parent = trackButton
            trackInnerBg.AnchorPoint = Vector2.new(0.5, 0.5)
            trackInnerBg.Position = UDim2.new(0.5, 0, 0.5, 0)
            trackInnerBg.Size = UDim2.new(1, -2, 1, -6) -- Slightly inset track
            trackInnerBg.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark inner track
            trackInnerBg.BorderSizePixel = 0

            local innerCorner = Instance.new("UICorner", trackInnerBg)
            innerCorner.CornerRadius = UDim.new(1, 0)

            -- Filled Part of the Track
            local fillTrack = Instance.new("Frame")
            fillTrack.Name = "FillTrack"
            fillTrack.Parent = trackInnerBg -- Inside the inner track
            fillTrack.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple fill
            fillTrack.BorderSizePixel = 0
            fillTrack.Size = UDim2.new(0, 0, 1, 0) -- Width calculated based on value
            fillTrack.ZIndex = 2

            local fillCorner = Instance.new("UICorner", fillTrack)
            fillCorner.CornerRadius = UDim.new(1, 0) -- Match rounding

            -- Slider Thumb (Circle/Handle) - Optional visual element
             local thumb = Instance.new("Frame")
             thumb.Name = "Thumb"
             thumb.Parent = trackButton -- On top of the main track button
             thumb.AnchorPoint = Vector2.new(0.5, 0.5)
             thumb.Position = UDim2.new(0, 0, 0.5, 0) -- Position calculated based on value
             thumb.Size = UDim2.new(0, 12, 0, 12) -- Thumb size
             thumb.BackgroundColor3 = Color3.fromRGB(200, 200, 200) -- Thumb color
             thumb.BorderSizePixel = 1
             thumb.BorderColor3 = Color3.fromRGB(120,120,120)
             thumb.ZIndex = 3

             local thumbCorner = Instance.new("UICorner", thumb)
             thumbCorner.CornerRadius = UDim.new(1, 0) -- Make it a circle


            -- Update Function (Sets value, updates visuals, runs callback)
             CreateTween("slider_fill", 0.05, Enum.EasingStyle.Linear) -- Fast fill update
             local function UpdateSliderValue(newValue, runCallback)
                 -- Clamp and snap value to increment
                 local snappedValue = math.clamp(math.floor((newValue - minVal) / increment + 0.5) * increment + minVal, minVal, maxVal)

                 if snappedValue == currentValue then return end -- No change needed

                 currentValue = snappedValue

                 -- Calculate fill percentage
                 local percentage = (currentValue - minVal) / (maxVal - minVal)
                 if (maxVal - minVal) == 0 then percentage = 0 end -- Avoid division by zero

                 -- Update Visuals
                 local targetFill = UDim2.new(percentage, 0, 1, 0)
                 TweenService:Create(fillTrack, TweenTable["slider_fill"], {Size = targetFill}):Play()

                 -- Update Thumb Position
                 local thumbPosition = UDim2.new(percentage, 0, 0.5, 0)
                 TweenService:Create(thumb, TweenTable["slider_fill"], {Position = thumbPosition}):Play()


                 -- Update Value Label
                 if showValue then
                     valueLabel.Text = tostring(currentValue) .. suffix
                      -- Recalculate label sizes if value text length changes significantly (optional optimization)
                      -- local newValueWidth = TextService:GetTextSize(valueLabel.Text, valueLabel.TextSize, valueLabel.Font, Vector2.new(math.huge, 18)).X
                      -- valueLabel.Size = UDim2.new(1, -(labelWidth + 10), 1, 0) -- Needs adjustment based on new width
                 end

                 -- Run Callback
                 if runCallback then
                     local success, err = pcall(callback, currentValue)
                      if not success then
                           warn("SC Lib Slider Error:", err)
                           if library.Notify then library.Notify("Slider Callback Error: " .. tostring(err), 5, "error") end
                      end
                 end
             end

             -- Set Initial Value
             UpdateSliderValue(defaultVal, false) -- Set default without running callback initially

             -- Drag Logic
             local function HandleDrag(input)
                  local trackStartX = trackButton.AbsolutePosition.X
                  local trackWidth = trackButton.AbsoluteSize.X
                  local mouseX = input.Position.X
                  local relativeX = math.clamp(mouseX - trackStartX, 0, trackWidth)
                  local percentage = relativeX / trackWidth
                  local newValue = minVal + percentage * (maxVal - minVal)
                  UpdateSliderValue(newValue, true) -- Update value and run callback during drag
             end

             trackButton.InputBegan:Connect(function(input)
                  if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                       isDragging = true
                       HandleDrag(input) -- Update immediately on click
                       thumb.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- Highlight thumb on drag
                       thumb.Size = UDim2.new(0, 14, 0, 14) -- Make thumb slightly larger on drag
                  end
             end)

             trackButton.InputChanged:Connect(function(input)
                  if isDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                       HandleDrag(input)
                  end
             end)

             trackButton.InputEnded:Connect(function(input)
                 if isDragging and (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
                     isDragging = false
                     thumb.BackgroundColor3 = Color3.fromRGB(200, 200, 200) -- Return thumb to normal
                     thumb.Size = UDim2.new(0, 12, 0, 12)
                     -- Final callback run might be redundant if handled in InputChanged, but ensures final state
                     -- pcall(callback, currentValue)
                 end
             end)


             task.wait()
             DebouncedUpdatePageSize()

             -- Slider Functions API
             local SliderFunctions = {}
             function SliderFunctions:Value(newValue) -- Renamed from :Set to :Value for clarity
                  UpdateSliderValue(newValue, true) -- Set value and run callback
                  return SliderFunctions
             end
             function SliderFunctions:SilentValue(newValue) -- Set value without running callback
                  UpdateSliderValue(newValue, false)
                  return SliderFunctions
             end
             function SliderFunctions:GetValue() return currentValue end
             function SliderFunctions:SetFunction(newCallback) callback = newCallback or function() end; return SliderFunctions end
             function SliderFunctions:Text(newLabelText)
                  sliderLabel.Text = newLabelText or text
                  -- Recalculate sizes
                  labelWidth = TextService:GetTextSize(sliderLabel.Text, sliderLabel.TextSize, sliderLabel.Font, Vector2.new(math.huge, 18)).X
                  sliderLabel.Size = UDim2.new(0, labelWidth, 1, 0)
                  valueLabel.Size = UDim2.new(1, -(labelWidth + 10), 1, 0)
                  return SliderFunctions
             end
             function SliderFunctions:Hide() sliderFrame.Visible = false; DebouncedUpdatePageSize(); return SliderFunctions end
             function SliderFunctions:Show() sliderFrame.Visible = true; DebouncedUpdatePageSize(); return SliderFunctions end
             function SliderFunctions:Remove() sliderFrame:Destroy(); DebouncedUpdatePageSize(); return nil end

             return SliderFunctions
         end


        -- Tab Control Functions (Belong to the specific tab instance)
        function Components:Open()
             tabButton:MouseButton1Click() -- Simulate clicking the tab button
             return Components
        end
        function Components:Remove()
             local wasActive = (TabLibrary.CurrentTab == tabButton)
             tabButton:Destroy()
             page:Destroy()
             if wasActive then
                  -- Find the next available tab and activate it
                  local nextTabButton = tabButtons:FindFirstChildWhichIsA("TextButton")
                  if nextTabButton then
                       TabLibrary.CurrentTab = nil -- Clear current so click works
                       TabLibrary.CurrentPage = nil
                       nextTabButton:MouseButton1Click()
                  else -- No tabs left
                       TabLibrary.CurrentTab = nil
                       TabLibrary.CurrentPage = nil
                       TabLibrary.IsFirst = true -- Reset for next potential tab
                  end
             end
             return nil -- Indicate removal
        end
        function Components:Hide()
            tabButton.Visible = false
            if TabLibrary.CurrentTab == tabButton then
                 page.Visible = false
                 -- Potentially find and show another tab? Or just leave container blank?
                 -- For simplicity, just hide the page too. User must manually show another tab.
            end
            return Components
        end
        function Components:Show()
            tabButton.Visible = true
            -- If this tab is supposed to be the active one, ensure its page is visible
            if TabLibrary.CurrentTab == tabButton then
                 page.Visible = true
            end
            return Components
        end
        function Components:Text(newTitle)
             tabButton.Text = newTitle or title
             page.Name = newTitle .. "_Page"
             return Components
        end

        return Components -- Return the API for this tab
    end -- End of NewTab

    -- Main Library Window Control Functions
    function TabLibrary:Remove()
        -- Save time before destroying
        library:SaveUsageTime()
        library.trackingEnabled = false -- Stop tracking
        screen:Destroy()
        library.UI_Initialized = false -- Mark as uninitialized
        return nil -- Indicate removal
    end
    function TabLibrary:Text(newTitle)
        library.title = newTitle or "SC UI"
        headerLabel.Text = library.title
        return TabLibrary
    end
    function TabLibrary:UpdateKeybind(newKey)
        if newKey and typeof(newKey) == "EnumItem" and newKey.EnumType == Enum.KeyCode then
             toggleKey = newKey
        else
             warn("SC Lib UpdateKeybind: Invalid KeyCode Enum provided.")
        end
        return TabLibrary
    end

    library.UI_Initialized = true -- Mark as initialized *after* setup
    screen.Enabled = true -- Ensure the screen is enabled initially

    return TabLibrary -- Return the main Tab management API
end -- End of library:Init


-- / Entry Point: Start with the key request
if library.KeyAccepted then
     -- If script re-runs and key is already accepted (e.g., via _G flag if implemented), skip prompt
     library:ShowGreeting()
else
     library:RequestKey()
end


return library -- Return the main library object

--- END OF REVISED FILE SC Lib Source.txt ---
