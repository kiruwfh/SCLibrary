-- SC UI Lib by sc.owner (reuploaded)
-- init
local player = game.Players.LocalPlayer
-- local mouse = player:GetMouse() -- Deprecated, use UserInputService if needed for specific mouse data

-- services
local input = game:GetService("UserInputService")
local run = game:GetService("RunService")
local tween = game:GetService("TweenService")
local TextService = game:GetService("TextService") -- Added for text size calculations
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting") -- Added for blur effect
local tweeninfo = TweenInfo.new

-- additional
local utility = {}

-- themes
local objects = {} -- Stores weak references to themed objects
local themes = {
	Background = Color3.fromRGB(24, 24, 24),
	Glow = Color3.fromRGB(0, 0, 0),
	Accent = Color3.fromRGB(10, 10, 10),
	LightContrast = Color3.fromRGB(20, 20, 20),
	DarkContrast = Color3.fromRGB(14, 14, 14),
	TextColor = Color3.fromRGB(255, 255, 255),
	-- Notification Colors
	NotifInfo = Color3.fromRGB(100, 150, 255),
	NotifSuccess = Color3.fromRGB(100, 255, 150),
	NotifWarning = Color3.fromRGB(255, 255, 100),
	NotifError = Color3.fromRGB(255, 100, 100)
}

do
	-- Utility Functions with improvements and robustness checks --

	function utility:Create(instance, properties, children)
		local object = Instance.new(instance)
		local success, err = pcall(function() -- Wrap in pcall for safety
			for i, v in pairs(properties or {}) do
				object[i] = v

				if typeof(v) == "Color3" then -- save for theme changer later
					local themeName = utility:Find(themes, v) -- Renamed 'theme' to 'themeName'

					if themeName then
						objects[themeName] = objects[themeName] or {}
						-- Use setmetatable correctly for weak values (objects)
						objects[themeName][i] = objects[themeName][i] or setmetatable({}, {__mode = "v"})

                        -- Store the object itself as the key in the weak table
                        objects[themeName][i][object] = true -- Use object as key
					end
				end
			end

			for _, module in ipairs(children or {}) do -- Use ipairs for arrays
				if module then -- Check if child is valid
					module.Parent = object
				end
			end
		end)
        if not success then
            warn("[SCUI Error] Creating "..instance..":", err)
            warn("Properties:", properties)
        end
		return object
	end

	function utility:Tween(instance, properties, duration, ...)
		if not instance or not instance.Parent then return nil end -- Check instance validity
		local success, tweenInstance = pcall(tween.Create, tween, instance, tweeninfo(duration, ...), properties)
		if success and tweenInstance then
			tweenInstance:Play()
            return tweenInstance -- Return the tween
		else
			warn("[SCUI Tween Error] Instance:", instance:GetFullName(), "Properties:", properties, "Error:", tweenInstance)
            return nil
		end
	end

	function utility:Wait()
		return run.RenderStepped:Wait() -- Use RenderStepped for smoother waits tied to frame rendering
	end

	function utility:Find(tbl, value) -- Renamed 'table' to 'tbl'
		for i, v in pairs(tbl) do
			if v == value then
				return i
			end
		end
		return nil -- Return nil explicitly if not found
	end

	function utility:Sort(pattern, values)
		local new = {}
		pattern = pattern:lower()

		if pattern == "" then
			return values
		end

		for _, value in ipairs(values) do -- Use ipairs for array iteration
			-- Use plain find (non-pattern) for simple substring check
			if tostring(value):lower():find(pattern, 1, true) then
				table.insert(new, value)
			end
		end

		return new
	end

	function utility:Pop(object, shrink)
        if not object or not object.Parent then return nil end -- Add check

		local clone = object:Clone()
		clone.AnchorPoint = Vector2.new(0.5, 0.5)

        -- Ensure shrink doesn't make size negative
        local currentSize = object.AbsoluteSize
        local newShrink = math.min(shrink, currentSize.X / 2, currentSize.Y / 2)
		clone.Size = UDim2.fromOffset(currentSize.X - newShrink, currentSize.Y - newShrink) -- Use fromOffset for pixel size
		clone.Position = UDim2.new(0.5, 0, 0.5, 0)

		clone.Parent = object
		clone:ClearAllChildren()

        local originalTransparency = object.ImageTransparency -- Store original transparency
		object.ImageTransparency = 1
		utility:Tween(clone, {Size = object.Size}, 0.2) -- Animate clone size back to original

		task.spawn(function() -- Use task.spawn
			task.wait(0.2) -- Use task.wait
            if object and object.Parent then -- Check again before restoring
			    object.ImageTransparency = originalTransparency
            end
            if clone and clone.Parent then -- Check before destroying
			    clone:Destroy()
            end
		end)

		return clone
	end

	function utility:InitializeKeybind()
        if self.keybindsInitialized then return end -- Prevent multiple initializations
		self.keybinds = {}
		self.ended = {} -- For MouseButton1 ended callbacks

		input.InputBegan:Connect(function(key, proc)
			-- Check if keybinds table exists before indexing
            if self.keybinds and self.keybinds[key.KeyCode] and not proc then
				for _, bindEntry in ipairs(self.keybinds[key.KeyCode]) do -- Use ipairs
					task.spawn(bindEntry.callback) -- Call the actual callback safely
				end
			end
		end)

		input.InputEnded:Connect(function(key)
			if key.UserInputType == Enum.UserInputType.MouseButton1 then
                -- Check if ended table exists
                if self.ended then
                    for _, callback in ipairs(self.ended) do -- Use ipairs
                        task.spawn(callback) -- Call safely
                    end
				end
			end
		end)
        self.keybindsInitialized = true -- Mark as initialized
	end

	function utility:BindToKey(key, callback)
        if not self.keybindsInitialized then utility:InitializeKeybind() end -- Ensure initialized

		self.keybinds[key] = self.keybinds[key] or {}
		-- Store callback in a table for easier removal by reference
        local bindEntry = { callback = callback }
		table.insert(self.keybinds[key], bindEntry)

		return {
			UnBind = function()
                if self.keybinds and self.keybinds[key] then
                    -- Iterate backwards when removing
                    for i = #self.keybinds[key], 1, -1 do
                        if self.keybinds[key][i] == bindEntry then
                            table.remove(self.keybinds[key], i)
                            break -- Assume only one instance
                        end
                    end
                    -- Optional cleanup: Remove key entry if list is empty
                    -- if #self.keybinds[key] == 0 then
                    --     self.keybinds[key] = nil
                    -- end
                end
			end
		}
	end

	function utility:KeyPressed() -- yield until next valid key is pressed
		while true do
			local key, gameProcessedEvent = input.InputBegan:Wait()
			if not gameProcessedEvent and key.UserInputType == Enum.UserInputType.Keyboard then
				-- Exclude modifier keys, allow Delete/Backspace
				local kc = key.KeyCode
				if kc ~= Enum.KeyCode.Unknown and
				   kc ~= Enum.KeyCode.LeftShift and kc ~= Enum.KeyCode.RightShift and
				   kc ~= Enum.KeyCode.LeftControl and kc ~= Enum.KeyCode.RightControl and
				   kc ~= Enum.KeyCode.LeftAlt and kc ~= Enum.KeyCode.RightAlt and
				   kc ~= Enum.KeyCode.LeftSuper and kc ~= Enum.KeyCode.RightSuper and
				   kc ~= Enum.KeyCode.CapsLock and kc ~= Enum.KeyCode.Menu then

					-- task.wait() -- Generally not needed here unless specific race conditions occur
					return key -- Return the full InputObject
				end
			end
            task.wait() -- Prevent potential tight loop if InputBegan fires rapidly with ignored keys
		end
	end

	function utility:DraggingEnabled(frame, parent)
		parent = parent or frame
        if not frame or not parent then return end -- Add checks

		local dragging = false
		local dragInput, mousePos, framePos
        local inputChangedConn -- To disconnect specific connection

		frame.InputBegan:Connect(function(inputObj) -- Renamed 'input' to 'inputObj'
			if inputObj.UserInputType == Enum.UserInputType.MouseButton1 then
				dragging = true
				mousePos = inputObj.Position
				framePos = parent.Position

                -- Disconnect previous connection if it exists
                if inputChangedConn then
                    inputChangedConn:Disconnect()
                    inputChangedConn = nil
                end

				inputChangedConn = inputObj.Changed:Connect(function()
					if inputObj.UserInputState == Enum.UserInputState.End then
						dragging = false
                        if inputChangedConn then -- Disconnect itself
                            inputChangedConn:Disconnect()
                            inputChangedConn = nil
                        end
					end
				end)
			end
		end)

		frame.InputChanged:Connect(function(inputObj)
			if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
				dragInput = inputObj
			end
		end)

		input.InputChanged:Connect(function(globalInputObj) -- Connect to global service
			if globalInputObj == dragInput and dragging then
				local delta = globalInputObj.Position - mousePos
                -- Check if parent still exists and has a parent itself
				if parent and parent.Parent then
					parent.Position = UDim2.new(framePos.X.Scale, framePos.X.Offset + delta.X, framePos.Y.Scale, framePos.Y.Offset + delta.Y)
                else
                    dragging = false -- Stop dragging if parent becomes invalid
                    if inputChangedConn then inputChangedConn:Disconnect(); inputChangedConn = nil end -- Clean up connection
				end
			end
		end)
	end

	function utility:DraggingEnded(callback)
        if not self.ended then self.ended = {} end -- Ensure 'ended' table exists
		table.insert(self.ended, callback)
	end

end -- End of Utility Functions Do block

-- Function to create the key prompt UI
function utility:KeyPrompt(correctKeyCallback)
	local theme = themes

	local keyPromptScreen = utility:Create("ScreenGui", {
		Name = "SCUI_KeyPromptScreen",
		Parent = CoreGui,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
		DisplayOrder = 1001,
        ResetOnSpawn = false -- Essential for CoreGui
	})

	local blur = utility:Create("BlurEffect", { Size = 8, Parent = Lighting })

	local main = utility:Create("ImageLabel", {
		Name = "main", Parent = keyPromptScreen, BackgroundTransparency = 1,
		Position = UDim2.new(0.5, 0, -0.5, 0), AnchorPoint = Vector2.new(0.5, 0.5),
		Size = UDim2.new(0, 320, 0, 160), Image = "rbxassetid://5028857472",
		ImageColor3 = theme.Background, ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(4, 4, 296, 296), ZIndex = 1
	}, {
		utility:Create("ImageLabel", { Name = "Glow", BackgroundTransparency = 1, Position = UDim2.new(0, -15, 0, -15), Size = UDim2.new(1, 30, 1, 30), ZIndex = 0, Image = "rbxassetid://5028857084", ImageColor3 = theme.Glow, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(24, 24, 276, 276) }),
		utility:Create("TextLabel", { Name = "Title", BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0, 20), AnchorPoint = Vector2.new(0.5, 0), Size = UDim2.new(0.9, 0, 0, 25), ZIndex = 2, Font = Enum.Font.GothamBold, Text = "SC UI - Key Required", TextColor3 = theme.TextColor, TextSize = 18, TextXAlignment = Enum.TextXAlignment.Center }),
		utility:Create("ImageLabel", { Name = "InputBackground", BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0.5, -15), AnchorPoint = Vector2.new(0.5, 0.5), Size = UDim2.new(0.85, 0, 0, 35), Image = "rbxassetid://5028857472", ImageColor3 = theme.DarkContrast, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298), ZIndex = 2 }, {
			utility:Create("TextBox", { Name = "KeyInput", BackgroundTransparency = 1, Size = UDim2.new(1, -10, 1, -4), Position = UDim2.new(0.5, 0, 0.5, 0), AnchorPoint = Vector2.new(0.5, 0.5), Font = Enum.Font.GothamSemibold, PlaceholderText = "Enter key...", PlaceholderColor3 = Color3.fromRGB(180, 180, 180), Text = "", TextColor3 = theme.TextColor, TextSize = 15, ClearTextOnFocus = false, TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Center, ZIndex = 3 })
		}),
		utility:Create("ImageButton", { Name = "SubmitButton", BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0.8, 0), AnchorPoint = Vector2.new(0.5, 0.5), Size = UDim2.new(0.5, 0, 0, 35), Image = "rbxassetid://5028857472", ImageColor3 = theme.Accent, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298), ZIndex = 2, AutoButtonColor = false }, { -- Added AutoButtonColor
			utility:Create("TextLabel", { Name = "SubmitText", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Font = Enum.Font.GothamBold, Text = "Submit", TextColor3 = theme.TextColor, TextSize = 16, ZIndex = 3 })
		})
	})

    -- Check if essential elements exist
    if not main or not main.Parent then
        warn("[SCUI Error] KeyPrompt main frame failed to create.")
        if keyPromptScreen and keyPromptScreen.Parent then keyPromptScreen:Destroy() end
        if blur and blur.Parent then blur:Destroy() end
        return -- Cannot proceed
    end
	local keyInput = main:FindFirstChild("KeyInput", true) -- Recursive search
	local submitButton = main:FindFirstChild("SubmitButton")

    if not keyInput or not submitButton then
         warn("[SCUI Error] KeyPrompt input/button not found.")
         if keyPromptScreen and keyPromptScreen.Parent then keyPromptScreen:Destroy() end
         if blur and blur.Parent then blur:Destroy() end
         return
    end

	utility:Tween(main, {Position = UDim2.new(0.5, 0, 0.5, 0)}, 0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out)

	local function shakeElement(element)
        if not element or not element.Parent then return end
		local originalPos = element.Position
		for _ = 1, 3 do
			utility:Tween(element, {Position = originalPos + UDim2.fromOffset(8, 0)}, 0.05)
			task.wait(0.05)
			utility:Tween(element, {Position = originalPos - UDim2.fromOffset(8, 0)}, 0.05)
			task.wait(0.05)
		end
		utility:Tween(element, {Position = originalPos}, 0.05)
	end

	local connectionSubmit, connectionFocusLost
    local isSubmitting = false -- Debounce

	local handleSubmit = function()
        if isSubmitting then return end
        isSubmitting = true

		local enteredKey = keyInput.Text
		local correctKey = "hh.hg**@@"

		if enteredKey == correctKey then
			if connectionSubmit then connectionSubmit:Disconnect(); connectionSubmit = nil end
			if connectionFocusLost then connectionFocusLost:Disconnect(); connectionFocusLost = nil end

			utility:Tween(main, {Position = UDim2.new(0.5, 0, 1.5, 0)}, 0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)
			task.wait(0.3)

            -- Robust cleanup
			if keyPromptScreen and keyPromptScreen.Parent then keyPromptScreen:Destroy() end
			if blur and blur.Parent then blur:Destroy() end

            pcall(correctKeyCallback) -- Call safely
            -- No need to reset isSubmitting here, UI is gone
		else
			shakeElement(main)
            if keyInput and keyInput.Parent then -- Check validity
                keyInput.Text = ""
                keyInput.PlaceholderText = "Incorrect key!"
            end
			task.spawn(function()
				task.wait(1.5)
				if keyInput and keyInput.Parent then
					keyInput.PlaceholderText = "Enter key..."
				end
			end)
            isSubmitting = false -- Reset only on failure
		end
	end

	connectionSubmit = submitButton.MouseButton1Click:Connect(handleSubmit)
	connectionFocusLost = keyInput.FocusLost:Connect(function(enterPressed)
		if enterPressed then
			handleSubmit()
		end
	end)
end


-- classes
local library = {}
local page = {}
local section = {}

do -- Class implementations block
	library.__index = library
	page.__index = page
	section.__index = section

	-- library.new --
	function library.new(title)
		local self = setmetatable({
			container = nil, -- The main ScreenGui
			pagesContainer = nil, -- The ScrollingFrame for page buttons (left side)
            pageContentContainer = nil, -- The Frame holding the actual page content ScrollingFrames
			pages = {}, -- Array of page objects
            focusedPage = nil, -- Currently selected page object
            notificationContainer = nil, -- Frame for notifications
			toggling = false, -- Minimize/restore state flag
			position = nil, -- Stored position for restore
            watermarkScreenGui = nil, -- Reference to watermark container
            watermarkElements = {},
            fpsUpdaterRunning = false,
            fpsWatermarkControls = nil,
            keybindsInitialized = false -- Track if keybinds are set up
		}, library)

		print("-- SC UI Initializing... --") -- Simple log

		-- Show key prompt and wait using BindableEvent
		local keyEnteredEvent = Instance.new("BindableEvent")
		utility:KeyPrompt(function()
			keyEnteredEvent:Fire()
		end)
		keyEnteredEvent.Event:Wait() -- Wait until fired
        keyEnteredEvent:Destroy() -- Cleanup event

		-- Create the main UI after key is accepted
		title = title or "SC UI"
		local container = utility:Create("ScreenGui", {
			Name = title, Parent = CoreGui,
			ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
			Enabled = false, -- Start disabled for fade-in
            ResetOnSpawn = false -- Essential for CoreGui
		})
		self.container = container -- Assign early for checks

        local mainFrame = utility:Create("ImageLabel", {
            Name = "Main", Parent = container, BackgroundTransparency = 1,
            Position = UDim2.new(0.25, 0, 0.05, 0), Size = UDim2.new(0, 511, 0, 428),
            Image = "rbxassetid://4641149554", ImageColor3 = themes.Background,
            ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(4, 4, 296, 296)
        })
        self.pageContentContainer = mainFrame -- Page content goes here

        -- Check if main frame was created
        if not mainFrame or not mainFrame.Parent then
            warn("[SCUI Error] Failed to create Main UI Frame.")
            if container and container.Parent then container:Destroy() end
            return nil
        end

        -- Create children of Main Frame
        local mainChildren = {
            utility:Create("ImageLabel", { -- Glow
                Name = "Glow", BackgroundTransparency = 1, Position = UDim2.new(0, -18, 0, -18), Size = UDim2.new(1, 36, 1, 36), ZIndex = 0, Image = "rbxassetid://5028857084", ImageColor3 = themes.Glow, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(24, 24, 276, 276)
            }),
            utility:Create("ImageLabel", { -- Pages List Background (Left Sidebar)
                Name = "Pages", BackgroundTransparency = 1, ClipsDescendants = true, Position = UDim2.new(0, 0, 0, 38), Size = UDim2.new(0, 126, 1, -38), ZIndex = 3, Image = "rbxassetid://5012534273", ImageColor3 = themes.DarkContrast, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(4, 4, 296, 296)
            }, {
                utility:Create("ScrollingFrame", { -- Actual container for Page Buttons
                    Name = "Pages_Container", Active = true, BackgroundTransparency = 1, Position = UDim2.new(0, 0, 0, 0), Size = UDim2.new(1, 0, 1, 0), -- Fill the sidebar bg
                    CanvasSize = UDim2.new(0, 0, 0, 0), AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollBarThickness = 4, ScrollBarImageColor3 = themes.Accent
                }, {
                    utility:Create("UIListLayout", { Name = "PageButtonLayout", SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 10), FillDirection = Enum.FillDirection.Vertical, HorizontalAlignment = Enum.HorizontalAlignment.Center, VerticalAlignment = Enum.VerticalAlignment.Top }),
                    utility:Create("UIPadding", { PaddingTop = UDim.new(0, 10), PaddingBottom = UDim.new(0, 10) }) -- Padding inside scroll frame
                })
            }),
            utility:Create("ImageLabel", { -- Top Bar
                Name = "TopBar", BackgroundTransparency = 1, ClipsDescendants = true, Size = UDim2.new(1, 0, 0, 38), Position = UDim2.new(0,0,0,0), ZIndex = 5, Image = "rbxassetid://4595286933", ImageColor3 = themes.Accent, ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(4, 4, 296, 296)
            }, {
                utility:Create("TextLabel", { -- Title in Top Bar
                    Name = "Title", AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1, Position = UDim2.new(0, 12, 0.5, 0), Size = UDim2.new(1, -46, 0, 16), ZIndex = 5, Font = Enum.Font.GothamBold, Text = title, TextColor3 = themes.TextColor, TextSize = 14, TextXAlignment = Enum.TextXAlignment.Left
                })
            })
        }
        -- Parent main children correctly
        for _, child in ipairs(mainChildren) do
            if child then child.Parent = mainFrame end
        end

        -- Assign pagesContainer reference
		self.pagesContainer = mainFrame:FindFirstChild("Pages_Container", true)

		-- Notification Container (Top-Right)
		local notificationContainer = utility:Create("Frame", {
			Name = "NotificationContainer", Parent = container, BackgroundTransparency = 1,
			Size = UDim2.new(0, 250, 0, 300), Position = UDim2.new(1, -260, 0, 10),
			ZIndex = 100, ClipsDescendants = true
		}, {
			utility:Create("UIListLayout", { Name = "Layout", SortOrder = Enum.SortOrder.LayoutOrder, FillDirection = Enum.FillDirection.Vertical, HorizontalAlignment = Enum.HorizontalAlignment.Right, VerticalAlignment = Enum.VerticalAlignment.Top, Padding = UDim.new(0, 5) })
		})
		self.notificationContainer = notificationContainer

		-- Initialize subsystems safely
        pcall(utility.InitializeKeybind, self)
        local topBar = mainFrame:FindFirstChild("TopBar")
        if topBar then pcall(utility.DraggingEnabled, self, topBar, mainFrame) end

		-- Add Watermark (using task.spawn for safety)
		task.spawn(function() pcall(self.Watermark, self) end)

		-- Show welcome notification (delayed and safe)
		task.delay(0.5, function() pcall(self.Notify, self, "Welcome!", "SC UI Initialized.", { type = "success", duration = 3 }) end)

		-- Fade In Main UI
		container.Enabled = true
		mainFrame.BackgroundTransparency = 1
		local glow = mainFrame:FindFirstChild("Glow")
        local pagesFrame = mainFrame:FindFirstChild("Pages")
		if glow then glow.ImageTransparency = 1 end
		if pagesFrame then pagesFrame.ImageTransparency = 1 end
        if topBar then topBar.ImageTransparency = 1 end

        utility:Tween(mainFrame, { BackgroundTransparency = 0 }, 0.3)
		if glow then utility:Tween(glow, { ImageTransparency = 0 }, 0.3) end
        if pagesFrame then utility:Tween(pagesFrame, { ImageTransparency = 0 }, 0.3) end
		if topBar then utility:Tween(topBar, { ImageTransparency = 0 }, 0.3) end

		return self
	end

	-- page.new --
	function page.new(library, title, icon)
        local theme = themes

		-- Create the Content Container first (ScrollingFrame on the right)
        local contentContainer = utility:Create("ScrollingFrame", {
			Name = title .. "_Content", Parent = library.pageContentContainer, -- Parent to Main frame
			Active = true, BackgroundTransparency = 1, BorderSizePixel = 0,
			Position = UDim2.new(0, 126, 0, 38), -- Right of sidebar, below topbar
			Size = UDim2.new(1, -126, 1, -38), -- Fill remaining space
			CanvasSize = UDim2.new(0, 0, 0, 0), AutomaticCanvasSize = Enum.AutomaticSize.Y, -- Auto height
			ScrollBarThickness = 4, ScrollBarImageColor3 = theme.Accent,
			Visible = false, -- Start hidden
            ZIndex = 2
		}, {
			utility:Create("UIListLayout", { Name = "SectionLayout", SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 10), FillDirection = Enum.FillDirection.Vertical, HorizontalAlignment = Enum.HorizontalAlignment.Center, VerticalAlignment = Enum.VerticalAlignment.Top }),
            utility:Create("UIPadding", { PaddingLeft = UDim.new(0, 8), PaddingRight = UDim.new(0, 8), PaddingTop = UDim.new(0, 8), PaddingBottom = UDim.new(0, 8) })
		})

        -- Create the Button (goes in the left sidebar)
		local buttonChildren = {
            utility:Create("TextLabel", { Name = "Title", AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1, Position = UDim2.new(0, icon and 40 or 15, 0.5, 0), Size = UDim2.new(1, -(icon and 45 or 20), 1, 0), ZIndex = 3, Font = Enum.Font.Gotham, Text = title, TextColor3 = theme.TextColor, TextSize = 12, TextTransparency = 0.65, TextXAlignment = Enum.TextXAlignment.Left }),
            utility:Create("Frame", { Name = "HoverBG", BackgroundTransparency = 1, BackgroundColor3 = theme.LightContrast, Size = UDim2.new(1, 0, 1, 0), ZIndex = 1, Visible = false }) -- Hover/Selected BG
        }
		if icon then
			table.insert(buttonChildren, 1, utility:Create("ImageLabel", { -- Insert icon before title if present
				Name = "Icon", AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1, Position = UDim2.new(0, 15, 0.5, 0), Size = UDim2.new(0, 16, 0, 16), ZIndex = 3, Image = icon, ImageColor3 = theme.TextColor, ImageTransparency = 0.65
			}))
		end

		local button = utility:Create("TextButton", {
			Name = title .. "_Button", Parent = library.pagesContainer, -- Parent to left sidebar scrolling frame
			BackgroundTransparency = 1, BorderSizePixel = 0,
			Size = UDim2.new(1, -10, 0, 26), -- Almost full width, fixed height
            Position = UDim2.new(0.5, 0, 0, 0), AnchorPoint = Vector2.new(0.5, 0), -- Centered horizontally
			ZIndex = 3, AutoButtonColor = false, Text = "",
            LayoutOrder = #library.pages + 1
		}, buttonChildren)

        -- Create the page object instance
		local pageInstance = setmetatable({
			library = library,
			container = contentContainer, -- The content ScrollingFrame
			button = button, -- The button in the sidebar
			sections = {}, -- Array of section objects
            lastScrollPosition = 0 -- To restore scroll position
		}, page)

		-- Button Hover/Click Logic
		local hoverBG = button:FindFirstChild("HoverBG")
		if hoverBG then
            button.MouseEnter:Connect(function()
                if library.focusedPage ~= pageInstance then
                    hoverBG.BackgroundTransparency = 0.8
                    hoverBG.Visible = true
                end
            end)
            button.MouseLeave:Connect(function()
                 if library.focusedPage ~= pageInstance then
                    hoverBG.Visible = false
                 end
            end)
        end
		button.MouseButton1Click:Connect(function()
            library:SelectPage(pageInstance) -- Tell the library to select this page
        end)

		return pageInstance
	end

	-- section.new --
	function section.new(page, title)
        local theme = themes
		-- Main section frame (ImageLabel background)
        local sectionFrame = utility:Create("ImageLabel", {
			Name = title .. "_Section", Parent = page.container, -- Parent to page's content container
			BackgroundTransparency = 1,
            AutomaticSize = Enum.AutomaticSize.Y, -- Auto height based on content
            Size = UDim2.new(1, 0, 0, 30), -- Full width, initial min height
			ZIndex = 2, Image = "rbxassetid://5028857472",
			ImageColor3 = theme.LightContrast:Lerp(theme.Background, 0.1),
			ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(4, 4, 296, 296),
			ClipsDescendants = true,
            LayoutOrder = #page.sections + 1 -- Add to end of page layout
		})

        -- Inner container Frame for padding and module layout
        local moduleContainer = utility:Create("Frame", {
            Name = "Container", Parent = sectionFrame,
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 1, 0), -- Fill section frame
            AutomaticSize = Enum.AutomaticSize.Y
        })

        -- Children of moduleContainer (Padding, Title, Layout)
        local moduleContainerChildren = {
             utility:Create("UIPadding", { PaddingLeft = UDim.new(0, 8), PaddingRight = UDim.new(0, 8), PaddingTop = UDim.new(0, 8), PaddingBottom = UDim.new(0, 8) }),
             utility:Create("TextLabel", { Name = "Title", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 20), AutomaticSize = Enum.AutomaticSize.Y, ZIndex = 2, Font = Enum.Font.GothamSemibold, Text = title, TextColor3 = theme.TextColor, TextSize = 12, TextXAlignment = Enum.TextXAlignment.Left, TextWrapped = true, LayoutOrder = 0 }),
             utility:Create("UIListLayout", { Name = "ModuleLayout", SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 6), FillDirection = Enum.FillDirection.Vertical, HorizontalAlignment = Enum.HorizontalAlignment.Center, VerticalAlignment = Enum.VerticalAlignment.Top, ItemLineAlignment = Enum.ItemLineAlignment.Width, LayoutOrder = 1 })
        }
        for _, child in ipairs(moduleContainerChildren) do
            if child then child.Parent = moduleContainer end
        end

        -- Create section object instance
		local sectionInstance = setmetatable({
			page = page,
			container = moduleContainer, -- Where modules (buttons, toggles) are parented
            frame = sectionFrame, -- The outer ImageLabel for visibility/sizing
		}, section)

        -- Resize after a frame to allow auto-sizing to calculate
        task.wait()
        sectionInstance:Resize()

		return sectionInstance
	end

	-- Library Methods --

	function library:addPage(title, icon)
		local newPage = page.new(self, title, icon)
        if newPage then
		    table.insert(self.pages, newPage)
            -- Automatically select the first page added
            if #self.pages == 1 then
                self:SelectPage(newPage)
            end
    		return newPage
        else
            warn("[SCUI Error] Failed to create page:", title)
            return nil
        end
	end

	function page:addSection(title)
		local newSection = section.new(self, title)
		if newSection then
            table.insert(self.sections, newSection)
    		return newSection
        else
            warn("[SCUI Error] Failed to create section:", title, "on page:", self.button and self.button.Name or "Unknown")
            return nil
        end
	end

	function library:setTheme(themeName, color3)
        if not themes[themeName] then
            warn("[SCUI Warning] Theme '"..tostring(themeName).."' does not exist.")
            return
        end
		themes[themeName] = color3 -- Update the theme color

        -- Update existing objects using weak references
		if objects[themeName] then
			for property, weakObjMap in pairs(objects[themeName]) do
                -- Iterate through the weak map (keys are objects)
				for objectRef, _ in pairs(weakObjMap) do
					if objectRef and objectRef.Parent then -- Check if object still exists
                        -- Use pcall to safely set the property
                        local success, err = pcall(function() objectRef[property] = color3 end)
                        if not success then
                            warn("[SCUI Theme Error] Failed to set", property, "on", objectRef:GetFullName(), "-", err)
                        end
					else
						-- Remove dead reference (object likely destroyed)
                        weakObjMap[objectRef] = nil
					end
				end
			end
		end
	end

	function library:toggle() -- Minimize/Restore
		if self.toggling or not self.container or not self.container.Parent then return end
		self.toggling = true

		local mainFrame = self.container:FindFirstChild("Main")
        if not mainFrame then self.toggling = false; return end

		if self.position then -- Restore
            mainFrame.ClipsDescendants = false -- Allow overflow before resizing
			utility:Tween(mainFrame, {
				Size = UDim2.new(0, 511, 0, 428),
				Position = self.position
			}, 0.2)
			self.position = nil
		else -- Minimize
			self.position = mainFrame.Position -- Store position
			utility:Tween(mainFrame, {
				Size = UDim2.new(0, 511, 0, 38), -- Shrink to top bar height
			}, 0.2)
            -- Don't tween top bar size, just let ClipsDescendants hide the rest
			task.wait(0.2) -- Wait for shrink before clipping
            mainFrame.ClipsDescendants = true
		end

		task.delay(0.3, function() self.toggling = false end) -- Reset flag after animation
	end

	-- Watermark System (Assuming original code is complex but functional)
	function library:Watermark(...)
        -- Keep your existing Watermark code here.
        -- Ensure it uses task.wait/spawn and checks self.container validity.
        if not self.container or not self.container.Parent then
             warn("[SCUI Warning] Cannot create watermark, main container missing.")
             return nil -- Return nil or an empty control table
        end
        print("[SCUI Info] Watermark function called (assuming original implementation).")
        -- Placeholder return
        return { AddWatermark = function() return { Hide=function()end, Show=function()end, Text=function()end, Remove=function()end } end, Remove=function()end }
	end

	-- Reworked Notification System (Assuming original code is complex but functional)
	function library:Notify(...)
        -- Keep your existing Notification code here.
        -- Ensure it uses task.wait/spawn and checks self.notificationContainer validity.
		if not self.notificationContainer or not self.notificationContainer.Parent then
			warn("[SCUI Warning] Notification container not found.")
			return
		end
        print("[SCUI Info] Notify function called (assuming original implementation).")
        -- ... (Your existing Notify logic using task.wait/spawn) ...
	end

	-- Section Methods (Adding Modules) --

	function section:addButton(title, callback)
        local theme = themes
		local button = utility:Create("ImageButton", {
			Name = "Button_" .. title:gsub("%s+", ""), Parent = self.container, -- Parent to inner container
			BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 30),
			ZIndex = 2, Image = "rbxassetid://5028857472", ImageColor3 = theme.DarkContrast,
			ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298),
            AutoButtonColor = false, LayoutOrder = #self.container:GetChildren()
		}, {
			utility:Create("TextLabel", { Name = "Title", BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), ZIndex = 3, Font = Enum.Font.Gotham, Text = title, TextColor3 = theme.TextColor, TextSize = 12, TextTransparency = 0.1 }),
            utility:Create("UICorner", { CornerRadius = UDim.new(0, 3) })
		})

		local debounce = false
		button.MouseButton1Click:Connect(function()
			if debounce then return end
			debounce = true

            utility:Pop(button, 6) -- Smaller pop effect
			local text = button:FindFirstChild("Title")
			if text then -- Animate text size slightly
                local tween1 = utility:Tween(text, {TextSize = 13}, 0.1)
                if tween1 then tween1.Completed:Wait() end -- Wait for tween
                local tween2 = utility:Tween(text, {TextSize = 12}, 0.1)
            end

			if callback then
                local updateFunc = function(newTitle) -- Function to update button text later
                    if button and button.Parent and text then text.Text = newTitle or title end
                end
				task.spawn(callback, updateFunc) -- Call callback safely in new thread
			end

            task.delay(0.3, function() debounce = false end) -- Reset debounce after delay
		end)

		self:Resize() -- Trigger resize after adding
		return button
	end

	function section:addToggle(title, default, callback)
        local theme = themes
        -- Base frame for the toggle row
        local toggleFrame = utility:Create("Frame", {
            Name = "Toggle_"..title:gsub("%s+", ""), Parent = self.container,
            BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 30), -- Full width, fixed height
            LayoutOrder = #self.container:GetChildren()
        })

        -- Title Label on the left
        utility:Create("TextLabel", {
            Name = "Title", Parent = toggleFrame,
            AnchorPoint = Vector2.new(0, 0.5), BackgroundTransparency = 1,
            Position = UDim2.new(0, 10, 0.5, 0), Size = UDim2.new(1, -65, 1, -4), -- Leave space for switch
            ZIndex = 3, Font = Enum.Font.Gotham, Text = title, TextColor3 = theme.TextColor,
            TextSize = 12, TextTransparency = 0.1,
            TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Center
        })

        -- The switch button on the right
        local buttonSize = Vector2.new(40, 16)
        local switchButton = utility:Create("ImageButton", {
            Name = "Switch", Parent = toggleFrame,
            AnchorPoint = Vector2.new(1, 0.5), Position = UDim2.new(1, -10, 0.5, 0), -- Position from right
            Size = UDim2.fromOffset(buttonSize.X, buttonSize.Y), ZIndex = 2,
            Image = "rbxassetid://5028857472", ImageColor3 = theme.LightContrast,
            ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(2, 2, 298, 298),
            AutoButtonColor = false
        }, {
            utility:Create("UICorner", { CornerRadius = UDim.new(1, 0) }), -- Rounded ends
            utility:Create("Frame", { -- The moving knob
                Name = "Knob", AnchorPoint = Vector2.new(0.5, 0.5),
                Size = UDim2.fromOffset(buttonSize.Y - 4, buttonSize.Y - 4), -- Square knob based on height
                Position = UDim2.new(0, (buttonSize.Y - 4)/2 + 2, 0.5, 0), -- Start left (+padding)
                BackgroundColor3 = theme.TextColor, ZIndex = 3, BorderSizePixel = 0
            }, {
                 utility:Create("UICorner", { CornerRadius = UDim.new(1, 0) }) -- Rounded knob
            })
        })

        local knob = switchButton:FindFirstChild("Knob")
        local active = default or false -- Current state

        -- Function to update the visual appearance
        local function updateVisuals(isOn)
            if not knob or not knob.Parent or not switchButton or not switchButton.Parent then return end
            local knobSize = knob.AbsoluteSize
            -- Calculate target X position based on button width and knob size/padding
            local targetX = isOn and (buttonSize.X - knobSize.X/2 - 2) or (knobSize.X/2 + 2)
            local targetPos = UDim2.new(0, targetX, 0.5, 0)
            local targetColor = isOn and theme.NotifSuccess or theme.LightContrast -- Green when on

            utility:Tween(knob, { Position = targetPos }, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            utility:Tween(switchButton, { ImageColor3 = targetColor }, 0.15)
        end

        updateVisuals(active) -- Set initial state

		switchButton.MouseButton1Click:Connect(function()
			active = not active -- Toggle state
			updateVisuals(active) -- Update visuals

			if callback then
                -- Function allows callback to force-update the toggle state if needed
                local updateFunc = function(forceState)
                    if type(forceState) == "boolean" and forceState ~= active then
                        active = forceState
                        updateVisuals(active)
                    end
                end
				task.spawn(callback, active, updateFunc) -- Pass current state and update function
			end
		end)

        self:Resize() -- Resize section after adding
		return toggleFrame -- Return the main frame for this toggle
	end

	-- ... Implement addTextbox, addKeybind, addColorPicker, addSlider, addDropdown similarly ...
    -- Remember to:
    -- 1. Parent to `self.container` (the inner frame of the section)
    -- 2. Add `LayoutOrder = #self.container:GetChildren()`
    -- 3. Call `self:Resize()` at the end
    -- 4. Use `task.spawn` for callbacks
    -- 5. Add `UICorner` where appropriate
    -- 6. Use `FindFirstChild` and validity checks


	-- Module Update Functions --

	function section:updateButton(button, title)
		button = self:getModule(button) -- Find the button instance
        if not button or not button.Parent then return end -- Check validity

        local textLabel = button:FindFirstChild("Title")
        if textLabel and title then
		    textLabel.Text = title
        end
	end

	function section:updateToggle(toggleFrame, title, value)
		toggleFrame = self:getModule(toggleFrame) -- Find the toggle's base frame
        if not toggleFrame or not toggleFrame.Parent then return end

        local titleLabel = toggleFrame:FindFirstChild("Title")
        local switchButton = toggleFrame:FindFirstChild("Switch")
        local knob = switchButton and switchButton:FindFirstChild("Knob")

        if not titleLabel or not switchButton or not knob then return end -- Check elements exist

		if title then titleLabel.Text = title end

        -- Manually update visuals if 'value' is provided
		if type(value) == "boolean" then
            local theme = themes
            local buttonSize = switchButton.AbsoluteSize
            local knobSize = knob.AbsoluteSize
            local targetX = value and (buttonSize.X - knobSize.X/2 - 2) or (knobSize.X/2 + 2)
            local targetPos = UDim2.new(0, targetX, 0.5, 0)
            local targetColor = value and theme.NotifSuccess or theme.LightContrast

            utility:Tween(knob, { Position = targetPos }, 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            utility:Tween(switchButton, { ImageColor3 = targetColor }, 0.15)
            -- Note: This directly sets visuals. It doesn't update the internal 'active' state
            -- used by the click event. The callback should ideally handle state logic.
		end
	end

    -- ... Implement other update functions (updateTextbox, updateKeybind, etc.) ...
    -- Ensure they use `getModule`, check validity, and use `FindFirstChild`.


	-- Other Class Functions --

	-- Corrected SelectPage Logic
	function library:SelectPage(pageToSelect)
        if not pageToSelect or self.focusedPage == pageToSelect then
            return -- Ignore if invalid or already selected
        end
        -- Verify the page belongs to this library instance
        local found = false
        for _, p in ipairs(self.pages) do if p == pageToSelect then found = true; break end end
        if not found then
             warn("[SCUI Warning] Attempted to select a page not registered with this library.")
             return
        end

        local previouslyFocused = self.focusedPage
        self.focusedPage = pageToSelect

        -- Update all pages
        for _, pageInstance in ipairs(self.pages) do
            local isSelected = (pageInstance == pageToSelect)
            local button = pageInstance.button
            local container = pageInstance.container

            -- Update content container visibility
            if container and container.Parent then
                 -- Store scroll position of previously focused page before hiding
                 if not isSelected and container.Visible and previouslyFocused == pageInstance then
                    pageInstance.lastScrollPosition = container.CanvasPosition.Y
                 end
                 container.Visible = isSelected
            end

            -- Update button appearance
            if button and button.Parent then
                 local titleLabel = button:FindFirstChild("Title")
                 local iconLabel = button:FindFirstChild("Icon")
                 local hoverBG = button:FindFirstChild("HoverBG")

                 if titleLabel then
                     titleLabel.TextTransparency = isSelected and 0 or 0.65
                     titleLabel.Font = isSelected and Enum.Font.GothamSemibold or Enum.Font.Gotham
                 end
                 if iconLabel then
                     iconLabel.ImageTransparency = isSelected and 0 or 0.65
                 end
                 if hoverBG then
                     hoverBG.Visible = isSelected -- Only show BG if selected
                     if isSelected then hoverBG.BackgroundTransparency = 0 end
                 end
            end
        end

        -- Resize and scroll the newly selected page (defer to allow layout updates)
        if pageToSelect.container and pageToSelect.container.Parent then
            task.defer(pageToSelect.Resize, pageToSelect, true) -- Pass 'true' to apply scroll
        end
	end

	function page:Resize(applyScroll)
        if not self.container or not self.container.Parent then return end
        -- AutomaticCanvasSize should handle the height. We focus on scroll position.
        if applyScroll then
            local targetY = self.lastScrollPosition or 0
            -- Clamp scroll position within valid bounds
            local maxScroll = self.container.CanvasSize.Y.Offset - self.container.AbsoluteSize.Y
            targetY = math.clamp(targetY, 0, math.max(0, maxScroll))
            utility:Tween(self.container, { CanvasPosition = Vector2.new(0, targetY) }, 0.2)
        end
        -- Update scrollbar visibility (may need manual check if AutoCanvasSize is slow)
        task.delay(0.1, function() -- Check after delay
             if self.container and self.container.Parent then
                 local contentHeight = self.container.CanvasSize.Y.Offset
                 local viewHeight = self.container.AbsoluteSize.Y
                 self.container.ScrollBarImageTransparency = contentHeight <= viewHeight and 1 or 0
             end
        end)
	end

	function section:Resize(smooth) -- Smooth optional, might conflict with auto-sizing
        -- AutomaticSize should handle the section's frame height.
        -- We need to ensure the *page's* container resizes if a section changes significantly.
        if self.page and self.page.Resize then
             -- Call page resize after a short delay to let section auto-size settle
             task.delay(0.05, function()
                  if self.page and self.page.Resize then
                      self.page:Resize() -- Don't apply scroll usually when resizing section
                  end
             end)
        end
	end

	-- Improved getModule
	function section:getModule(info)
		if not self.container or not self.container.Parent then return nil end -- Check section validity

		if typeof(info) == "Instance" and info:IsDescendantOf(self.container) then
			return info -- Already have the instance
		end

        if typeof(info) == "string" then
            -- Try finding by name (using the pattern defined in addX methods)
            local potentialName = (info:match("^[A-Za-z]+_") and info) or ("Button_"..info:gsub("%s+","")) -- Basic guess, adjust patterns if needed
            local found = self.container:FindFirstChild(potentialName)
            if found then return found end

            -- Fallback: Search by Title Text (less reliable)
            for _, moduleFrame in ipairs(self.container:GetChildren()) do
                -- Check TextLabel named "Title" or TextBox for Textbox modules
                local titleSource = moduleFrame:FindFirstChild("Title") or moduleFrame:FindFirstChildWhichIsA("TextBox")
                if titleSource and titleSource.Text == info then
                    return moduleFrame
                end
                -- Add checks for other elements if needed (e.g., Dropdown TextBox)
                 local searchBox = moduleFrame:FindFirstChild("Search", true) -- Check Dropdown
                 if searchBox and searchBox:IsA("ImageLabel") then
                     local dropTextBox = searchBox:FindFirstChild("TextBox")
                     if dropTextBox and dropTextBox.Text == info then
                         return moduleFrame -- Return the main dropdown frame
                     end
                 end
            end
        end

		warn("[SCUI Warning] Module not found:", tostring(info), "in section:", self.frame.Name)
        return nil -- Return nil instead of erroring
	end


end -- End of Class implementations block

return library
