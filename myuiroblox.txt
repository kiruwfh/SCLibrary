lua --[[ UI lib originally by bungie#0001 Modified and Enhanced by SupremeCreativity (sc.owner) Version: 3.0.0 (Enhanced) - Significant modifications include: Key System, Enhanced Introduction, Usage Time Tracking, Webhook Integration, Renaming (xsx -> SC), Animation Improvements, and additional features. - Please obtain permission before reusing modified components. ]] -- / Core Services local Workspace = game:GetService("Workspace") local Players = game:GetService("Players") local UserInputService = game:GetService("UserInputService") local TextService = game:GetService("TextService") local TweenService = game:GetService("TweenService") local RunService = game:GetService("RunService") local CoreGuiService = game:GetService("CoreGui") local ContentService = game:GetService("ContentProvider") local TeleportService = game:GetService("TeleportService") local HttpService = game:GetService("HttpService") local StarterGui = game:GetService("StarterGui") -- For notifications -- / Local Player & Mouse local Player = Players.LocalPlayer local Mouse = Player:GetMouse() -- / Configuration local Config = { Key = "hh.hg**@@", -- The required key WebhookURL = "https://discord.com/api/webhooks/1353802030740803684/sjogfRtn6rXRF83IY-Y2b8fULjbQSZY29eXaApOEKBSq8RdqH8P6qy-tdQASb1glu4mm", DebugMode = false -- Set to true for more console output } -- / State Variables local isAuthenticated = false local isGuiActive = false -- Track if the main GUI is currently intended to be active local sessionStartTime = 0 local totalUsageTime = 0 -- Placeholder, real persistence is complex client-side local sessionTimeUpdateCoroutine = nil local lastWebhookUpdateTime = 0 local webhookUpdateInterval = 60 -- Update webhook with time every 60 seconds -- / Helper Functions local function DebugPrint(...) if Config.DebugMode then print("[SC Lib DEBUG]", ...) end end -- Generate a unique-ish ID for this session local sessionId = HttpService:GenerateGUID(false) -- / Webhook Functionality local function SendToWebhook(payload) if not Config.WebhookURL or Config.WebhookURL == "" then DebugPrint("Webhook URL is not set. Skipping send.") return end local success, err = pcall(function() local data = { embeds = { payload } -- Send payload directly as the first embed } local headers = {["Content-Type"] = "application/json"} HttpService:PostAsync(Config.WebhookURL, HttpService:JSONEncode(data), Enum.HttpContentType.ApplicationJson, false, headers) end) if not success then warn("[SC Lib Webhook Error] Failed to send webhook:", err) end end -- / Tween table & function local TweenTable = { Default = { TweenInfo.new(0.17, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0) } } local CreateTween = function(name, speed, style, direction, loop, reverse, delay) name = name speed = speed or 0.17 style = style or Enum.EasingStyle.Sine direction = direction or Enum.EasingDirection.InOut loop = loop or 0 reverse = reverse or false delay = delay or 0 TweenTable[name] = TweenInfo.new(speed, style, direction, loop, reverse, delay) end -- Pre-create common tweens CreateTween("fast_fade", 0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out) CreateTween("medium_fade", 0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut) CreateTween("slow_fade", 0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut) CreateTween("button_hover", 0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out) CreateTween("toggle_anim", 0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out) CreateTween("intro_element_appear", 0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out) CreateTween("intro_element_disappear", 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In) CreateTween("key_prompt_fade", 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut) CreateTween("scale_pop", 0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out) CreateTween("slide_in", 0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.Out) CreateTween("slide_out", 0.3, Enum.EasingStyle.Quint, Enum.EasingDirection.In) -- / Dragging (Slightly improved responsiveness) local drag = function(obj, latency) obj = obj latency = latency or 0.04 -- Reduced latency for smoother feel local dragging = false local inputObject = nil local dragStart = nil local startPos = nil local function updateInput(input) if not dragging then return end local delta = input.Position - dragStart local newPosition = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y) -- Use a direct set for lower latency feel instead of tween during drag -- TweenService:Create(obj, TweenInfo.new(latency), {Position = newPosition}):Play() obj.Position = newPosition end obj.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then dragging = true dragStart = input.Position startPos = obj.Position inputObject = input local connection connection = input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false if connection then connection:Disconnect() connection = nil end end end) end end) obj.InputChanged:Connect(function(input) if input == inputObject and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then updateInput(input) end end) -- Use UserInputService.InputChanged for smoother tracking, especially for touch UserInputService.InputChanged:Connect(function(input) if input == inputObject and dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then updateInput(input) end end) end -- / Main Library Table local library = { version = "3.0.0", title = title or "SC Lib " .. tostring(math.random(1, 1000)), -- Renamed fps = 0, rank = "private", -- Or whatever status creator = "SupremeCreativity (sc.owner)" -- New creator info } local sc = library -- Alias for shorter access if needed -- FPS Counter Coroutine coroutine.wrap(function() local lastTime = tick() local frameCounter = 0 while task.wait(1) do local currentTime = tick() local deltaTime = currentTime - lastTime local currentFps = math.floor(frameCounter / deltaTime + 0.5) library.fps = currentFps frameCounter = 0 lastTime = currentTime end end)() RunService.RenderStepped:Connect(function(v) -- This direct calculation is simple but can be very noisy. -- A rolling average might be smoother, but the coroutine above provides a 1-second average. -- library.fps = math.round(1/v) -- Keep the coroutine-based FPS for stability if typeof(v) == 'number' and v > 0 then -- Check v is a valid number -- library.fps = math.floor(1/v + 0.5) -- Keep original RenderStepped calculation if preferred end -- Update frame counter for the coroutine frameCounter = (frameCounter or 0) + 1 end) -- / Utility Functions function library:RoundNumber(int, float) return tonumber(string.format("%." .. (int or 0) .. "f", float)) end function library:GetUsername() return Player.Name end function library:CheckIfLoaded() return game:IsLoaded() end function library:GetUserId() return Player.UserId end function library:GetPlaceId() return game.PlaceId end function library:GetJobId() return game.JobId end function library:Rejoin() local placeId = library:GetPlaceId() local jobId = library:GetJobId() local userId = library:GetUserId() if placeId and jobId and userId then pcall(TeleportService.TeleportToPlaceInstance, TeleportService, placeId, jobId, Player) else warn("[SC Lib] Could not rejoin: Missing place/job/user ID.") library:Notify("Error: Could not get server details to rejoin.", 5, "error") end end function library:Copy(input) -- Prefer setclipboard if available (more universal than syn) if typeof(setclipboard) == "function" then setclipboard(input) library:Notify("Copied to clipboard!", 3, "success") elseif syn and syn.write_clipboard then -- Fallback for Synapse syn.write_clipboard(input) library:Notify("Copied to clipboard! (Synapse)", 3, "success") else warn("[SC Lib] Clipboard functionality not available in this environment.") library:Notify("Error: Clipboard not supported.", 5, "error") end end -- Date/Time functions remain largely the same, but grouped for clarity do function library:GetDay(type) if type == "word" then return os.date("%A") end if type == "short" then return os.date("%a") end if type == "month" then return os.date("%d") end if type == "year" then return os.date("%j") end return os.date("%A") -- Default end function library:GetTime(type) if type == "24h" then return os.date("%H") end if type == "12h" then return os.date("%I") end if type == "minute" then return os.date("%M") end if type == "half" then return os.date("%p") end if type == "second" then return os.date("%S") end if type == "full" then return os.date("%X") end if type == "ISO" then return os.date("%z") end if type == "zone" then return os.date("%Z") end return os.date("%X") -- Default end function library:GetMonth(type) if type == "word" then return os.date("%B") end if type == "short" then return os.date("%b") end if type == "digit" then return os.date("%m") end return os.date("%B") -- Default end function library:GetWeek(type) if type == "year_S" then return os.date("%U") end if type == "day" then return os.date("%w") end if type == "year_M" then return os.date("%W") end return os.date("%U") -- Default end function library:GetYear(type) if type == "digits" then return os.date("%y") end if type == "full" then return os.date("%Y") end return os.date("%Y") -- Default end end function library:UnlockFps(newFpsCap) newFpsCap = tonumber(newFpsCap) or 999 -- Default to a high cap if invalid if typeof(setfpscap) == "function" then -- Check for common function name setfpscap(newFpsCap) DebugPrint("FPS cap set to", newFpsCap, "(using setfpscap)") library:Notify("FPS Unlocked/Set: " .. newFpsCap, 3, "information") return true elseif syn and syn.setfpscap then -- Synapse specific syn.setfpscap(newFpsCap) DebugPrint("FPS cap set to", newFpsCap, "(using syn.setfpscap)") library:Notify("FPS Unlocked/Set: " .. newFpsCap, 3, "information") return true else warn("[SC Lib] Cannot unlock FPS: Function not found in this environment.") library:Notify("Error: FPS unlock not supported.", 5, "error") return false end end -- / Key System Implementation function library:RequestKey() return coroutine.create(function() -- Use coroutine to avoid yielding the main thread unnecessarily DebugPrint("Key system initiated.") -- Cleanup previous key prompts for _, v in pairs(CoreGuiService:GetChildren()) do if v.Name == "SC_KeyPrompt" then v:Destroy() end end local keyPromptGui = Instance.new("ScreenGui") keyPromptGui.Name = "SC_KeyPrompt" keyPromptGui.Parent = CoreGuiService keyPromptGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling keyPromptGui.DisplayOrder = 9999 -- Ensure it's on top local backgroundBlur = Instance.new("BlurEffect") backgroundBlur.Size = 16 backgroundBlur.Parent = game:GetService("Lighting") -- Apply blur local mainFrame = Instance.new("Frame") mainFrame.Name = "MainFrame" mainFrame.Parent = keyPromptGui mainFrame.AnchorPoint = Vector2.new(0.5, 0.5) mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0) mainFrame.Size = UDim2.new(0, 350, 0, 200) mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30) mainFrame.BorderColor3 = Color3.fromRGB(80, 80, 80) mainFrame.BorderSizePixel = 1 mainFrame.Visible = false -- Start invisible for fade-in local corner = Instance.new("UICorner") corner.CornerRadius = UDim.new(0, 6) corner.Parent = mainFrame local titleLabel = Instance.new("TextLabel") titleLabel.Name = "Title" titleLabel.Parent = mainFrame titleLabel.Size = UDim2.new(1, 0, 0, 40) titleLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45) titleLabel.Font = Enum.Font.GothamSemibold titleLabel.Text = "SC Authentication" titleLabel.TextColor3 = Color3.fromRGB(180, 180, 180) titleLabel.TextSize = 18 local titleCorner = Instance.new("UICorner") titleCorner.CornerRadius = UDim.new(0, 6) titleCorner.Parent = titleLabel local statusLabel = Instance.new("TextLabel") statusLabel.Name = "Status" statusLabel.Parent = mainFrame statusLabel.Position = UDim2.new(0, 15, 0, 50) statusLabel.Size = UDim2.new(1, -30, 0, 20) statusLabel.BackgroundTransparency = 1 statusLabel.Font = Enum.Font.Gotham statusLabel.Text = "Please enter the key:" statusLabel.TextColor3 = Color3.fromRGB(160, 160, 160) statusLabel.TextSize = 14 statusLabel.TextXAlignment = Enum.TextXAlignment.Left local keyInput = Instance.new("TextBox") keyInput.Name = "KeyInput" keyInput.Parent = mainFrame keyInput.AnchorPoint = Vector2.new(0.5, 0) keyInput.Position = UDim2.new(0.5, 0, 0, 80) keyInput.Size = UDim2.new(0, 300, 0, 35) keyInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40) keyInput.BorderColor3 = Color3.fromRGB(60, 60, 60) keyInput.BorderSizePixel = 1 keyInput.Font = Enum.Font.Code keyInput.TextColor3 = Color3.fromRGB(200, 200, 200) keyInput.PlaceholderText = "Enter key..." keyInput.PlaceholderColor3 = Color3.fromRGB(100, 100, 100) keyInput.TextSize = 16 keyInput.ClearTextOnFocus = false keyInput.Text = "" local inputCorner = Instance.new("UICorner") inputCorner.CornerRadius = UDim.new(0, 4) inputCorner.Parent = keyInput local submitButton = Instance.new("TextButton") submitButton.Name = "SubmitButton" submitButton.Parent = mainFrame submitButton.AnchorPoint = Vector2.new(0.5, 0) submitButton.Position = UDim2.new(0.5, 0, 0, 135) submitButton.Size = UDim2.new(0, 150, 0, 40) submitButton.BackgroundColor3 = Color3.fromRGB(100, 60, 180) -- SC Purple Accent submitButton.Font = Enum.Font.GothamSemibold submitButton.Text = "Authenticate" submitButton.TextColor3 = Color3.fromRGB(230, 230, 230) submitButton.TextSize = 16 local buttonCorner = Instance.new("UICorner") buttonCorner.CornerRadius = UDim.new(0, 4) buttonCorner.Parent = submitButton -- Fade in the prompt mainFrame.Visible = true mainFrame.BackgroundTransparency = 1 mainFrame.Size = UDim2.new(0, 350, 0, 0) -- Start small for scale effect local sizeTween = TweenService:Create(mainFrame, TweenTable["scale_pop"], { Size = UDim2.new(0, 350, 0, 200) }) local fadeTween = TweenService:Create(mainFrame, TweenTable["key_prompt_fade"], { BackgroundTransparency = 0 }) sizeTween:Play() fadeTween:Play() -- Tween children transparency as well for _, child in pairs(mainFrame:GetChildren()) do if child:IsA("GuiObject") and child.Name ~= "MainFrame" then child.BackgroundTransparency = 1 if child:IsA("TextLabel") or child:IsA("TextButton") or child:IsA("TextBox") then child.TextTransparency = 1 if child:IsA("TextBox") then child.PlaceholderTransparency = 1 end end TweenService:Create(child, TweenTable["key_prompt_fade"] * 1.5, {BackgroundTransparency = child.BackgroundTransparency < 1 and 0 or 1, TextTransparency = 0, PlaceholderTransparency = 0 }):Play() end end local connection = nil connection = submitButton.MouseButton1Click:Connect(function() DebugPrint("Submit button clicked.") local enteredKey = keyInput.Text if enteredKey == Config.Key then DebugPrint("Key accepted.") isAuthenticated = true statusLabel.Text = "Success! Initializing..." statusLabel.TextColor3 = Color3.fromRGB(80, 200, 80) keyInput.Editable = false submitButton.Text = "Success!" submitButton.BackgroundColor3 = Color3.fromRGB(60, 160, 60) submitButton.AutoButtonColor = false -- Send initial webhook local webhookPayload = { title = "SC Lib Session Started", description = string.format( "User `%s` (ID: %d) authenticated and started using the script.", library:GetUsername(), library:GetUserId() ), color = 3066993, -- Green fields = { { name = "Place ID", value = tostring(library:GetPlaceId()), inline = true }, { name = "Job ID", value = tostring(library:GetJobId()), inline = true }, { name = "Session ID", value = sessionId, inline = false } }, timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"), footer = { text = "SC Lib v" .. library.version } } SendToWebhook(webhookPayload) -- Cleanup and proceed local fadeOutTween = TweenService:Create(mainFrame, TweenTable["key_prompt_fade"], { BackgroundTransparency = 1 }) for _, child in pairs(mainFrame:GetChildren()) do if child:IsA("GuiObject") and child.Name ~= "MainFrame" then TweenService:Create(child, TweenTable["key_prompt_fade"], {BackgroundTransparency = 1, TextTransparency = 1, PlaceholderTransparency = 1 }):Play() end end fadeOutTween:Play() fadeOutTween.Completed:Wait() if connection then connection:Disconnect() end if backgroundBlur then backgroundBlur:Destroy() end keyPromptGui:Destroy() DebugPrint("Key prompt destroyed.") -- Start the introduction and timer *after* successful auth library:Introduction() -- Show the new intro library:StartUsageTimer() -- Start tracking time else DebugPrint("Incorrect key entered.") statusLabel.Text = "Incorrect key. Please try again." statusLabel.TextColor3 = Color3.fromRGB(220, 70, 70) keyInput.Text = "" -- Clear input -- Add a visual shake or color flash for feedback local originalPos = mainFrame.Position local shakeTweenInfo = TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 4, true) TweenService:Create(mainFrame, shakeTweenInfo, {Position = originalPos + UDim2.new(0, 5, 0, 0)}):Play() task.wait(0.4) -- Wait for shake to finish mainFrame.Position = originalPos -- Reset position just in case end end) -- Allow Enter key to submit keyInput.FocusLost:Connect(function(enterPressed) if enterPressed and submitButton.Enabled then submitButton.MouseButton1Click:Fire() end end) end) end -- / Enhanced Introduction Sequence function library:Introduction() DebugPrint("Starting introduction sequence.") for _,v in next, CoreGuiService:GetChildren() do -- Use a more specific name to avoid conflicts if v.Name == "SC_IntroductionScreen" then v:Destroy() DebugPrint("Destroyed previous introduction screen.") end end -- Create a dedicated tween info table for the intro local introTweenFast = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out) local introTweenMedium = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut) local introTweenSlow = TweenInfo.new(0.8, Enum.EasingStyle.Quint, Enum.EasingDirection.Out) local introFadeOut = TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In) local introduction = Instance.new("ScreenGui") introduction.Name = "SC_IntroductionScreen" introduction.Parent = CoreGuiService introduction.ZIndexBehavior = Enum.ZIndexBehavior.Sibling introduction.DisplayOrder = 9998 -- Below key prompt if it were still visible -- Full screen semi-transparent overlay local overlay = Instance.new("Frame") overlay.Name = "Overlay" overlay.Parent = introduction overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0) overlay.BackgroundTransparency = 1 -- Start transparent overlay.Size = UDim2.new(1, 0, 1, 0) -- Main container centered local container = Instance.new("Frame") container.Name = "Container" container.Parent = overlay -- Parent to overlay for easier fading container.AnchorPoint = Vector2.new(0.5, 0.5) container.Position = UDim2.new(0.5, 0, 0.5, 0) container.Size = UDim2.new(0, 450, 0, 250) -- Adjusted size container.BackgroundColor3 = Color3.fromRGB(25, 25, 25) container.BorderSizePixel = 0 container.ClipsDescendants = true container.BackgroundTransparency = 1 -- Start transparent container.Visible = false -- Start hidden local corner = Instance.new("UICorner") corner.CornerRadius = UDim.new(0, 8) corner.Parent = container -- Animated Gradient Background (subtle) local gradient = Instance.new("UIGradient") gradient.Name = "AnimatedGradient" gradient.Parent = container gradient.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 30, 50)), ColorSequenceKeypoint.new(0.5, Color3.fromRGB(30, 30, 40)), ColorSequenceKeypoint.new(1, Color3.fromRGB(40, 30, 50)) }) gradient.Rotation = 0 gradient.Transparency = NumberSequence.new(0.5) -- Make it slightly transparent -- SC Logo (Example - Replace with actual asset ID if available, or use text) local logoLabel = Instance.new("TextLabel") -- Using TextLabel as placeholder logoLabel.Name = "SCLogo" logoLabel.Parent = container logoLabel.AnchorPoint = Vector2.new(0.5, 0.5) logoLabel.Position = UDim2.new(0.5, 0, 0.4, 0) -- Positioned slightly above center logoLabel.Size = UDim2.new(0, 200, 0, 80) logoLabel.BackgroundTransparency = 1 logoLabel.Font = Enum.Font.GothamBlack -- Bold font logoLabel.Text = "SC" logoLabel.TextColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple logoLabel.TextSize = 96 logoLabel.TextTransparency = 1 -- Start transparent -- Welcome Text local welcomeText = Instance.new("TextLabel") welcomeText.Name = "WelcomeText" welcomeText.Parent = container welcomeText.AnchorPoint = Vector2.new(0.5, 0.5) welcomeText.Position = UDim2.new(0.5, 0, 0.75, 0) -- Positioned below logo welcomeText.Size = UDim2.new(1, -40, 0, 30) welcomeText.BackgroundTransparency = 1 welcomeText.Font = Enum.Font.GothamSemibold welcomeText.Text = "Welcome, " .. library:GetUsername() .. "!" welcomeText.TextColor3 = Color3.fromRGB(200, 200, 200) welcomeText.TextSize = 18 welcomeText.TextTransparency = 1 -- Start transparent -- Progress Bar (more engaging than just the top bar) local progressBarEdge = Instance.new("Frame") progressBarEdge.Name = "ProgressBarEdge" progressBarEdge.Parent = container progressBarEdge.AnchorPoint = Vector2.new(0.5, 1) progressBarEdge.Position = UDim2.new(0.5, 0, 1, -10) -- Bottom edge progressBarEdge.Size = UDim2.new(0.8, 0, 0, 6) progressBarEdge.BackgroundColor3 = Color3.fromRGB(60, 60, 60) progressBarEdge.BorderSizePixel = 0 progressBarEdge.BackgroundTransparency = 1 local progressCornerEdge = Instance.new("UICorner") progressCornerEdge.CornerRadius = UDim.new(0, 3) progressCornerEdge.Parent = progressBarEdge local progressBarFill = Instance.new("Frame") progressBarFill.Name = "ProgressBarFill" progressBarFill.Parent = progressBarEdge progressBarFill.Size = UDim2.new(0, 0, 1, 0) -- Starts at 0 width progressBarFill.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple progressBarFill.BorderSizePixel = 0 progressBarFill.BackgroundTransparency = 1 local progressCornerFill = Instance.new("UICorner") progressCornerFill.CornerRadius = UDim.new(0, 3) progressCornerFill.Parent = progressBarFill -- Animation Sequence coroutine.wrap(function() -- 0. Fade in overlay TweenService:Create(overlay, introTweenMedium, { BackgroundTransparency = 0.4 }):Play() task.wait(0.2) -- 1. Scale/Fade in Container container.Visible = true local containerScale = TweenService:Create(container, introTweenSlow, { Size = UDim2.new(0, 450, 0, 250) }) -- Optional scale effect local containerFade = TweenService:Create(container, introTweenMedium, { BackgroundTransparency = 0 }) -- containerScale:Play() -- Uncomment for scale effect containerFade:Play() task.wait(0.3) -- Wait slightly for container to appear -- 2. Animate Gradient (subtle rotation) gradient:GetPropertyChangedSignal("Rotation"):Connect(function() end) -- Pre-load? Seems unnecessary. TweenService:Create(gradient, TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1, true), {Rotation = 360}):Play() -- 3. Pop in Logo logoLabel.Position = UDim2.new(0.5, 0, 0.35, 0) -- Start slightly higher local logoFade = TweenService:Create(logoLabel, introTweenFast, { TextTransparency = 0 }) local logoMove = TweenService:Create(logoLabel, introTweenMedium, { Position = UDim2.new(0.5, 0, 0.4, 0) }) logoFade:Play() logoMove:Play() task.wait(0.4) -- 4. Fade in Welcome Text local welcomeFade = TweenService:Create(welcomeText, introTweenMedium, { TextTransparency = 0 }) welcomeFade:Play() task.wait(0.2) -- 5. Animate Progress Bar TweenService:Create(progressBarEdge, introTweenFast, { BackgroundTransparency = 0.5 }):Play() TweenService:Create(progressBarFill, introTweenFast, { BackgroundTransparency = 0 }):Play() local progressFillTween = TweenService:Create(progressBarFill, TweenInfo.new(1.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Size = UDim2.new(1, 0, 1, 0) }) progressFillTween:Play() progressFillTween.Completed:Wait() task.wait(0.5) -- Hold message for a moment -- 6. Fade Out Everything local fadeOutOverlay = TweenService:Create(overlay, introFadeOut, { BackgroundTransparency = 1 }) local fadeOutContainer = TweenService:Create(container, introFadeOut * 0.8, { BackgroundTransparency = 1 }) -- Fade container slightly faster fadeOutOverlay:Play() fadeOutContainer:Play() fadeOutOverlay.Completed:Wait() gradient:Destroy() -- Stop gradient animation introduction:Destroy() DebugPrint("Introduction sequence finished.") -- Now initialize the main UI library:InitializeMainGui() end)() end -- / Usage Time Tracking function library:StartUsageTimer() if not isAuthenticated then warn("[SC Lib] Cannot start timer: Not authenticated.") return end if sessionTimeUpdateCoroutine then DebugPrint("Timer already running.") return end sessionStartTime = os.clock() lastWebhookUpdateTime = sessionStartTime -- Initialize last update time DebugPrint("Usage timer started at", sessionStartTime) -- Create the background update coroutine sessionTimeUpdateCoroutine = coroutine.create(function() while isAuthenticated and task.wait(1) do -- Update every second local currentTime = os.clock() local elapsedSessionTime = currentTime - sessionStartTime local formattedTime = library:FormatTime(elapsedSessionTime) -- Update GUI label (assuming it exists and is named 'SessionTimeLabel') local screen = CoreGuiService:FindFirstChild("SC_Screen") -- Renamed GUI if screen then local timeLabel = screen:FindFirstChild("SessionTimeLabel", true) -- Search recursively if timeLabel and timeLabel:IsA("TextLabel") then timeLabel.Text = "Session: " .. formattedTime end -- Also update watermark if it exists local watermark = CoreGuiService:FindFirstChild("SC_Watermark") if watermark then local timeWm = watermark:FindFirstChild("TimeWatermark", true) if timeWm then timeWm:Text(formattedTime) end -- Assuming Text() method exists end end -- Send periodic updates to webhook if currentTime - lastWebhookUpdateTime >= webhookUpdateInterval then lastWebhookUpdateTime = currentTime local webhookPayload = { description = string.format( "User `%s` session update. Current elapsed time: %s", library:GetUsername(), formattedTime ), color = 5759190, -- Blue-ish fields = { { name = "Session ID", value = sessionId, inline = false } }, timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"), footer = { text = "SC Lib v" .. library.version .. " - Periodic Update" } } SendToWebhook(webhookPayload) DebugPrint("Sent periodic time update to webhook.") end end DebugPrint("Session time update loop stopped.") sessionTimeUpdateCoroutine = nil -- Clear the coroutine variable when done end) coroutine.resume(sessionTimeUpdateCoroutine) end function library:StopUsageTimer() if not sessionStartTime or sessionStartTime == 0 then DebugPrint("Timer not running or already stopped.") return end local endTime = os.clock() local elapsedSessionTime = endTime - sessionStartTime local formattedTime = library:FormatTime(elapsedSessionTime) DebugPrint("Usage timer stopped. Elapsed time:", formattedTime) -- Send final webhook local webhookPayload = { title = "SC Lib Session Ended", description = string.format( "User `%s` (ID: %d) session ended.", library:GetUsername(), library:GetUserId() ), color = 15158332, -- Red fields = { { name = "Place ID", value = tostring(library:GetPlaceId()), inline = true }, { name = "Job ID", value = tostring(library:GetJobId()), inline = true }, { name = "Session Duration", value = formattedTime, inline = false }, { name = "Session ID", value = sessionId, inline = false } }, timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"), footer = { text = "SC Lib v" .. library.version } } SendToWebhook(webhookPayload) isAuthenticated = false -- Stop the update coroutine sessionStartTime = 0 -- No need to manually stop the coroutine, it checks 'isAuthenticated' end function library:FormatTime(totalSeconds) totalSeconds = math.floor(totalSeconds + 0.5) local seconds = totalSeconds % 60 local minutes = math.floor(totalSeconds / 60) % 60 local hours = math.floor(totalSeconds / 3600) return string.format("%02d:%02d:%02d", hours, minutes, seconds) end -- Connect PlayerRemoving to stop the timer Players.PlayerRemoving:Connect(function(player) if player == Player then DebugPrint("Local player removing, stopping timer.") library:StopUsageTimer() end end) -- / Watermark (Renamed and updated) function library:Watermark(text) -- Cleanup previous for i,v in pairs(CoreGuiService:GetChildren()) do if v.Name == "SC_Watermark" then v:Destroy() DebugPrint("Destroyed previous watermark.") end end local defaultText = "SC Lib v" .. library.version .. " | By " .. library.creator text = text or defaultText local watermark = Instance.new("ScreenGui") local watermarkPadding = Instance.new("UIPadding") local watermarkLayout = Instance.new("UIListLayout") -- [...] Instance creation like original, but with SC names watermark.Name = "SC_Watermark" -- Renamed watermark.Parent = CoreGuiService watermark.ZIndexBehavior = Enum.ZIndexBehavior.Sibling watermark.DisplayOrder = 1000 -- High priority but below intro/key watermarkLayout.Name = "watermarkLayout" watermarkLayout.Parent = watermark watermarkLayout.FillDirection = Enum.FillDirection.Horizontal watermarkLayout.SortOrder = Enum.SortOrder.LayoutOrder watermarkLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom watermarkLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left -- Default to left watermarkLayout.Padding = UDim.new(0, 5) -- Spacing between elements watermarkPadding.Name = "watermarkPadding" watermarkPadding.Parent = watermark watermarkPadding.PaddingBottom = UDim.new(0, 8) -- Slightly more padding watermarkPadding.PaddingLeft = UDim.new(0, 8) watermarkPadding.PaddingRight = UDim.new(0, 8) watermarkPadding.PaddingTop = UDim.new(0, 8) local function CreateWatermarkElement(elementText) local edge = Instance.new("Frame") local edgeCorner = Instance.new("UICorner") local background = Instance.new("Frame") local barFolder = Instance.new("Folder") local bar = Instance.new("Frame") local barCorner = Instance.new("UICorner") local barLayout = Instance.new("UIListLayout") local backgroundGradient = Instance.new("UIGradient") local backgroundCorner = Instance.new("UICorner") local waterText = Instance.new("TextLabel") local waterPadding = Instance.new("UIPadding") local backgroundLayout = Instance.new("UIListLayout") edge.Name = "edge" edge.Parent = watermark edge.AnchorPoint = Vector2.new(0.5, 0.5) edge.BackgroundColor3 = Color3.fromRGB(60, 60, 60) edge.Position = UDim2.new(0.5, 0, -0.03, 0) edge.Size = UDim2.new(0, 0, 0, 26) edge.BackgroundTransparency = 1 edgeCorner.CornerRadius = UDim.new(0, 3) -- Slightly rounder edgeCorner.Name = "edgeCorner" edgeCorner.Parent = edge background.Name = "background" background.Parent = edge background.AnchorPoint = Vector2.new(0.5, 0.5) background.BackgroundColor3 = Color3.fromRGB(255, 255, 255) background.BackgroundTransparency = 1 background.ClipsDescendants = true background.Position = UDim2.new(0.5, 0, 0.5, 0) background.Size = UDim2.new(0, 0, 0, 24) barFolder.Name = "barFolder" barFolder.Parent = background bar.Name = "bar" bar.Parent = barFolder bar.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple bar.BackgroundTransparency = 0 -- Solid bar looks better here bar.Size = UDim2.new(0, 0, 0, 2) -- Thicker bar bar.Position = UDim2.new(0,0,0,1) -- Position at bottom using AnchorPoint trick might be better barCorner.CornerRadius = UDim.new(0, 3) barCorner.Name = "barCorner" barCorner.Parent = bar barLayout.Name = "barLayout" -- Unused if bar positioned manually barLayout.Parent = barFolder barLayout.SortOrder = Enum.SortOrder.LayoutOrder backgroundGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(38, 38, 38)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(30, 30, 30))} -- Darker gradient backgroundGradient.Rotation = 90 backgroundGradient.Name = "backgroundGradient" backgroundGradient.Parent = background backgroundCorner.CornerRadius = UDim.new(0, 3) backgroundCorner.Name = "backgroundCorner" backgroundCorner.Parent = background waterText.Name = "watermarkText" -- Renamed waterText.Parent = background waterText.BackgroundColor3 = Color3.fromRGB(255, 255, 255) waterText.BackgroundTransparency = 1.000 waterText.Position = UDim2.new(0, 0, -0.0416666679, 0) waterText.Size = UDim2.new(0, 0, 0, 24) waterText.Font = Enum.Font.GothamSemibold -- Nicer font waterText.Text = elementText waterText.TextColor3 = Color3.fromRGB(210, 210, 210) -- Brighter text waterText.TextTransparency = 1 waterText.TextSize = 13.000 -- Slightly smaller waterText.RichText = true local NewSize = TextService:GetTextSize(waterText.Text, waterText.TextSize, waterText.Font, Vector2.new(math.huge, math.huge)) waterText.Size = UDim2.new(0, NewSize.X + 12, 0, 24) -- More padding waterPadding.Name = "waterPadding" waterPadding.Parent = waterText waterPadding.PaddingBottom = UDim.new(0, 0) waterPadding.PaddingLeft = UDim.new(0, 6) waterPadding.PaddingRight = UDim.new(0, 6) waterPadding.PaddingTop = UDim.new(0, 0) backgroundLayout.Name = "backgroundLayout" backgroundLayout.Parent = background backgroundLayout.SortOrder = Enum.SortOrder.LayoutOrder backgroundLayout.VerticalAlignment = Enum.VerticalAlignment.Center -- Animate appearance CreateTween("wm_appear", 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out) CreateTween("wm_bar_appear", 0.35, Enum.EasingStyle.Quint, Enum.EasingDirection.Out) coroutine.wrap(function() local targetWidth = NewSize.X + 12 TweenService:Create(edge, TweenTable["wm_appear"], { BackgroundTransparency = 0, Size = UDim2.new(0, targetWidth + 2, 0, 26)}):Play() TweenService:Create(background, TweenTable["wm_appear"], { BackgroundTransparency = 0, Size = UDim2.new(0, targetWidth, 0, 24) }):Play() task.wait(0.1) TweenService:Create(bar, TweenTable["wm_bar_appear"], { Size = UDim2.new(0, targetWidth, 0, 2) }):Play() task.wait(0.15) TweenService:Create(waterText, TweenTable["wm_appear"], { TextTransparency = 0 }):Play() end)() local ElementFunctions = {} function ElementFunctions:Hide() -- Animate hiding TweenService:Create(edge, TweenTable["wm_appear"], {BackgroundTransparency = 1, Size = UDim2.new(0, 0, 0, 26)}):Play() TweenService:Create(background, TweenTable["wm_appear"], {BackgroundTransparency = 1, Size = UDim2.new(0, 0, 0, 24)}):Play() TweenService:Create(bar, TweenTable["wm_appear"] * 0.5, {Size = UDim2.new(0, 0, 0, 2)}):Play() TweenService:Create(waterText, TweenTable["wm_appear"] * 0.5, {TextTransparency = 1}):Play() task.wait(0.25) edge.Visible = false -- Fully hide after animation return ElementFunctions end function ElementFunctions:Show() edge.Visible = true local targetWidth = TextService:GetTextSize(waterText.Text, waterText.TextSize, waterText.Font, Vector2.new(math.huge, math.huge)).X + 12 TweenService:Create(edge, TweenTable["wm_appear"], { BackgroundTransparency = 0, Size = UDim2.new(0, targetWidth + 2, 0, 26)}):Play() TweenService:Create(background, TweenTable["wm_appear"], { BackgroundTransparency = 0, Size = UDim2.new(0, targetWidth, 0, 24) }):Play() task.wait(0.1) TweenService:Create(bar, TweenTable["wm_bar_appear"], { Size = UDim2.new(0, targetWidth, 0, 2) }):Play() task.wait(0.15) TweenService:Create(waterText, TweenTable["wm_appear"], { TextTransparency = 0 }):Play() return ElementFunctions end function ElementFunctions:Text(newText) newText = newText or elementText waterText.Text = newText local NewSize = TextService:GetTextSize(waterText.Text, waterText.TextSize, waterText.Font, Vector2.new(math.huge, math.huge)) local targetWidth = NewSize.X + 12 local resizeTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut) -- Faster resize tween TweenService:Create(edge, resizeTweenInfo, { Size = UDim2.new(0, targetWidth + 2, 0, 26) }):Play() TweenService:Create(background, resizeTweenInfo, { Size = UDim2.new(0, targetWidth, 0, 24) }):Play() TweenService:Create(bar, resizeTweenInfo, { Size = UDim2.new(0, targetWidth, 0, 2) }):Play() TweenService:Create(waterText, resizeTweenInfo, { Size = UDim2.new(0, targetWidth, 0, 24)}):Play() -- Resize text label too return ElementFunctions end function ElementFunctions:Remove() ElementFunctions:Hide() -- Animate out task.wait(0.3) -- Wait for hide animation edge:Destroy() -- Note: Returning ElementFunctions after destruction might cause errors if used further. return nil -- Indicate removal end return ElementFunctions end -- Create initial elements local mainWm = CreateWatermarkElement(text) local fpsWm = CreateWatermarkElement("FPS: " .. library.fps) local timeWm = CreateWatermarkElement("Session: 00:00:00") timeWm.InstanceName = "TimeWatermark" -- For easy finding by timer -- Update FPS element periodically local fpsUpdateConnection = nil fpsUpdateConnection = RunService.RenderStepped:Connect(function() -- Update less frequently to avoid spamming Text() calls if math.random(1, 15) == 1 then -- Update roughly 4 times per second if fpsWm and fpsWm.Text then -- Check if not removed fpsWm:Text("FPS: " .. library.fps) else if fpsUpdateConnection then fpsUpdateConnection:Disconnect() end -- Stop updating if removed end end end) -- Main Watermark Functions wrapper local WatermarkFunctions = {} local elements = {main = mainWm, fps = fpsWm, time = timeWm} -- Keep track of elements function WatermarkFunctions:AddWatermark(elementText, name) name = name or "custom_" .. math.random(1000,9999) if elements[name] then warn("[SC Lib] Watermark element with name", name, "already exists.") return elements[name] -- Return existing element end local newElement = CreateWatermarkElement(elementText) if newElement then elements[name] = newElement newElement.InstanceName = name -- Store name if needed return newElement end return nil end function WatermarkFunctions:Hide() for _, element in pairs(elements) do if element and element.Hide then element:Hide() end end return WatermarkFunctions end function WatermarkFunctions:Show() for _, element in pairs(elements) do if element and element.Show then element:Show() end end return WatermarkFunctions end function WatermarkFunctions:Text(newText) -- This modifies the *first* element added (the main one) if elements.main and elements.main.Text then elements.main:Text(newText) end return WatermarkFunctions end function WatermarkFunctions:Remove() for name, element in pairs(elements) do if element and element.Remove then element:Remove() end end if fpsUpdateConnection then fpsUpdateConnection:Disconnect() end elements = {} -- Clear tracked elements watermark:Destroy() -- Destroy the container ScreenGui return nil -- Indicate removal end function WatermarkFunctions:GetElement(name) return elements[name] end return WatermarkFunctions end -- / Notifications System (Using StarterGui for potential wider compatibility) -- NOTE: This uses StarterGui:SetCore("SendNotification"), which has limitations (text only, standard look). -- If a custom look is strictly required, the original frame-based system is needed. -- Let's keep the original custom notification system as it offers more control and style. function library:InitNotifications() -- Cleanup previous custom notifications for i,v in next, CoreGuiService:GetChildren() do if v.Name == "SC_NotificationsContainer" then v:Destroy() DebugPrint("Destroyed previous notification container.") end end local Notifications = Instance.new("ScreenGui") local notificationsLayout = Instance.new("UIListLayout") local notificationsPadding = Instance.new("UIPadding") Notifications.Name = "SC_NotificationsContainer" -- Renamed Notifications.Parent = CoreGuiService Notifications.ZIndexBehavior = Enum.ZIndexBehavior.Sibling Notifications.DisplayOrder = 9990 -- High, but below watermark/intro notificationsLayout.Name = "notificationsLayout" notificationsLayout.Parent = Notifications notificationsLayout.SortOrder = Enum.SortOrder.LayoutOrder notificationsLayout.Padding = UDim.new(0, 6) -- Increased spacing notificationsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left notificationsLayout.VerticalAlignment = Enum.VerticalAlignment.Top -- Top-left corner notificationsPadding.Name = "notificationsPadding" notificationsPadding.Parent = Notifications notificationsPadding.PaddingLeft = UDim.new(0, 10) notificationsPadding.PaddingTop = UDim.new(0, 10) -- From top-left local activeNotifications = {} -- Track active notifications to prevent overlap/spam local Notification = {} function Notification:Notify(text, duration, type, callback) text = text or "Please wait..." duration = duration or 5 type = type or "notification" -- notification, alert, error, success, information callback = callback or function() end -- Limit concurrent notifications of the same text to avoid spam if activeNotifications[text] then DebugPrint("Skipping duplicate notification:", text) return -- Don't show if same text is already visible end activeNotifications[text] = true CreateTween("notification_slide_in", 0.3, Enum.EasingStyle.Quint, Enum.EasingDirection.Out) CreateTween("notification_slide_out", 0.3, Enum.EasingStyle.Quint, Enum.EasingDirection.In) CreateTween("notification_fade", 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out) CreateTween("notification_progress", duration, Enum.EasingStyle.Linear) -- Linear progress local edge = Instance.new("Frame") local edgeCorner = Instance.new("UICorner") local background = Instance.new("Frame") local bar = Instance.new("Frame") -- Progress bar directly on background local backgroundGradient = Instance.new("UIGradient") local backgroundCorner = Instance.new("UICorner") local contentFrame = Instance.new("Frame") -- Frame for text and icon local contentLayout = Instance.new("UIListLayout") local iconLabel = Instance.new("ImageLabel") -- Added Icon local notifText = Instance.new("TextLabel") local notifPadding = Instance.new("UIPadding") edge.Name = "edge" edge.Parent = Notifications -- Parent to the container edge.BackgroundColor3 = Color3.fromRGB(70, 70, 70) -- Slightly darker edge edge.BackgroundTransparency = 1.000 edge.Position = UDim2.new(-1, 0, 0, 0) -- Start off-screen left edge.Size = UDim2.new(0, 0, 0, 40) -- Fixed height for consistency edge.ClipsDescendants = true -- Important for slide animation edgeCorner.CornerRadius = UDim.new(0, 4) edgeCorner.Name = "edgeCorner" edgeCorner.Parent = edge background.Name = "background" background.Parent = edge background.AnchorPoint = Vector2.new(0.5, 0.5) background.BackgroundColor3 = Color3.fromRGB(255, 255, 255) background.BackgroundTransparency = 1.000 -- Start transparent background.ClipsDescendants = true background.Position = UDim2.new(0.5, 0, 0.5, 0) background.Size = UDim2.new(1, -2, 1, -2) -- Inner frame size backgroundGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(45, 45, 45)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(35, 35, 35))} -- Darker bg backgroundGradient.Rotation = 90 backgroundGradient.Name = "backgroundGradient" backgroundGradient.Parent = background backgroundCorner.CornerRadius = UDim.new(0, 4) backgroundCorner.Name = "backgroundCorner" backgroundCorner.Parent = background -- Progress Bar (thin line at the bottom) bar.Name = "progressBar" bar.Parent = background -- Inside the main background bar.AnchorPoint = Vector2.new(0, 1) bar.Position = UDim2.new(0, 0, 1, 0) bar.Size = UDim2.new(1, 0, 0, 3) -- Full width, 3px height bar.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- Default color bar.BackgroundTransparency = 0.3-- Semi-transparent looks nice bar.BorderSizePixel = 0 bar.ZIndex = 3 -- Above gradient -- Set bar color based on type if type == "notification" then bar.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- Purple elseif type == "alert" then bar.BackgroundColor3 = Color3.fromRGB(255, 190, 0) -- Orange/Yellow elseif type == "error" then bar.BackgroundColor3 = Color3.fromRGB(230, 50, 50) -- Red elseif type == "success" then bar.BackgroundColor3 = Color3.fromRGB(50, 200, 80) -- Green elseif type == "information" then bar.BackgroundColor3 = Color3.fromRGB(50, 150, 230) -- Blue end local barCorner = Instance.new("UICorner") barCorner.CornerRadius = UDim.new(0, 2) barCorner.Parent = bar contentFrame.Name = "ContentFrame" contentFrame.Parent = background contentFrame.BackgroundTransparency = 1 contentFrame.Size = UDim2.new(1, 0, 1, -3) -- Leave space for progress bar contentFrame.Position = UDim2.new(0, 0, 0, 0) contentFrame.ZIndex = 2 -- Above gradient contentLayout.Name = "ContentLayout" contentLayout.Parent = contentFrame contentLayout.FillDirection = Enum.FillDirection.Horizontal contentLayout.VerticalAlignment = Enum.VerticalAlignment.Center contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left contentLayout.SortOrder = Enum.SortOrder.LayoutOrder contentLayout.Padding = UDim.new(0, 8) -- Icon (Example using Roblox assets - replace if needed) iconLabel.Name = "Icon" iconLabel.Parent = contentFrame iconLabel.BackgroundTransparency = 1 iconLabel.Size = UDim2.new(0, 20, 0, 20) -- Square icon iconLabel.ImageColor3 = bar.BackgroundColor3 -- Match icon color to type iconLabel.ScaleType = Enum.ScaleType.Fit -- Set Icon based on type (using common Roblox asset IDs) if type == "alert" then iconLabel.Image = "rbxassetid://159878193" -- Warning Symbol elseif type == "error" then iconLabel.Image = "rbxassetid://160092558" -- Stop Symbol elseif type == "success" then iconLabel.Image = "rbxassetid://159877577" -- Checkmark Symbol elseif type == "information" then iconLabel.Image = "rbxassetid://160092604" -- Info Symbol else iconLabel.Visible = false end -- Hide icon for default notification type notifText.Name = "notifText" notifText.Parent = contentFrame -- Parent to content frame notifText.BackgroundTransparency = 1.000 notifText.Size = UDim2.new(1, -50, 1, 0) -- Flexible width, full height notifText.Font = Enum.Font.Gotham -- Consistent font notifText.Text = text notifText.TextColor3 = Color3.fromRGB(220, 220, 220) notifText.TextSize = 14.000 notifText.TextTransparency = 1.000 -- Start transparent notifText.TextXAlignment = Enum.TextXAlignment.Left notifText.TextYAlignment = Enum.TextYAlignment.Center notifText.TextWrapped = true notifText.RichText = true notifPadding.Name = "notifPadding" notifPadding.Parent = contentFrame -- Padding for the whole content frame notifPadding.PaddingLeft = UDim.new(0, 10) notifPadding.PaddingRight = UDim.new(0, 10) -- Calculate width based on text size local textBounds = TextService:GetTextSize(notifText.Text, notifText.TextSize, notifText.Font, Vector2.new(300, math.huge)) -- Limit max width local iconWidth = iconLabel.Visible and iconLabel.Size.X.Offset + contentLayout.Padding.Offset or 0 local requiredWidth = textBounds.X + iconWidth + notifPadding.PaddingLeft.Offset + notifPadding.PaddingRight.Offset + 10 -- Add extra buffer requiredWidth = math.clamp(requiredWidth, 150, 350) -- Min/Max width edge.Size = UDim2.new(0, requiredWidth, 0, 40) -- Animation Coroutine coroutine.wrap(function() local isRunning = true -- 1. Slide In and Fade In local slideTween = TweenService:Create(edge, TweenTable["notification_slide_in"], { Position = UDim2.new(0, 0, 0, 0) }) local fadeBgTween = TweenService:Create(background, TweenTable["notification_fade"], {BackgroundTransparency = 0}) local fadeEdgeTween = TweenService:Create(edge, TweenTable["notification_fade"], {BackgroundTransparency = 0}) local fadeTextTween = TweenService:Create(notifText, TweenTable["notification_fade"], {TextTransparency = 0}) slideTween:Play() fadeEdgeTween:Play() fadeBgTween:Play() fadeTextTween:Play() slideTween.Completed:Wait() -- Wait for slide in to finish -- 2. Progress Bar Animation bar.Size = UDim2.new(1, 0, 0, 3) -- Start full width local progressTween = TweenService:Create(bar, TweenTable["notification_progress"], { Size = UDim2.new(0, 0, 0, 3) }) progressTween:Play() progressTween.Completed:Wait() -- Wait for progress to finish -- Condition to prevent fading out if manually removed if not isRunning then return end -- 3. Slide Out and Fade Out local slideOutTween = TweenService:Create(edge, TweenTable["notification_slide_out"], { Position = UDim2.new(-1, 0, 0, 0) }) local fadeOutBgTween = TweenService:Create(background, TweenTable["notification_fade"], {BackgroundTransparency = 1}) local fadeOutEdgeTween = TweenService:Create(edge, TweenTable["notification_fade"], {BackgroundTransparency = 1}) local fadeOutTextTween = TweenService:Create(notifText, TweenTable["notification_fade"], {TextTransparency = 1}) slideOutTween:Play() fadeOutBgTween:Play() fadeOutEdgeTween:Play() fadeOutTextTween:Play() slideOutTween.Completed:Wait() isRunning = false edge:Destroy() activeNotifications[text] = nil -- Remove from active list pcall(callback) -- Call callback after destruction end)() -- Return functions to control the specific notification instance (though less useful with auto-timeout) local NotificationFunctions = {} function NotificationFunctions:Remove() if isRunning then isRunning = false -- Stop the animation coroutine from proceeding to fade out -- Manually trigger fade out/destroy local slideOutTween = TweenService:Create(edge, TweenTable["notification_slide_out"] * 0.5, { Position = UDim2.new(-1, 0, 0, 0) }) -- Faster removal local fadeOutBgTween = TweenService:Create(background, TweenTable["notification_fade"] * 0.5, {BackgroundTransparency = 1}) local fadeOutEdgeTween = TweenService:Create(edge, TweenTable["notification_fade"] * 0.5, {BackgroundTransparency = 1}) local fadeOutTextTween = TweenService:Create(notifText, TweenTable["notification_fade"] * 0.5, {TextTransparency = 1}) slideOutTween:Play() fadeOutBgTween:Play() fadeOutEdgeTween:Play() fadeOutTextTween:Play() task.wait(0.2) -- Wait for quick fade edge:Destroy() activeNotifications[text] = nil end return nil end function NotificationFunctions:Text(new) -- Changing text while visible might mess up layout/timing significantly -- It's generally better to issue a new notification. warn("[SC Lib] Changing notification text while visible is not recommended.") return NotificationFunctions -- No-op for now end return NotificationFunctions end library.Notify = Notification.Notify -- Assign the function directly to the library table for easy access return Notification -- Return the table itself if needed elsewhere end -- / Main UI Initialization (Placeholder - To be called after Intro) function library:InitializeMainGui() DebugPrint("Initializing main GUI...") -- Call the original Init function, now potentially renamed or modified -- Assuming the main UI setup function is now called MainGui or similar -- Or just directly call the renamed :Init function if that's the convention. library:MainGui() -- Example call, replace with actual name (likely still library:Init) end -- / Main UI Build Function (Renamed from library:Init to avoid name clash if needed) -- Kept the name library:Init as requested, but ensure it's only called *after* auth/intro function library:Init(keybind) if not isAuthenticated then warn("[SC Lib] Cannot initialize GUI: Not authenticated.") library:RequestKey() -- Re-request key if attempted to init without auth return nil -- Stop initialization end if isGuiActive then warn("[SC Lib] GUI is already initialized.") -- Maybe toggle visibility instead? local screen = CoreGuiService:FindFirstChild("SC_Screen") if screen then screen.Enabled = not screen.Enabled end return nil end DebugPrint("Starting library:Init...") isGuiActive = true -- Mark GUI as active -- Cleanup previous GUIs for _,v in next, CoreGuiService:GetChildren() do if v.Name == "SC_Screen" then v:Destroy() DebugPrint("Destroyed previous SC_Screen.") end end local title = library.title keybind = keybind or Enum.KeyCode.RightAlt -- Default keybind -- Instance Creation - Use new names (SC_) local screen = Instance.new("ScreenGui") local edge = Instance.new("Frame") local edgeCorner = Instance.new("UICorner") local background = Instance.new("Frame") local backgroundCorner = Instance.new("UICorner") local backgroundGradient = Instance.new("UIGradient") local headerFrame = Instance.new("Frame") -- Separate frame for header local headerLayout = Instance.new("UIListLayout") local headerLabel = Instance.new("TextLabel") local sessionTimeLabel = Instance.new("TextLabel") -- Added session time label local barFolder = Instance.new("Folder") local bar = Instance.new("Frame") local barCorner = Instance.new("UICorner") local barLayout = Instance.new("UIListLayout") local mainContentFrame = Instance.new("Frame") -- Frame for tabs and container local mainContentLayout = Instance.new("UIListLayout") local tabButtonsEdge = Instance.new("Frame") local tabButtonCorner = Instance.new("UICorner") local tabButtons = Instance.new("Frame") -- Will be ScrollingFrame for many tabs local tabButtonCorner_2 = Instance.new("UICorner") local tabButtonsGradient = Instance.new("UIGradient") local tabButtonLayout = Instance.new("UIListLayout") local tabButtonPadding = Instance.new("UIPadding") local containerEdge = Instance.new("Frame") local tabButtonCorner_3 = Instance.new("UICorner") local container = Instance.new("Frame") -- Container for pages local containerCorner = Instance.new("UICorner") local containerGradient = Instance.new("UIGradient") screen.Name = "SC_Screen" -- Renamed screen.Parent = CoreGuiService screen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling screen.DisplayOrder = 1 -- Low display order, other elements like watermark/notifs go above edge.Name = "edge" edge.Parent = screen edge.AnchorPoint = Vector2.new(0.5, 0.5) edge.BackgroundColor3 = Color3.fromRGB(65, 65, 70) -- Slightly different edge color edge.Position = UDim2.new(0.5, 0, 0.5, 0) edge.Size = UDim2.new(0, 624, 0, 436) -- Slightly larger edge.BackgroundTransparency = 1 -- Start transparent for fade-in drag(edge, 0.04) local CanChangeVisibility = true local guiVisible = true -- Track visibility state -- Fade-in animation for the entire GUI edge.Visible = true local guiFadeInfo = TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.Out) TweenService:Create(edge, guiFadeInfo, { BackgroundTransparency = 0 }):Play() local function ToggleVisibility() if not CanChangeVisibility then return end guiVisible = not guiVisible CanChangeVisibility = false -- Prevent spam toggling local targetTransparency = guiVisible and 0 or 1 local fadeTween = TweenService:Create(edge, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), { BackgroundTransparency = targetTransparency }) fadeTween:Play() fadeTween.Completed:Connect(function() edge.Visible = guiVisible -- Ensure visibility state matches after fade CanChangeVisibility = true end) end UserInputService.InputBegan:Connect(function(input, gameProcessed) if not gameProcessed and input.KeyCode == keybind then ToggleVisibility() end end) edgeCorner.CornerRadius = UDim.new(0, 5) -- Consistent corner radius edgeCorner.Name = "edgeCorner" edgeCorner.Parent = edge background.Name = "background" background.Parent = edge background.AnchorPoint = Vector2.new(0.5, 0.5) background.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- Won't be visible due to gradient background.Position = UDim2.new(0.5, 0, 0.5, 0) background.Size = UDim2.new(1, -2, 1, -2) -- Fit inside edge background.ClipsDescendants = true backgroundCorner.CornerRadius = UDim.new(0, 5) backgroundCorner.Name = "backgroundCorner" backgroundCorner.Parent = background backgroundGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(38, 38, 42)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(30, 30, 34))} -- Darker theme backgroundGradient.Rotation = 90 backgroundGradient.Name = "backgroundGradient" backgroundGradient.Parent = background -- Header Frame Setup headerFrame.Name = "HeaderFrame" headerFrame.Parent = background headerFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255) headerFrame.BackgroundTransparency = 1.000 headerFrame.Size = UDim2.new(1, 0, 0, 38) headerFrame.Position = UDim2.new(0, 0, 0, 0) headerLayout.Name = "HeaderLayout" headerLayout.Parent = headerFrame headerLayout.FillDirection = Enum.FillDirection.Horizontal headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center headerLayout.SortOrder = Enum.SortOrder.LayoutOrder headerLayout.Padding = UDim.new(0, 12) headerLabel.Name = "headerLabel" headerLabel.Parent = headerFrame -- Parent to header frame headerLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255) headerLabel.BackgroundTransparency = 1.000 headerLabel.Size = UDim2.new(0.6, 0, 1, 0) -- Take up ~60% width initially headerLabel.Font = Enum.Font.GothamSemibold -- Use better font headerLabel.Text = title headerLabel.TextColor3 = Color3.fromRGB(210, 210, 210) -- Brighter text headerLabel.TextSize = 16.000 headerLabel.TextXAlignment = Enum.TextXAlignment.Left headerLabel.RichText = true -- Session Time Label in Header sessionTimeLabel.Name = "SessionTimeLabel" sessionTimeLabel.Parent = headerFrame -- Parent to header frame sessionTimeLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255) sessionTimeLabel.BackgroundTransparency = 1.000 sessionTimeLabel.Size = UDim2.new(0.4, -24, 1, 0) -- Take remaining width, minus padding sessionTimeLabel.Font = Enum.Font.Code -- Monospace for time sessionTimeLabel.Text = "Session: 00:00:00" -- Initial text sessionTimeLabel.TextColor3 = Color3.fromRGB(160, 160, 160) -- Dimmer color sessionTimeLabel.TextSize = 14.000 sessionTimeLabel.TextXAlignment = Enum.TextXAlignment.Right sessionTimeLabel.RichText = false barFolder.Name = "barFolder" barFolder.Parent = background barFolder.Position = UDim2.new(0,0,0,38) -- Position below header bar.Name = "bar" bar.Parent = barFolder bar.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple bar.BackgroundTransparency = 0 -- Solid bar bar.Size = UDim2.new(1, 0, 0, 2) -- Full width, 2px height bar.BorderSizePixel = 0 bar.Position = UDim2.new(0,0,0,0) -- At the top of its folder barCorner.CornerRadius = UDim.new(0, 2) barCorner.Name = "barCorner" barCorner.Parent = bar barLayout.Name = "barLayout" -- Probably not needed if positioned manually barLayout.Parent = barFolder barLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center barLayout.SortOrder = Enum.SortOrder.LayoutOrder -- Main Content Frame (Tabs + Pages) mainContentFrame.Name = "MainContent" mainContentFrame.Parent = background mainContentFrame.BackgroundTransparency = 1 mainContentFrame.Position = UDim2.new(0, 0, 0, 40) -- Below header and bar mainContentFrame.Size = UDim2.new(1, 0, 1, -40) -- Fill remaining space mainContentFrame.ClipsDescendants = true mainContentLayout.Name = "MainContentLayout" mainContentLayout.Parent = mainContentFrame mainContentLayout.FillDirection = Enum.FillDirection.Horizontal mainContentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left mainContentLayout.VerticalAlignment = Enum.VerticalAlignment.Top mainContentLayout.SortOrder = Enum.SortOrder.LayoutOrder mainContentLayout.Padding = UDim.new(0, 8) -- Padding between tabs and container -- Tab Buttons Area (Left Side) - Now a ScrollingFrame tabButtonsEdge.Name = "tabButtonsEdge" tabButtonsEdge.Parent = mainContentFrame tabButtonsEdge.BackgroundColor3 = Color3.fromRGB(55, 55, 60) -- Slightly different edge tabButtonsEdge.Size = UDim2.new(0, 162, 1, -16) -- Fixed width, fill height minus padding tabButtonsEdge.Position = UDim2.new(0, 8, 0, 8) -- Position with padding tabButtonCorner.CornerRadius = UDim.new(0, 4) tabButtonCorner.Name = "tabButtonCorner" tabButtonCorner.Parent = tabButtonsEdge -- Make tabButtons a ScrollingFrame tabButtons = Instance.new("ScrollingFrame") tabButtons.Name = "tabButtons" tabButtons.Parent = tabButtonsEdge tabButtons.AnchorPoint = Vector2.new(0.5, 0.5) tabButtons.BackgroundColor3 = Color3.fromRGB(235, 235, 235) -- Hidden by gradient tabButtons.ClipsDescendants = true tabButtons.Position = UDim2.new(0.5, 0, 0.5, 0) tabButtons.Size = UDim2.new(1, -2, 1, -2) -- Fit inside edge tabButtons.BorderSizePixel = 0 tabButtons.ScrollBarThickness = 4 -- Thinner scrollbar tabButtons.ScrollBarImageColor3 = Color3.fromRGB(120, 80, 180) -- Darker purple scrollbar tabButtons.CanvasSize = UDim2.new(0, 0, 0, 0) -- Calculated automatically by layout tabButtons.AutomaticCanvasSize = Enum.AutomaticSize.Y -- Auto-adjust height tabButtonCorner_2.CornerRadius = UDim.new(0, 4) tabButtonCorner_2.Name = "tabButtonCorner" tabButtonCorner_2.Parent = tabButtons tabButtonsGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(42, 42, 46)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(34, 34, 38))} -- Darker tabs bg tabButtonsGradient.Rotation = 90 tabButtonsGradient.Name = "tabButtonsGradient" tabButtonsGradient.Parent = tabButtons tabButtonLayout.Name = "tabButtonLayout" tabButtonLayout.Parent = tabButtons -- Parent to ScrollingFrame's Canvas tabButtonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center tabButtonLayout.SortOrder = Enum.SortOrder.LayoutOrder tabButtonLayout.Padding = UDim.new(0, 4) -- Spacing between tab buttons tabButtonPadding.Name = "tabButtonPadding" tabButtonPadding.Parent = tabButtons tabButtonPadding.PaddingBottom = UDim.new(0, 4) tabButtonPadding.PaddingLeft = UDim.new(0, 4) tabButtonPadding.PaddingRight = UDim.new(0, 4) tabButtonPadding.PaddingTop = UDim.new(0, 4) -- Content Container Area (Right Side) containerEdge.Name = "containerEdge" containerEdge.Parent = mainContentFrame containerEdge.BackgroundColor3 = Color3.fromRGB(55, 55, 60) -- Calculate size dynamically: Full width - tab width - padding * 3 containerEdge.Size = UDim2.new(1, -(162 + 8 * 3), 1, -16) -- Adjust size based on tab width containerEdge.Position = UDim2.new(0, 162 + 8 * 2, 0, 8) -- Position next to tabs tabButtonCorner_3.CornerRadius = UDim.new(0, 4) tabButtonCorner_3.Name = "tabButtonCorner" tabButtonCorner_3.Parent = containerEdge container.Name = "container" container.Parent = containerEdge container.AnchorPoint = Vector2.new(0.5, 0.5) container.BackgroundColor3 = Color3.fromRGB(235, 235, 235) -- Hidden container.Position = UDim2.new(0.5, 0, 0.5, 0) container.Size = UDim2.new(1, -2, 1, -2) -- Fit inside edge container.ClipsDescendants = true -- Clip pages inside containerCorner.CornerRadius = UDim.new(0, 4) containerCorner.Name = "containerCorner" containerCorner.Parent = container containerGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(42, 42, 46)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(34, 34, 38))} -- Match tabs background containerGradient.Rotation = 90 containerGradient.Name = "containerGradient" containerGradient.Parent = container -- Tab Management Logic local TabLibrary = { IsFirst = true, CurrentTab = nil, -- Store the button instance CurrentPage = nil, -- Store the page instance Tabs = {}, -- Store tab info { button = btn, page = pg } Pages = {} -- Store pages { pageInstance = page } } CreateTween("tab_text_colour", 0.16, Enum.EasingStyle.Quad) CreateTween("tab_select_indicator", 0.2, Enum.EasingStyle.Quint, Enum.EasingDirection.Out) function TabLibrary:SwitchTab(button, page) if TabLibrary.CurrentPage == page then return end -- Don't switch to the same tab -- Deselect old tab if TabLibrary.CurrentTab then TweenService:Create(TabLibrary.CurrentTab, TweenTable["tab_text_colour"], { TextColor3 = Color3.fromRGB(170, 170, 170) }):Play() local oldIndicator = TabLibrary.CurrentTab:FindFirstChild("SelectionIndicator") if oldIndicator then TweenService:Create(oldIndicator, TweenTable["tab_select_indicator"], { Size = UDim2.new(0, 0, 1, 0) }):Play() end end if TabLibrary.CurrentPage then TabLibrary.CurrentPage.Visible = false end -- Select new tab page.Visible = true TweenService:Create(button, TweenTable["tab_text_colour"], { TextColor3 = Color3.fromRGB(190, 140, 255) }):Play() -- Brighter purple local indicator = button:FindFirstChild("SelectionIndicator") if indicator then TweenService:Create(indicator, TweenTable["tab_select_indicator"], { Size = UDim2.new(0, 4, 1, 0) }):Play() end TabLibrary.CurrentTab = button TabLibrary.CurrentPage = page library.CurrentTabName = button.Text -- Store name for potential saving/loading end function TabLibrary:NewTab(title) title = title or "tab" local tabButton = Instance.new("TextButton") local selectionIndicator = Instance.new("Frame") -- Indicator for selected tab local page = Instance.new("ScrollingFrame") local pageLayout = Instance.new("UIListLayout") local pagePadding = Instance.new("UIPadding") tabButton.Name = "tabButton_" .. title:gsub("%s+", "") -- Unique name tabButton.Parent = tabButtons -- Parent to ScrollingFrame tabButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255) tabButton.BackgroundTransparency = 1.000 tabButton.Size = UDim2.new(1, -8, 0, 28) -- Full width (-padding), fixed height tabButton.AutoButtonColor = false tabButton.Font = Enum.Font.GothamSemibold -- Better font tabButton.Text = title tabButton.TextColor3 = Color3.fromRGB(170, 170, 170) -- Default text color tabButton.TextSize = 14.000 -- Slightly smaller tabButton.TextXAlignment = Enum.TextXAlignment.Left -- Align text left tabButton.ClipsDescendants = true tabButton.LayoutOrder = #tabButtons:GetChildren() -- Maintain order -- Add padding inside the button local buttonTextPadding = Instance.new("UIPadding") buttonTextPadding.Parent = tabButton buttonTextPadding.PaddingLeft = UDim.new(0, 15) -- Indent text -- Selection Indicator (thin bar on the left) selectionIndicator.Name = "SelectionIndicator" selectionIndicator.Parent = tabButton selectionIndicator.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple selectionIndicator.BorderSizePixel = 0 selectionIndicator.AnchorPoint = Vector2.new(0, 0.5) selectionIndicator.Position = UDim2.new(0, 0, 0.5, 0) selectionIndicator.Size = UDim2.new(0, 0, 1, 0) -- Start hidden (0 width) selectionIndicator.ZIndex = 2 -- Above background page.Name = "page_" .. title:gsub("%s+", "") -- Unique name page.Parent = container -- Parent to the main container page.Active = true page.BackgroundColor3 = Color3.fromRGB(255, 255, 255) page.BackgroundTransparency = 1.000 -- Transparent background page.BorderSizePixel = 0 page.Size = UDim2.new(1, 0, 1, 0) -- Fill container page.Visible = false -- Start hidden page.CanvasSize = UDim2.new(0, 0, 0, 0) -- Auto calculated page.ScrollBarThickness = 6 page.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 105) -- Darker scroll bar -- page.AutomaticCanvasSize = Enum.AutomaticSize.Y -- Needs layout inside pageLayout.Name = "pageLayout" pageLayout.Parent = page -- Parent to ScrollingFrame's Canvas pageLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center pageLayout.SortOrder = Enum.SortOrder.LayoutOrder pageLayout.Padding = UDim.new(0, 6) -- Spacing between elements in page pagePadding.Name = "pagePadding" pagePadding.Parent = page pagePadding.PaddingBottom = UDim.new(0, 8) pagePadding.PaddingLeft = UDim.new(0, 8) pagePadding.PaddingRight = UDim.new(0, 8) pagePadding.PaddingTop = UDim.new(0, 8) -- Store tab info TabLibrary.Tabs[title] = { button = tabButton, page = page } TabLibrary.Pages[page] = true -- Keep track of page instances if TabLibrary.IsFirst then TabLibrary:SwitchTab(tabButton, page) -- Select the first tab TabLibrary.IsFirst = false end tabButton.MouseButton1Click:Connect(function() TabLibrary:SwitchTab(tabButton, page) end) -- Update Page Canvas Size (more robust) local function UpdatePageSize() task.wait() -- Wait a frame for layout to potentially update local contentHeight = pageLayout.AbsoluteContentSize.Y page.CanvasSize = UDim2.new(0, 0, 0, contentHeight + pagePadding.PaddingTop.Offset + pagePadding.PaddingBottom.Offset) -- DebugPrint("Updated page size for", title, "to", page.CanvasSize) end pageLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(UpdatePageSize) page.ChildAdded:Connect(UpdatePageSize) page.ChildRemoved:Connect(UpdatePageSize) UpdatePageSize() -- Initial call -- Component Functions (Attached to the returned table) -- These functions now add elements directly to the 'page' ScrollingFrame. local Components = {} -- Add component functions here (NewLabel, NewButton, NewToggle, etc.) -- Make sure they parent elements to 'page' and call UpdatePageSize() appropriately. -- Example Component: NewLabel (Adapted) function Components:NewLabel(text, alignment) text = text or "label" alignment = alignment or Enum.TextXAlignment.Left -- Use Enum directly local label = Instance.new("TextLabel") local labelPadding = Instance.new("UIPadding") -- Padding inside label label.Name = "LabelComponent" -- More specific name label.Parent = page -- Parent to the page's ScrollingFrame Canvas label.BackgroundTransparency = 1.000 label.Size = UDim2.new(1, 0, 0, 24) -- Full width, auto height would be better if wrapped label.Font = Enum.Font.Gotham -- Nicer default font label.TextColor3 = Color3.fromRGB(190, 190, 190) label.Text = text label.TextSize = 14.000 label.TextWrapped = true -- Enable wrapping label.TextXAlignment = alignment label.AutomaticSize = Enum.AutomaticSize.Y -- Auto-adjust height based on text label.RichText = true labelPadding.PaddingLeft = UDim.new(0, 4) labelPadding.PaddingRight = UDim.new(0, 4) labelPadding.Parent = label UpdatePageSize() -- Update canvas size after adding local LabelFunctions = {} function LabelFunctions:Text(newText) newText = newText or label.Text label.Text = newText UpdatePageSize() -- Text change might affect height return LabelFunctions end function LabelFunctions:Remove() label:Destroy() UpdatePageSize() return nil end function LabelFunctions:Hide() label.Visible = false UpdatePageSize() return LabelFunctions end function LabelFunctions:Show() label.Visible = true UpdatePageSize() return LabelFunctions end function LabelFunctions:Align(newAlignment) label.TextXAlignment = newAlignment or Enum.TextXAlignment.Left return LabelFunctions end return LabelFunctions end -- Section Component (Adapted) function Components:NewSection(text) text = text or "Section" local sectionFrame = Instance.new("Frame") local sectionLayout = Instance.new("UIListLayout") local leftBar = Instance.new("Frame") -- Decorative bar local sectionLabel = Instance.new("TextLabel") local rightBar = Instance.new("Frame") -- Decorative bar sectionFrame.Name = "SectionFrame" sectionFrame.Parent = page sectionFrame.BackgroundTransparency = 1.000 sectionFrame.Size = UDim2.new(1, 0, 0, 20) -- Slightly taller sectionLayout.Name = "sectionLayout" sectionLayout.Parent = sectionFrame sectionLayout.FillDirection = Enum.FillDirection.Horizontal sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder sectionLayout.VerticalAlignment = Enum.VerticalAlignment.Center sectionLayout.Padding = UDim.new(0, 8) -- More spacing -- Left Decorative Bar leftBar.Name = "leftBar" leftBar.Parent = sectionFrame leftBar.BackgroundColor3 = Color3.fromRGB(80, 80, 85) -- Section color leftBar.BorderSizePixel = 0 leftBar.Size = UDim2.new(0.2, 0, 0, 1) -- Takes up 20% width, 1px height sectionLabel.Name = "sectionLabel" sectionLabel.Parent = sectionFrame sectionLabel.BackgroundTransparency = 1.000 sectionLabel.Size = UDim2.new(0, 0, 1, 0) -- Auto width based on text sectionLabel.AutomaticSize = Enum.AutomaticSize.X sectionLabel.Font = Enum.Font.GothamSemibold sectionLabel.Text = text sectionLabel.TextColor3 = Color3.fromRGB(170, 170, 170) -- Slightly dimmer section text sectionLabel.TextSize = 13.000 sectionLabel.TextXAlignment = Enum.TextXAlignment.Center -- Center text between bars sectionLabel.RichText = true -- Right Decorative Bar rightBar.Name = "rightBar" rightBar.Parent = sectionFrame rightBar.BackgroundColor3 = Color3.fromRGB(80, 80, 85) rightBar.BorderSizePixel = 0 rightBar.Size = UDim2.new(1, 0, 0, 1) -- Fill remaining width dynamically (UISizeConstraint might be better) -- Use a constraint to make rightBar fill remaining space: local rightBarConstraint = Instance.new("UIScale") -- Using UIScale for simplicity here, might flicker. UIConstraint preferred. rightBarConstraint.Parent = rightBar UpdatePageSize() local SectionFunctions = {} function SectionFunctions:Text(new) new = new or text sectionLabel.Text = new UpdatePageSize() return SectionFunctions end function SectionFunctions:Hide() sectionFrame.Visible = false; UpdatePageSize() return SectionFunctions end function SectionFunctions:Show() sectionFrame.Visible = true; UpdatePageSize() return SectionFunctions end function SectionFunctions:Remove() sectionFrame:Destroy(); UpdatePageSize() return nil end return SectionFunctions end -- Button Component (Adapted) function Components:NewButton(text, callback) text = text or "Button" callback = callback or function() print("[SC Lib] Button '"..text.."' clicked.") end -- Main button frame to hold everything, allows for multiple buttons later local buttonContainer = Instance.new("Frame") buttonContainer.Name = "ButtonContainer" buttonContainer.Parent = page buttonContainer.BackgroundTransparency = 1 buttonContainer.Size = UDim2.new(1, 0, 0, 30) -- Standard height for button rows buttonContainer.AutomaticSize = Enum.AutomaticSize.Y -- Allow height to grow if text wraps in label? No, keep fixed. local buttonLayout = Instance.new("UIListLayout") buttonLayout.Parent = buttonContainer buttonLayout.FillDirection = Enum.FillDirection.Horizontal buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center buttonLayout.VerticalAlignment = Enum.VerticalAlignment.Center buttonLayout.SortOrder = Enum.SortOrder.LayoutOrder buttonLayout.Padding = UDim.new(0, 6) -- Spacing between multiple buttons on the same row -- The actual button element local button = Instance.new("TextButton") button.Name = "ButtonComponent" button.Parent = buttonContainer -- Parent to the container button.BackgroundColor3 = Color3.fromRGB(70, 70, 75) -- Button background button.Size = UDim2.new(1, -(buttonLayout.Padding.Offset * 2), 1, 0) -- Default: fill container width button.AutoButtonColor = false button.Font = Enum.Font.GothamSemibold button.Text = text button.TextColor3 = Color3.fromRGB(210, 210, 210) button.TextSize = 14.000 button.ClipsDescendants = true local buttonCorner = Instance.new("UICorner") buttonCorner.CornerRadius = UDim.new(0, 4) buttonCorner.Parent = button -- Hover and Click Effects local originalColor = button.BackgroundColor3 local hoverColor = Color3.fromRGB(85, 85, 90) local clickColor = Color3.fromRGB(159, 115, 255) -- SC Purple on click button.MouseEnter:Connect(function() TweenService:Create(button, TweenTable["button_hover"], { BackgroundColor3 = hoverColor }):Play() end) button.MouseLeave:Connect(function() TweenService:Create(button, TweenTable["button_hover"], { BackgroundColor3 = originalColor }):Play() end) button.MouseButton1Down:Connect(function() TweenService:Create(button, TweenTable["fast_fade"], { BackgroundColor3 = clickColor }):Play() end) button.MouseButton1Up:Connect(function() -- Return to hover color if mouse is still over, else original local mousePos = UserInputService:GetMouseLocation() local buttonPos = button.AbsolutePosition local buttonSize = button.AbsoluteSize if mousePos.X >= buttonPos.X and mousePos.X <= buttonPos.X + buttonSize.X and mousePos.Y >= buttonPos.Y and mousePos.Y <= buttonPos.Y + buttonSize.Y then TweenService:Create(button, TweenTable["button_hover"], { BackgroundColor3 = hoverColor }):Play() else TweenService:Create(button, TweenTable["button_hover"], { BackgroundColor3 = originalColor }):Play() end end) button.MouseButton1Click:Connect(function() pcall(callback) -- Wrap callback in pcall end) UpdatePageSize() local ButtonFunctions = {} local buttonElement = button -- Reference the specific button instance -- Function to add another button TO THE SAME ROW (Layout handles positioning) -- Limit to maybe 4 buttons per row for sanity. function ButtonFunctions:AddButton(addText, addCallback) if #buttonContainer:GetChildren() >= 5 then -- Limit buttons per row (1 layout + 4 buttons) warn("[SC Lib] Maximum buttons per row reached.") return ButtonFunctions -- Return original functions end addText = addText or "Button 2" addCallback = addCallback or function() print("[SC Lib] Button '"..addText.."' clicked.") end local newButton = buttonElement:Clone() -- Clone the original button in the row newButton.Name = "ButtonComponent_" .. addText:gsub("%s+", "") newButton.Text = addText newButton.Parent = buttonContainer -- Parent to the same container -- Disconnect old signals and connect new ones for the cloned button newButton:ClearAllChildren() -- Remove old corner, potentially others local newCorner = Instance.new("UICorner"); newCorner.CornerRadius = UDim.new(0,4); newCorner.Parent = newButton; newButton.MouseEnter:Connect(function() TweenService:Create(newButton, TweenTable["button_hover"], { BackgroundColor3 = hoverColor }):Play() end) newButton.MouseLeave:Connect(function() TweenService:Create(newButton, TweenTable["button_hover"], { BackgroundColor3 = originalColor }):Play() end) newButton.MouseButton1Down:Connect(function() TweenService:Create(newButton, TweenTable["fast_fade"], { BackgroundColor3 = clickColor }):Play() end) newButton.MouseButton1Up:Connect(function() local mousePos = UserInputService:GetMouseLocation(); local buttonPos = newButton.AbsolutePosition; local buttonSize = newButton.AbsoluteSize if mousePos.X >= buttonPos.X and mousePos.X <= buttonPos.X + buttonSize.X and mousePos.Y >= buttonPos.Y and mousePos.Y <= buttonPos.Y + buttonSize.Y then TweenService:Create(newButton, TweenTable["button_hover"], { BackgroundColor3 = hoverColor }):Play() else TweenService:Create(newButton, TweenTable["button_hover"], { BackgroundColor3 = originalColor }):Play() end end) newButton.MouseButton1Click:Connect(function() pcall(addCallback) end) -- Adjust sizes of all buttons in the row to fit local buttonsInRow = {} for _, child in ipairs(buttonContainer:GetChildren()) do if child:IsA("TextButton") then table.insert(buttonsInRow, child) end end local numButtons = #buttonsInRow if numButtons > 0 then local totalPadding = buttonLayout.Padding.Offset * (numButtons - 1) local availableWidth = 1 -- Scale local widthOffset = -(totalPadding) -- Subtract padding from total available offset local buttonWidthScale = availableWidth / numButtons local buttonWidthOffset = widthOffset / numButtons for _, btn in ipairs(buttonsInRow) do btn.Size = UDim2.new(buttonWidthScale, buttonWidthOffset, 1, 0) end end UpdatePageSize() -- Return functions specific to the NEWLY ADDED button local NewButtonFunctions = {} NewButtonFunctions.ButtonInstance = newButton -- Expose instance if needed function NewButtonFunctions:Fire() pcall(addCallback); return NewButtonFunctions end function NewButtonFunctions:Hide() newButton.Visible = false; return NewButtonFunctions end -- Note: Hiding might break row layout! function NewButtonFunctions:Show() newButton.Visible = true; return NewButtonFunctions end function NewButtonFunctions:Text(setText) newButton.Text = setText or addText; return NewButtonFunctions end function NewButtonFunctions:Remove() newButton:Destroy(); UpdatePageSize(); return nil end -- Removing will require recalculating layout function NewButtonFunctions:SetFunction(setFunc) addCallback = setFunc or function() end; return NewButtonFunctions end return NewButtonFunctions -- Return functions for the new button end ButtonFunctions.ButtonInstance = buttonElement -- Expose instance if needed function ButtonFunctions:Fire() pcall(callback); return ButtonFunctions end function ButtonFunctions:Hide() buttonContainer.Visible = false; UpdatePageSize(); return ButtonFunctions end -- Hide the whole row function ButtonFunctions:Show() buttonContainer.Visible = true; UpdatePageSize(); return ButtonFunctions end function ButtonFunctions:Text(setText) buttonElement.Text = setText or text; return ButtonFunctions end function ButtonFunctions:Remove() buttonContainer:Destroy(); UpdatePageSize(); return nil end -- Remove the whole row function ButtonFunctions:SetFunction(setFunc) callback = setFunc or function() end; return ButtonFunctions end return ButtonFunctions end -- Toggle Component (Adapted and Improved) function Components:NewToggle(text, default, callback) text = text or "Toggle" default = default or false callback = callback or function(state) print("[SC Lib] Toggle '"..text.."' set to:", state) end local toggleContainer = Instance.new("Frame") toggleContainer.Name = "ToggleContainer" toggleContainer.Parent = page toggleContainer.BackgroundTransparency = 1 toggleContainer.Size = UDim2.new(1, 0, 0, 24) -- Standard height local toggleLayout = Instance.new("UIListLayout") toggleLayout.Parent = toggleContainer toggleLayout.FillDirection = Enum.FillDirection.Horizontal toggleLayout.VerticalAlignment = Enum.VerticalAlignment.Center toggleLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left -- Align left toggleLayout.SortOrder = Enum.SortOrder.LayoutOrder toggleLayout.Padding = UDim.new(0, 8) -- Padding between label and switch -- Toggle Switch (Visual Element) local switchFrame = Instance.new("TextButton") -- Use button for click detection switchFrame.Name = "SwitchFrame" switchFrame.Parent = toggleContainer switchFrame.Size = UDim2.new(0, 36, 0, 18) -- Wider switch switchFrame.BackgroundColor3 = Color3.fromRGB(80, 80, 85) -- Off color switchFrame.BorderSizePixel = 0 switchFrame.AutoButtonColor = false switchFrame.Text = "" switchFrame.LayoutOrder = 2 -- Place switch after label local switchCorner = Instance.new("UICorner") switchCorner.CornerRadius = UDim.new(1, 0) -- Pill shape switchCorner.Parent = switchFrame local switchKnob = Instance.new("Frame") switchKnob.Name = "SwitchKnob" switchKnob.Parent = switchFrame switchKnob.BackgroundColor3 = Color3.fromRGB(200, 200, 200) -- Knob color switchKnob.BorderSizePixel = 0 switchKnob.Size = UDim2.new(0, 14, 0, 14) -- Smaller knob switchKnob.AnchorPoint = Vector2.new(0.5, 0.5) switchKnob.Position = UDim2.new(0, 9, 0.5, 0) -- Initial left position (padding + radius) local knobCorner = Instance.new("UICorner") knobCorner.CornerRadius = UDim.new(1, 0) -- Circular knob knobCorner.Parent = switchKnob -- Toggle Label local toggleLabel = Instance.new("TextLabel") toggleLabel.Name = "ToggleLabel" toggleLabel.Parent = toggleContainer toggleLabel.BackgroundTransparency = 1 toggleLabel.Size = UDim2.new(1, -50, 1, 0) -- Fill remaining space (-switch width - padding) toggleLabel.Font = Enum.Font.Gotham toggleLabel.Text = text toggleLabel.TextColor3 = Color3.fromRGB(190, 190, 190) toggleLabel.TextSize = 14.000 toggleLabel.TextXAlignment = Enum.TextXAlignment.Left toggleLabel.LayoutOrder = 1 -- Place label first -- State and Animation Logic local IsOn = default local function SetToggleState(state, animate) IsOn = state local targetBgColor = IsOn and Color3.fromRGB(159, 115, 255) or Color3.fromRGB(80, 80, 85) local targetKnobPos = IsOn and UDim2.new(1, -9, 0.5, 0) or UDim2.new(0, 9, 0.5, 0) local targetKnobColor = IsOn and Color3.fromRGB(230, 230, 230) or Color3.fromRGB(200, 200, 200) if animate then TweenService:Create(switchFrame, TweenTable["toggle_anim"], { BackgroundColor3 = targetBgColor }):Play() TweenService:Create(switchKnob, TweenTable["toggle_anim"], { Position = targetKnobPos, BackgroundColor3 = targetKnobColor }):Play() else switchFrame.BackgroundColor3 = targetBgColor switchKnob.Position = targetKnobPos switchKnob.BackgroundColor3 = targetKnobColor end end -- Set initial state without animation SetToggleState(IsOn, false) switchFrame.MouseButton1Click:Connect(function() SetToggleState(not IsOn, true) -- Toggle state with animation pcall(callback, IsOn) -- Fire callback end) UpdatePageSize() -- Toggle Functions local ToggleFunctions = {} function ToggleFunctions:Text(newText) toggleLabel.Text = newText or text return ToggleFunctions end function ToggleFunctions:Hide() toggleContainer.Visible = false; UpdatePageSize() return ToggleFunctions end function ToggleFunctions:Show() toggleContainer.Visible = true; UpdatePageSize() return ToggleFunctions end function ToggleFunctions:Change() -- Manually trigger change & callback SetToggleState(not IsOn, true) pcall(callback, IsOn) return ToggleFunctions end function ToggleFunctions:Remove() toggleContainer:Destroy(); UpdatePageSize() return nil end function ToggleFunctions:Set(state, fireCallback) -- Set state directly state = state or false if state ~= IsOn then -- Only change if different SetToggleState(state, true) if fireCallback == true or fireCallback == nil then -- Fire callback by default pcall(callback, IsOn) end end return ToggleFunctions end function ToggleFunctions:GetState() return IsOn end function ToggleFunctions:SetFunction(newFunc) callback = newFunc or function() end return ToggleFunctions end -- AddKeybind (adapted from original, attached to toggle) function ToggleFunctions:AddKeybind(defaultKey) defaultKey = defaultKey or Enum.KeyCode.P -- Default keybind 'P' local keybindButton = Instance.new("TextButton") keybindButton.Name = "KeybindButton" keybindButton.Parent = toggleContainer -- Add next to toggle switch keybindButton.Size = UDim2.new(0, 60, 0, 18) -- Small button for keybind display keybindButton.BackgroundColor3 = Color3.fromRGB(60, 60, 65) keybindButton.Font = Enum.Font.Code keybindButton.Text = "[" .. defaultKey.Name .. "]" -- Display key keybindButton.TextColor3 = Color3.fromRGB(150, 150, 150) keybindButton.TextSize = 11.000 keybindButton.AutoButtonColor = false keybindButton.LayoutOrder = 3 -- After label and switch local kbCorner = Instance.new("UICorner") kbCorner.CornerRadius = UDim.new(0, 3) kbCorner.Parent = keybindButton local currentKey = defaultKey local isBinding = false -- Update function for keybind text local function UpdateKeybindText(key) local keyName = key.Name -- Simple shortening for common keys if keyName:find("MouseButton") then keyName = keyName:sub(12) end if keyName == "LeftControl" or keyName == "RightControl" then keyName = "Ctrl" end if keyName == "LeftShift" or keyName == "RightShift" then keyName = "Shift" end if keyName == "LeftAlt" or keyName == "RightAlt" then keyName = "Alt" end keybindButton.Text = "[" .. keyName .. "]" keybindButton.TextSize = 11 -- Reset size in case it changed -- Auto resize button width based on text? Maybe not needed for simple keys. end UpdateKeybindText(currentKey) -- Initial text keybindButton.MouseButton1Click:Connect(function() if isBinding then return end -- Prevent multi-bind isBinding = true keybindButton.Text = "[...]" keybindButton.TextColor3 = Color3.fromRGB(200, 200, 100) -- Yellow while binding local inputConn = nil inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessed) if not gameProcessed and input.UserInputType ~= Enum.UserInputType.MouseMovement and input.KeyCode ~= Enum.KeyCode.Unknown then if inputConn then inputConn:Disconnect() end currentKey = input.KeyCode UpdateKeybindText(currentKey) keybindButton.TextColor3 = Color3.fromRGB(150, 150, 150) -- Reset color isBinding = false if inputConn then inputConn:Disconnect(); inputConn = nil end -- Ensure disconnect end end) -- Timeout for binding task.delay(5, function() if isBinding then if inputConn then inputConn:Disconnect(); inputConn = nil end UpdateKeybindText(currentKey) -- Revert text keybindButton.TextColor3 = Color3.fromRGB(150, 150, 150) isBinding = false end end) end) -- Keybind Activation Logic local keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed) if not gameProcessed and not isBinding and input.KeyCode == currentKey then local chatFocused = false -- Check if chat is focused pcall(function() local chatBar = Player.PlayerGui:FindFirstChild("Chat", true) and Player.PlayerGui.Chat:FindFirstChild("Frame", true) and Player.PlayerGui.Chat.Frame:FindFirstChild("ChatBarParentFrame", true) and Player.PlayerGui.Chat.Frame.ChatBarParentFrame:FindFirstChild("BoxFrame", true) and Player.PlayerGui.Chat.Frame.ChatBarParentFrame.BoxFrame:FindFirstChild("Frame", true) and Player.PlayerGui.Chat.Frame.ChatBarParentFrame.BoxFrame.Frame:FindFirstChild("ChatBar", true) if chatBar and chatBar:IsFocused() then chatFocused = true end end) local textboxFocused = UserInputService:GetFocusedTextBox() if not chatFocused and not textboxFocused then -- Only fire if not typing ToggleFunctions:Change() -- Use the toggle's change function end end end) -- Add function to remove keybind specifically function ToggleFunctions:RemoveKeybind() if keybindConnection then keybindConnection:Disconnect() end keybindButton:Destroy() UpdatePageSize() -- Update layout after removing button end UpdatePageSize() -- Update layout after adding button return ToggleFunctions -- Return main toggle functions end return ToggleFunctions end -- Slider Component (Adapted and Improved) function Components:NewSlider(text, min, max, default, precision, suffix, callback) text = text or "Slider" min = tonumber(min) or 0 max = tonumber(max) or 100 default = tonumber(default) or min precision = math.max(0, tonumber(precision) or 0) -- decimal places (0 for integer) suffix = suffix or "" callback = callback or function(value) print("[SC Lib] Slider '"..text.."' set to:", value) end local sliderContainer = Instance.new("Frame") sliderContainer.Name = "SliderContainer" sliderContainer.Parent = page sliderContainer.BackgroundTransparency = 1 sliderContainer.Size = UDim2.new(1, 0, 0, 40) -- Taller to fit label and slider local sliderLayout = Instance.new("UIListLayout") -- Vertical layout sliderLayout.Parent = sliderContainer sliderLayout.FillDirection = Enum.FillDirection.Vertical sliderLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center sliderLayout.VerticalAlignment = Enum.VerticalAlignment.Top sliderLayout.SortOrder = Enum.SortOrder.LayoutOrder sliderLayout.Padding = UDim.new(0, 4) -- Space between label and slider bar -- Label Row (Label + Value) local labelRow = Instance.new("Frame") labelRow.Name = "LabelRow" labelRow.Parent = sliderContainer labelRow.BackgroundTransparency = 1 labelRow.Size = UDim2.new(1, 0, 0, 16) -- Height for text local labelRowLayout = Instance.new("UIListLayout") labelRowLayout.Parent = labelRow labelRowLayout.FillDirection = Enum.FillDirection.Horizontal labelRowLayout.VerticalAlignment = Enum.VerticalAlignment.Center labelRowLayout.Padding = UDim.new(0, 10) local sliderLabel = Instance.new("TextLabel") sliderLabel.Name = "SliderLabel" sliderLabel.Parent = labelRow sliderLabel.BackgroundTransparency = 1 sliderLabel.Size = UDim2.new(0.6, 0, 1, 0) -- ~60% width sliderLabel.Font = Enum.Font.Gotham sliderLabel.Text = text sliderLabel.TextColor3 = Color3.fromRGB(190, 190, 190) sliderLabel.TextSize = 14.000 sliderLabel.TextXAlignment = Enum.TextXAlignment.Left local valueLabel = Instance.new("TextLabel") valueLabel.Name = "ValueLabel" valueLabel.Parent = labelRow valueLabel.BackgroundTransparency = 1 valueLabel.Size = UDim2.new(0.4, -10, 1, 0) -- Remaining width valueLabel.Font = Enum.Font.Code -- Monospace for value valueLabel.TextColor3 = Color3.fromRGB(160, 160, 160) valueLabel.TextSize = 13.000 valueLabel.TextXAlignment = Enum.TextXAlignment.Right -- Slider Bar Row local sliderBarRow = Instance.new("Frame") sliderBarRow.Name = "SliderBarRow" sliderBarRow.Parent = sliderContainer sliderBarRow.BackgroundTransparency = 1 sliderBarRow.Size = UDim2.new(1, 0, 0, 16) -- Height for slider bar sliderBarRow.ClipsDescendants = true -- Clip the fill indicator local sliderTrack = Instance.new("Frame") -- The background track sliderTrack.Name = "SliderTrack" sliderTrack.Parent = sliderBarRow sliderTrack.BackgroundColor3 = Color3.fromRGB(60, 60, 65) -- Track color sliderTrack.BorderSizePixel = 0 sliderTrack.AnchorPoint = Vector2.new(0, 0.5) sliderTrack.Position = UDim2.new(0, 0, 0.5, 0) sliderTrack.Size = UDim2.new(1, 0, 0, 6) -- Thin track local trackCorner = Instance.new("UICorner") trackCorner.CornerRadius = UDim.new(1, 0) -- Pill shape trackCorner.Parent = sliderTrack local sliderFill = Instance.new("Frame") -- The value indicator fill sliderFill.Name = "SliderFill" sliderFill.Parent = sliderTrack -- Parent to track for easy sizing sliderFill.BackgroundColor3 = Color3.fromRGB(159, 115, 255) -- SC Purple sliderFill.BorderSizePixel = 0 sliderFill.Size = UDim2.new(0, 0, 1, 0) -- Starts at 0 width sliderFill.ZIndex = 2 local fillCorner = Instance.new("UICorner") fillCorner.CornerRadius = UDim.new(1, 0) fillCorner.Parent = sliderFill -- Clickable Area (Transparent button over the track) local sliderButton = Instance.new("TextButton") sliderButton.Name = "SliderButton" sliderButton.Parent = sliderBarRow sliderButton.BackgroundTransparency = 1 sliderButton.Size = UDim2.new(1, 0, 1, 0) -- Cover the whole row area sliderButton.Text = "" sliderButton.AutoButtonColor = false sliderButton.ZIndex = 3 -- Above track/fill -- State and Logic local CurrentValue = default local MouseIsDown = false local function UpdateSliderFromValue(value, fireCallback) CurrentValue = math.clamp(value, min, max) CurrentValue = library:RoundNumber(precision, CurrentValue) -- Apply precision valueLabel.Text = string.format("%." .. precision .. "f", CurrentValue) .. suffix local percentage = (CurrentValue - min) / (max - min) if (max - min) == 0 then percentage = 0 end -- Avoid division by zero if min=max sliderFill.Size = UDim2.new(percentage, 0, 1, 0) if fireCallback ~= false then -- Fire callback unless explicitly told not to pcall(callback, CurrentValue) end end local function UpdateSliderFromMouse(mouseX) local trackPos = sliderTrack.AbsolutePosition.X local trackSize = sliderTrack.AbsoluteSize.X local relativeX = math.clamp(mouseX - trackPos, 0, trackSize) local percentage = relativeX / trackSize local newValue = min + (max - min) * percentage UpdateSliderFromValue(newValue) -- This fires the callback end -- Input Handling sliderButton.MouseButton1Down:Connect(function() MouseIsDown = true UpdateSliderFromMouse(Mouse.X) -- Update immediately on click end) UserInputService.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then MouseIsDown = false end end) UserInputService.InputChanged:Connect(function(input) if MouseIsDown and input.UserInputType == Enum.UserInputType.MouseMovement then UpdateSliderFromMouse(input.Position.X) end end) -- Initialize UpdateSliderFromValue(CurrentValue, false) -- Set initial state without firing callback UpdatePageSize() -- Slider Functions local SliderFunctions = {} function SliderFunctions:Value(newValue, fireCallback) -- Allows setting value manually UpdateSliderFromValue(newValue, fireCallback) return SliderFunctions end function SliderFunctions:Max(newMax) max = tonumber(newMax) or max; UpdateSliderFromValue(CurrentValue, false) return SliderFunctions end function SliderFunctions:Min(newMin) min = tonumber(newMin) or min; UpdateSliderFromValue(CurrentValue, false) return SliderFunctions end function SliderFunctions:SetFunction(newFunc) callback = newFunc or function() end return SliderFunctions end function SliderFunctions:Text(newText) -- Set the label text sliderLabel.Text = newText or text return SliderFunctions end function SliderFunctions:Hide() sliderContainer.Visible = false; UpdatePageSize() return SliderFunctions end function SliderFunctions:Show() sliderContainer.Visible = true; UpdatePageSize() return SliderFunctions end function SliderFunctions:Remove() sliderContainer:Destroy(); UpdatePageSize() return nil end function SliderFunctions:GetValue() return CurrentValue end return SliderFunctions end -- Add other components (Textbox, Selector, Keybind, Separator) adapted similarly... -- Make sure they parent correctly to 'page', use consistent styling, and call UpdatePageSize. -- Helper to open this specific tab function Components:Open() TabLibrary:SwitchTab(tabButton, page) return Components end function Components:Remove() tabButton:Destroy() page:Destroy() TabLibrary.Tabs[title] = nil TabLibrary.Pages[page] = nil -- Need logic to select another tab if the current one is removed if TabLibrary.CurrentPage == page then TabLibrary.CurrentTab = nil TabLibrary.CurrentPage = nil -- Select first available tab? local firstTitle = next(TabLibrary.Tabs) if firstTitle then TabLibrary:SwitchTab(TabLibrary.Tabs[firstTitle].button, TabLibrary.Tabs[firstTitle].page) end end UpdatePageSize() -- Update the *tab button* layout return nil end function Components:Hide() tabButton.Visible = false if TabLibrary.CurrentPage == page then TabLibrary:SwitchTab(nil, nil) -- Deselect if hidden end page.Visible = false -- Ensure page is hidden too return Components end function Components:Show() tabButton.Visible = true -- Consider if showing should automatically select it? Maybe not. return Components end function Components:Text(newText) tabButton.Text = newText or title -- Update internal tracking if title changes? Risky. Better to keep title consistent. return Components end return Components end -- End of NewTab function -- Library functions related to tabs/main UI function TabLibrary:Remove() screen:Destroy() library:StopUsageTimer() -- Ensure timer stops if GUI is removed isGuiActive = false return nil end function TabLibrary:Text(text) -- Set main header text headerLabel.Text = text or library.title return TabLibrary end function TabLibrary:UpdateKeybind(new) keybind = new or keybind return TabLibrary end DebugPrint("library:Init finished setup.") return TabLibrary end -- End of library:Init -- Final step: Assign the main Init function correctly -- library.Init = library:Init -- This assignment seems redundant if defined as library:Init directly. -- / Startup Sequence -- 1. Request Key local keyCoroutine = library:RequestKey() -- Wait for authentication before proceeding (This might yield if called directly) -- We need to wait for the coroutine to set isAuthenticated = true -- How to wait for a coroutine flag? Use a loop or signals. -- Simple wait loop (can freeze if key prompt fails/hangs) --[[ while not isAuthenticated and task.wait(0.1) do -- Optional: Add a timeout condition here if not CoreGuiService:FindFirstChild("SC_KeyPrompt") then warn("Key prompt disappeared unexpectedly.") -- Potentially stop the script here depending on desired behavior return library -- Return partially initialized library? Or error? break end end ]] -- Alternative: Structure code so Init is called *from* the key prompt success callback. -- The current key prompt implementation already does this by calling library:Introduction() -- and library:StartUsageTimer() upon success, and Introduction calls InitializeMainGui which calls library:Init. -- So, direct call here is unnecessary if the key prompt flow works. -- If script needs to return the library object immediately, authentication must be handled differently, -- maybe by disabling UI elements until authenticated. -- For this structure, we rely on the key prompt initiating the next steps. DebugPrint("SC Lib Core Initialized. Waiting for Key Authentication...") return library
